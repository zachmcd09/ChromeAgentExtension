"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AdminClient: () => AdminClient,
  ChromaClient: () => ChromaClient,
  CloudClient: () => CloudClient,
  CohereEmbeddingFunction: () => CohereEmbeddingFunction,
  DefaultEmbeddingFunction: () => DefaultEmbeddingFunction,
  GoogleGenerativeAiEmbeddingFunction: () => GoogleGenerativeAiEmbeddingFunction,
  HuggingFaceEmbeddingServerFunction: () => HuggingFaceEmbeddingServerFunction,
  JinaEmbeddingFunction: () => JinaEmbeddingFunction,
  OllamaEmbeddingFunction: () => OllamaEmbeddingFunction,
  OpenAIEmbeddingFunction: () => OpenAIEmbeddingFunction,
  TransformersEmbeddingFunction: () => TransformersEmbeddingFunction
});
module.exports = __toCommonJS(src_exports);

// src/generated/runtime.ts
var import_isomorphic_fetch = require("isomorphic-fetch");
var defaultFetch = fetch;
var BASE_PATH = "";
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, fetch2 = defaultFetch) {
    this.basePath = basePath;
    this.fetch = fetch2;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class _RequiredError extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    Object.setPrototypeOf(this, _RequiredError.prototype);
    this.name = "RequiredError";
  }
};

// src/generated/api.ts
var ApiApiFetchParamCreator = function(configuration) {
  return {
    /**
     * @summary Add
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(tenant, databaseName, collectionId, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling add.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling add.");
      }
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling add.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling add.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/add`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Add V1
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    addV1(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling addV1.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling addV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/add`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Delete
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.DeleteEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aDelete(collectionId, tenant, databaseName, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling aDelete.");
      }
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling aDelete.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling aDelete.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling aDelete.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/delete`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.GetEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aGet(collectionId, tenant, databaseName, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling aGet.");
      }
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling aGet.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling aGet.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling aGet.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/get`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Count
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    count(tenant, databaseName, collectionId, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling count.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling count.");
      }
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling count.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/count`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Count Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollections(tenant, databaseName, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling countCollections.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling countCollections.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections_count`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Count Collections V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollectionsV1(tenant, database, options = {}) {
      let localVarPath = `/api/v1/count_collections`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      if (database !== void 0) {
        localVarQueryParameter.append("database", String(database));
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Count V1
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countV1(collectionId, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling countV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/count`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Create Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.CreateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(tenant, databaseName, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling createCollection.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling createCollection.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling createCollection.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Create Collection V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {Api.CreateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollectionV1(tenant, database, request, options = {}) {
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling createCollectionV1.");
      }
      let localVarPath = `/api/v1/collections`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      if (database !== void 0) {
        localVarQueryParameter.append("database", String(database));
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Create Database
     * @param {string} tenant
     * @param {Api.CreateDatabase} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabase(tenant, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling createDatabase.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling createDatabase.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases`.replace("{tenant}", encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Create Database V1
     * @param {string} [tenant]
     * @param {Api.CreateDatabase} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabaseV1(tenant, request, options = {}) {
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling createDatabaseV1.");
      }
      let localVarPath = `/api/v1/databases`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Create Tenant
     * @param {Api.CreateTenant} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant(request, options = {}) {
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling createTenant.");
      }
      let localVarPath = `/api/v2/tenants`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Create Tenant V1
     * @param {Api.CreateTenant} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenantV1(request, options = {}) {
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling createTenantV1.");
      }
      let localVarPath = `/api/v1/tenants`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(collectionName, tenant, databaseName, options = {}) {
      if (collectionName === null || collectionName === void 0) {
        throw new RequiredError("collectionName", "Required parameter collectionName was null or undefined when calling deleteCollection.");
      }
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling deleteCollection.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling deleteCollection.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_name}`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_name}", encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "DELETE" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Delete Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollectionV1(collectionName, tenant, database, options = {}) {
      if (collectionName === null || collectionName === void 0) {
        throw new RequiredError("collectionName", "Required parameter collectionName was null or undefined when calling deleteCollectionV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_name}`.replace("{collection_name}", encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "DELETE" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      if (database !== void 0) {
        localVarQueryParameter.append("database", String(database));
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Delete V1
     * @param {string} collectionId
     * @param {Api.DeleteEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteV1(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling deleteV1.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling deleteV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/delete`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(tenant, databaseName, collectionName, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling getCollection.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling getCollection.");
      }
      if (collectionName === null || collectionName === void 0) {
        throw new RequiredError("collectionName", "Required parameter collectionName was null or undefined when calling getCollection.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_name}`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_name}", encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionV1(collectionName, tenant, database, options = {}) {
      if (collectionName === null || collectionName === void 0) {
        throw new RequiredError("collectionName", "Required parameter collectionName was null or undefined when calling getCollectionV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_name}`.replace("{collection_name}", encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      if (database !== void 0) {
        localVarQueryParameter.append("database", String(database));
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Database
     * @param {string} databaseName
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabase(databaseName, tenant, options = {}) {
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling getDatabase.");
      }
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling getDatabase.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Database V1
     * @param {string} database
     * @param {string} [tenant]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabaseV1(database, tenant, options = {}) {
      if (database === null || database === void 0) {
        throw new RequiredError("database", "Required parameter database was null or undefined when calling getDatabaseV1.");
      }
      let localVarPath = `/api/v1/databases/{database}`.replace("{database}", encodeURIComponent(String(database)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Nearest Neighbors
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.QueryEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighbors(tenant, databaseName, collectionId, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling getNearestNeighbors.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling getNearestNeighbors.");
      }
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling getNearestNeighbors.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling getNearestNeighbors.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/query`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Nearest Neighbors V1
     * @param {string} collectionId
     * @param {Api.QueryEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighborsV1(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling getNearestNeighborsV1.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling getNearestNeighborsV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/query`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Tenant
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant(tenant, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling getTenant.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}`.replace("{tenant}", encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get Tenant V1
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantV1(tenant, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling getTenantV1.");
      }
      let localVarPath = `/api/v1/tenants/{tenant}`.replace("{tenant}", encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get User Identity
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentity(options = {}) {
      let localVarPath = `/api/v2/auth/identity`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV11(options = {}) {
      let localVarPath = `/api/v1`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Get V1
     * @param {string} collectionId
     * @param {Api.GetEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV12(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling getV12.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling getV12.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/get`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1Heartbeat(options = {}) {
      let localVarPath = `/api/v1/heartbeat`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1PreFlightChecks(options = {}) {
      let localVarPath = `/api/v1/pre-flight-checks`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1Version(options = {}) {
      let localVarPath = `/api/v1/version`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2(options = {}) {
      let localVarPath = `/api/v2`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2Heartbeat(options = {}) {
      let localVarPath = `/api/v2/heartbeat`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2PreFlightChecks(options = {}) {
      let localVarPath = `/api/v2/pre-flight-checks`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2Version(options = {}) {
      let localVarPath = `/api/v2/version`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary List Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(tenant, databaseName, limit, offset, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling listCollections.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling listCollections.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (limit !== void 0) {
        localVarQueryParameter.append("limit", String(limit));
      }
      if (offset !== void 0) {
        localVarQueryParameter.append("offset", String(offset));
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary List Collections V1
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionsV1(limit, offset, tenant, database, options = {}) {
      let localVarPath = `/api/v1/collections`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      if (limit !== void 0) {
        localVarQueryParameter.append("limit", String(limit));
      }
      if (offset !== void 0) {
        localVarQueryParameter.append("offset", String(offset));
      }
      if (tenant !== void 0) {
        localVarQueryParameter.append("tenant", String(tenant));
      }
      if (database !== void 0) {
        localVarQueryParameter.append("database", String(database));
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    postV1Reset(options = {}) {
      let localVarPath = `/api/v1/reset`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    postV2Reset(options = {}) {
      let localVarPath = `/api/v2/reset`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarRequestOptions.headers = localVarHeaderParameter;
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Update
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(tenant, databaseName, collectionId, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling update.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling update.");
      }
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling update.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling update.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/update`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Update Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(tenant, databaseName, collectionId, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling updateCollection.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling updateCollection.");
      }
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling updateCollection.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling updateCollection.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Update Collection V1
     * @param {string} collectionId
     * @param {Api.UpdateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollectionV1(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling updateCollectionV1.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling updateCollectionV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Update V1
     * @param {string} collectionId
     * @param {Api.UpdateEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateV1(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling updateV1.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling updateV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/update`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Upsert
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsert(tenant, databaseName, collectionId, request, options = {}) {
      if (tenant === null || tenant === void 0) {
        throw new RequiredError("tenant", "Required parameter tenant was null or undefined when calling upsert.");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("databaseName", "Required parameter databaseName was null or undefined when calling upsert.");
      }
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling upsert.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling upsert.");
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/upsert`.replace("{tenant}", encodeURIComponent(String(tenant))).replace("{database_name}", encodeURIComponent(String(databaseName))).replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    },
    /**
     * @summary Upsert V1
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertV1(collectionId, request, options = {}) {
      if (collectionId === null || collectionId === void 0) {
        throw new RequiredError("collectionId", "Required parameter collectionId was null or undefined when calling upsertV1.");
      }
      if (request === null || request === void 0) {
        throw new RequiredError("request", "Required parameter request was null or undefined when calling upsertV1.");
      }
      let localVarPath = `/api/v1/collections/{collection_id}/upsert`.replace("{collection_id}", encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }
      localVarHeaderParameter.set("Content-Type", "application/json");
      localVarRequestOptions.headers = localVarHeaderParameter;
      if (request !== void 0) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }
      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions
      };
    }
  };
};
var ApiApiFp = function(configuration) {
  return {
    /**
     * @summary Add
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(tenant, databaseName, collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).add(tenant, databaseName, collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 201) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Add V1
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    addV1(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).addV1(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 201) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.DeleteEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aDelete(collectionId, tenant, databaseName, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).aDelete(collectionId, tenant, databaseName, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.GetEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aGet(collectionId, tenant, databaseName, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).aGet(collectionId, tenant, databaseName, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    count(tenant, databaseName, collectionId, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).count(tenant, databaseName, collectionId, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollections(tenant, databaseName, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countCollections(tenant, databaseName, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count Collections V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollectionsV1(tenant, database, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countCollectionsV1(tenant, database, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count V1
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countV1(collectionId, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countV1(collectionId, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.CreateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(tenant, databaseName, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createCollection(tenant, databaseName, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Collection V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {Api.CreateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollectionV1(tenant, database, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createCollectionV1(tenant, database, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Database
     * @param {string} tenant
     * @param {Api.CreateDatabase} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabase(tenant, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createDatabase(tenant, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Database V1
     * @param {string} [tenant]
     * @param {Api.CreateDatabase} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabaseV1(tenant, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createDatabaseV1(tenant, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Tenant
     * @param {Api.CreateTenant} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant(request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createTenant(request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Tenant V1
     * @param {Api.CreateTenant} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenantV1(request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createTenantV1(request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(collectionName, tenant, databaseName, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteCollection(collectionName, tenant, databaseName, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollectionV1(collectionName, tenant, database, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteCollectionV1(collectionName, tenant, database, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete V1
     * @param {string} collectionId
     * @param {Api.DeleteEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteV1(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteV1(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(tenant, databaseName, collectionName, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getCollection(tenant, databaseName, collectionName, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionV1(collectionName, tenant, database, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getCollectionV1(collectionName, tenant, database, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Database
     * @param {string} databaseName
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabase(databaseName, tenant, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getDatabase(databaseName, tenant, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Database V1
     * @param {string} database
     * @param {string} [tenant]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabaseV1(database, tenant, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getDatabaseV1(database, tenant, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Nearest Neighbors
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.QueryEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighbors(tenant, databaseName, collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getNearestNeighbors(tenant, databaseName, collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Nearest Neighbors V1
     * @param {string} collectionId
     * @param {Api.QueryEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighborsV1(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getNearestNeighborsV1(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Tenant
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant(tenant, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getTenant(tenant, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Tenant V1
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantV1(tenant, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getTenantV1(tenant, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get User Identity
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentity(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getUserIdentity(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV11(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV11(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get V1
     * @param {string} collectionId
     * @param {Api.GetEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV12(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV12(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1Heartbeat(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV1Heartbeat(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1PreFlightChecks(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV1PreFlightChecks(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1Version(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV1Version(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV2(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2Heartbeat(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV2Heartbeat(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2PreFlightChecks(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV2PreFlightChecks(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2Version(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV2Version(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary List Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(tenant, databaseName, limit, offset, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listCollections(tenant, databaseName, limit, offset, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary List Collections V1
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionsV1(limit, offset, tenant, database, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listCollectionsV1(limit, offset, tenant, database, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    postV1Reset(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).postV1Reset(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    postV2Reset(options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).postV2Reset(options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(tenant, databaseName, collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).update(tenant, databaseName, collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(tenant, databaseName, collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateCollection(tenant, databaseName, collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update Collection V1
     * @param {string} collectionId
     * @param {Api.UpdateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollectionV1(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateCollectionV1(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update V1
     * @param {string} collectionId
     * @param {Api.UpdateEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateV1(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateV1(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Upsert
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsert(tenant, databaseName, collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).upsert(tenant, databaseName, collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Upsert V1
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertV1(collectionId, request, options) {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).upsertV1(collectionId, request, options);
      return (fetch2 = defaultFetch, basePath = BASE_PATH) => {
        return fetch2(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get("Content-Type");
          const mimeType = contentType ? contentType.replace(/;.*/, "") : void 0;
          if (response.status === 200) {
            if (mimeType === "application/json") {
              return response.json();
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === "application/json") {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    }
  };
};
var ApiApi = class extends BaseAPI {
  /**
   * @summary Add
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.AddEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  add(tenant, databaseName, collectionId, request, options) {
    return ApiApiFp(this.configuration).add(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Add V1
   * @param {string} collectionId
   * @param {Api.AddEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  addV1(collectionId, request, options) {
    return ApiApiFp(this.configuration).addV1(collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Delete
   * @param {string} collectionId
   * @param {string} tenant
   * @param {string} databaseName
   * @param {Api.DeleteEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  aDelete(collectionId, tenant, databaseName, request, options) {
    return ApiApiFp(this.configuration).aDelete(collectionId, tenant, databaseName, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get
   * @param {string} collectionId
   * @param {string} tenant
   * @param {string} databaseName
   * @param {Api.GetEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  aGet(collectionId, tenant, databaseName, request, options) {
    return ApiApiFp(this.configuration).aGet(collectionId, tenant, databaseName, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Count
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  count(tenant, databaseName, collectionId, options) {
    return ApiApiFp(this.configuration).count(tenant, databaseName, collectionId, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Count Collections
   * @param {string} tenant
   * @param {string} databaseName
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  countCollections(tenant, databaseName, options) {
    return ApiApiFp(this.configuration).countCollections(tenant, databaseName, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Count Collections V1
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  countCollectionsV1(tenant, database, options) {
    return ApiApiFp(this.configuration).countCollectionsV1(tenant, database, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Count V1
   * @param {string} collectionId
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  countV1(collectionId, options) {
    return ApiApiFp(this.configuration).countV1(collectionId, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Create Collection
   * @param {string} tenant
   * @param {string} databaseName
   * @param {Api.CreateCollection} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  createCollection(tenant, databaseName, request, options) {
    return ApiApiFp(this.configuration).createCollection(tenant, databaseName, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Create Collection V1
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {Api.CreateCollection} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  createCollectionV1(tenant, database, request, options) {
    return ApiApiFp(this.configuration).createCollectionV1(tenant, database, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Create Database
   * @param {string} tenant
   * @param {Api.CreateDatabase} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  createDatabase(tenant, request, options) {
    return ApiApiFp(this.configuration).createDatabase(tenant, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Create Database V1
   * @param {string} [tenant]
   * @param {Api.CreateDatabase} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  createDatabaseV1(tenant, request, options) {
    return ApiApiFp(this.configuration).createDatabaseV1(tenant, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Create Tenant
   * @param {Api.CreateTenant} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  createTenant(request, options) {
    return ApiApiFp(this.configuration).createTenant(request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Create Tenant V1
   * @param {Api.CreateTenant} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  createTenantV1(request, options) {
    return ApiApiFp(this.configuration).createTenantV1(request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Delete Collection
   * @param {string} collectionName
   * @param {string} tenant
   * @param {string} databaseName
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteCollection(collectionName, tenant, databaseName, options) {
    return ApiApiFp(this.configuration).deleteCollection(collectionName, tenant, databaseName, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Delete Collection V1
   * @param {string} collectionName
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteCollectionV1(collectionName, tenant, database, options) {
    return ApiApiFp(this.configuration).deleteCollectionV1(collectionName, tenant, database, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Delete V1
   * @param {string} collectionId
   * @param {Api.DeleteEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteV1(collectionId, request, options) {
    return ApiApiFp(this.configuration).deleteV1(collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Collection
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionName
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getCollection(tenant, databaseName, collectionName, options) {
    return ApiApiFp(this.configuration).getCollection(tenant, databaseName, collectionName, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Collection V1
   * @param {string} collectionName
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getCollectionV1(collectionName, tenant, database, options) {
    return ApiApiFp(this.configuration).getCollectionV1(collectionName, tenant, database, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Database
   * @param {string} databaseName
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getDatabase(databaseName, tenant, options) {
    return ApiApiFp(this.configuration).getDatabase(databaseName, tenant, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Database V1
   * @param {string} database
   * @param {string} [tenant]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getDatabaseV1(database, tenant, options) {
    return ApiApiFp(this.configuration).getDatabaseV1(database, tenant, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Nearest Neighbors
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.QueryEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getNearestNeighbors(tenant, databaseName, collectionId, request, options) {
    return ApiApiFp(this.configuration).getNearestNeighbors(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Nearest Neighbors V1
   * @param {string} collectionId
   * @param {Api.QueryEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getNearestNeighborsV1(collectionId, request, options) {
    return ApiApiFp(this.configuration).getNearestNeighborsV1(collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Tenant
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getTenant(tenant, options) {
    return ApiApiFp(this.configuration).getTenant(tenant, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get Tenant V1
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getTenantV1(tenant, options) {
    return ApiApiFp(this.configuration).getTenantV1(tenant, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get User Identity
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getUserIdentity(options) {
    return ApiApiFp(this.configuration).getUserIdentity(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Root
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV11(options) {
    return ApiApiFp(this.configuration).getV11(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Get V1
   * @param {string} collectionId
   * @param {Api.GetEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV12(collectionId, request, options) {
    return ApiApiFp(this.configuration).getV12(collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Heartbeat
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV1Heartbeat(options) {
    return ApiApiFp(this.configuration).getV1Heartbeat(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Pre Flight Checks
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV1PreFlightChecks(options) {
    return ApiApiFp(this.configuration).getV1PreFlightChecks(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Version
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV1Version(options) {
    return ApiApiFp(this.configuration).getV1Version(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Root
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV2(options) {
    return ApiApiFp(this.configuration).getV2(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Heartbeat
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV2Heartbeat(options) {
    return ApiApiFp(this.configuration).getV2Heartbeat(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Pre Flight Checks
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV2PreFlightChecks(options) {
    return ApiApiFp(this.configuration).getV2PreFlightChecks(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Version
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  getV2Version(options) {
    return ApiApiFp(this.configuration).getV2Version(options)(this.fetch, this.basePath);
  }
  /**
   * @summary List Collections
   * @param {string} tenant
   * @param {string} databaseName
   * @param {number | null} [limit]
   * @param {number | null} [offset]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  listCollections(tenant, databaseName, limit, offset, options) {
    return ApiApiFp(this.configuration).listCollections(tenant, databaseName, limit, offset, options)(this.fetch, this.basePath);
  }
  /**
   * @summary List Collections V1
   * @param {number | null} [limit]
   * @param {number | null} [offset]
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  listCollectionsV1(limit, offset, tenant, database, options) {
    return ApiApiFp(this.configuration).listCollectionsV1(limit, offset, tenant, database, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Reset
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  postV1Reset(options) {
    return ApiApiFp(this.configuration).postV1Reset(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Reset
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  postV2Reset(options) {
    return ApiApiFp(this.configuration).postV2Reset(options)(this.fetch, this.basePath);
  }
  /**
   * @summary Update
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.UpdateEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  update(tenant, databaseName, collectionId, request, options) {
    return ApiApiFp(this.configuration).update(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Update Collection
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.UpdateCollection} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  updateCollection(tenant, databaseName, collectionId, request, options) {
    return ApiApiFp(this.configuration).updateCollection(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Update Collection V1
   * @param {string} collectionId
   * @param {Api.UpdateCollection} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  updateCollectionV1(collectionId, request, options) {
    return ApiApiFp(this.configuration).updateCollectionV1(collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Update V1
   * @param {string} collectionId
   * @param {Api.UpdateEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  updateV1(collectionId, request, options) {
    return ApiApiFp(this.configuration).updateV1(collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Upsert
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.AddEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  upsert(tenant, databaseName, collectionId, request, options) {
    return ApiApiFp(this.configuration).upsert(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }
  /**
   * @summary Upsert V1
   * @param {string} collectionId
   * @param {Api.AddEmbedding} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  upsertV1(collectionId, request, options) {
    return ApiApiFp(this.configuration).upsertV1(collectionId, request, options)(this.fetch, this.basePath);
  }
};

// src/generated/models.ts
var Api;
((Api2) => {
  let IncludeEnum;
  ((IncludeEnum2) => {
    IncludeEnum2["Documents"] = "documents";
    IncludeEnum2["Embeddings"] = "embeddings";
    IncludeEnum2["Metadatas"] = "metadatas";
    IncludeEnum2["Distances"] = "distances";
    IncludeEnum2["Uris"] = "uris";
    IncludeEnum2["Data"] = "data";
  })(IncludeEnum = Api2.IncludeEnum || (Api2.IncludeEnum = {}));
})(Api || (Api = {}));

// src/generated/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.authorization = param.authorization;
    this.basePath = param.basePath;
  }
};

// src/Errors.ts
var ChromaError = class extends Error {
  constructor(name, message, cause) {
    super(message);
    this.cause = cause;
    this.name = name;
  }
};
var ChromaConnectionError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaConnectionError";
  }
};
var ChromaServerError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaServerError";
  }
};
var ChromaClientError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaClientError";
  }
};
var ChromaUnauthorizedError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaAuthError";
  }
};
var ChromaForbiddenError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaForbiddenError";
  }
};
var ChromaNotFoundError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaNotFoundError";
  }
};
var ChromaValueError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaValueError";
  }
};
var InvalidCollectionError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "InvalidCollectionError";
  }
};
var InvalidArgumentError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "InvalidArgumentError";
  }
};
var ChromaUniqueError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ChromaUniqueError";
  }
};
function createErrorByType(type, message) {
  switch (type) {
    case "InvalidCollection":
      return new InvalidCollectionError(message);
    case "InvalidArgumentError":
      return new InvalidArgumentError(message);
    default:
      return void 0;
  }
}

// src/Collection.ts
var Collection = class {
  /**
   * @ignore
   */
  constructor(name, id, client, embeddingFunction, metadata) {
    this.name = name;
    this.id = id;
    this.metadata = metadata;
    this.client = client;
    this.embeddingFunction = embeddingFunction;
  }
  /**
   * Add items to the collection
   * @param {Object} params - The parameters for the query.
   * @param {ID | IDs} [params.ids] - IDs of the items to add.
   * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
   * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
   * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
   * @returns {Promise<AddResponse>} - The response from the API. True if successful.
   *
   * @example
   * ```typescript
   * const response = await collection.add({
   *   ids: ["id1", "id2"],
   *   embeddings: [[1, 2, 3], [4, 5, 6]],
   *   metadatas: [{ "key": "value" }, { "key": "value" }],
   *   documents: ["document1", "document2"]
   * });
   * ```
   */
  async add(params) {
    await this.client.init();
    await this.client.api.add(
      this.client.tenant,
      this.client.database,
      this.id,
      // TODO: For some reason the auto generated code requires metadata to be defined here.
      await prepareRecordRequest(
        params,
        this.embeddingFunction
      ),
      this.client.api.options
    );
  }
  /**
   * Upsert items to the collection
   * @param {Object} params - The parameters for the query.
   * @param {ID | IDs} [params.ids] - IDs of the items to add.
   * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
   * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
   * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
   * @returns {Promise<void>}
   *
   * @example
   * ```typescript
   * const response = await collection.upsert({
   *   ids: ["id1", "id2"],
   *   embeddings: [[1, 2, 3], [4, 5, 6]],
   *   metadatas: [{ "key": "value" }, { "key": "value" }],
   *   documents: ["document1", "document2"],
   * });
   * ```
   */
  async upsert(params) {
    await this.client.init();
    await this.client.api.upsert(
      this.client.tenant,
      this.client.database,
      this.id,
      // TODO: For some reason the auto generated code requires metadata to be defined here.
      await prepareRecordRequest(
        params,
        this.embeddingFunction
      ),
      this.client.api.options
    );
  }
  /**
   * Count the number of items in the collection
   * @returns {Promise<number>} - The number of items in the collection.
   *
   * @example
   * ```typescript
   * const count = await collection.count();
   * ```
   */
  async count() {
    await this.client.init();
    return await this.client.api.count(
      this.client.tenant,
      this.client.database,
      this.id,
      this.client.api.options
    );
  }
  /**
   * Get items from the collection
   * @param {Object} params - The parameters for the query.
   * @param {ID | IDs} [params.ids] - Optional IDs of the items to get.
   * @param {Where} [params.where] - Optional where clause to filter items by.
   * @param {PositiveInteger} [params.limit] - Optional limit on the number of items to get.
   * @param {PositiveInteger} [params.offset] - Optional offset on the items to get.
   * @param {IncludeEnum[]} [params.include] - Optional list of items to include in the response.
   * @param {WhereDocument} [params.whereDocument] - Optional where clause to filter items by.
   * @returns {Promise<GetResponse>} - The response from the server.
   *
   * @example
   * ```typescript
   * const response = await collection.get({
   *   ids: ["id1", "id2"],
   *   where: { "key": "value" },
   *   limit: 10,
   *   offset: 0,
   *   include: ["embeddings", "metadatas", "documents"],
   *   whereDocument: { $contains: "value" },
   * });
   * ```
   */
  async get({
    ids,
    where,
    limit,
    offset,
    include,
    whereDocument
  } = {}) {
    await this.client.init();
    const idsArray = ids ? toArray(ids) : void 0;
    const resp = await this.client.api.aGet(
      this.id,
      this.client.tenant,
      this.client.database,
      {
        ids: idsArray,
        where,
        limit,
        offset,
        include,
        where_document: whereDocument
      },
      this.client.api.options
    );
    return resp;
  }
  /**
   * Update items in the collection
   * @param {Object} params - The parameters for the query.
   * @param {ID | IDs} [params.ids] - IDs of the items to add.
   * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
   * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
   * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
   * @returns {Promise<void>}
   *
   * @example
   * ```typescript
   * const response = await collection.update({
   *   ids: ["id1", "id2"],
   *   embeddings: [[1, 2, 3], [4, 5, 6]],
   *   metadatas: [{ "key": "value" }, { "key": "value" }],
   *   documents: ["document1", "document2"],
   * });
   * ```
   */
  async update(params) {
    await this.client.init();
    await this.client.api.update(
      this.client.tenant,
      this.client.database,
      this.id,
      await prepareRecordRequest(params, this.embeddingFunction, true),
      this.client.api.options
    );
  }
  /**
   * Performs a query on the collection using the specified parameters.
   *
   * @param {Object} params - The parameters for the query.
   * @param {Embedding | Embeddings} [params.queryEmbeddings] - Optional query embeddings to use for the search.
   * @param {PositiveInteger} [params.nResults] - Optional number of results to return (default is 10).
   * @param {Where} [params.where] - Optional query condition to filter results based on metadata values.
   * @param {string | string[]} [params.queryTexts] - Optional query text(s) to search for in the collection.
   * @param {WhereDocument} [params.whereDocument] - Optional query condition to filter results based on document content.
   * @param {IncludeEnum[]} [params.include] - Optional array of fields to include in the result, such as "metadata" and "document".
   *
   * @returns {Promise<QueryResponse>} A promise that resolves to the query results.
   * @throws {Error} If there is an issue executing the query.
   * @example
   * // Query the collection using embeddings
   * const results = await collection.query({
   *   queryEmbeddings: [[0.1, 0.2, ...], ...],
   *   nResults: 10,
   *   where: {"name": {"$eq": "John Doe"}},
   *   include: ["metadata", "document"]
   * });
   * @example
   * ```js
   * // Query the collection using query text
   * const results = await collection.query({
   *   queryTexts: "some text",
   *   nResults: 10,
   *   where: {"name": {"$eq": "John Doe"}},
   *   include: ["metadata", "document"]
   * });
   * ```
   *
   */
  async query({
    nResults = 10,
    where,
    whereDocument,
    include,
    queryTexts,
    queryEmbeddings
  }) {
    if (queryTexts && queryEmbeddings || !queryTexts && !queryEmbeddings) {
      throw new Error(
        "You must supply exactly one of queryTexts or queryEmbeddings."
      );
    }
    await this.client.init();
    const arrayQueryEmbeddings = queryTexts !== void 0 ? await this.embeddingFunction.generate(toArray(queryTexts)) : toArrayOfArrays(queryEmbeddings);
    return await this.client.api.getNearestNeighbors(
      this.client.tenant,
      this.client.database,
      this.id,
      {
        query_embeddings: arrayQueryEmbeddings,
        where,
        n_results: nResults,
        where_document: whereDocument,
        include
      },
      this.client.api.options
    );
  }
  /**
   * Modify the collection name or metadata
   * @param {Object} params - The parameters for the query.
   * @param {string} [params.name] - Optional new name for the collection.
   * @param {CollectionMetadata} [params.metadata] - Optional new metadata for the collection.
   * @returns {Promise<void>} - The response from the API.
   *
   * @example
   * ```typescript
   * const response = await client.updateCollection({
   *   name: "new name",
   *   metadata: { "key": "value" },
   * });
   * ```
   */
  async modify({
    name,
    metadata
  }) {
    await this.client.init();
    return this.client.api.updateCollection(
      this.client.tenant,
      this.client.database,
      this.id,
      {
        new_name: name,
        new_metadata: metadata
      },
      this.client.api.options
    ).then(() => {
      if (name !== void 0) {
        this.name = name;
      }
      if (metadata !== void 0) {
        this.metadata = metadata;
      }
      return {
        name: this.name,
        metadata: this.metadata
      };
    });
  }
  /**
   * Peek inside the collection
   * @param {Object} params - The parameters for the query.
   * @param {PositiveInteger} [params.limit] - Optional number of results to return (default is 10).
   * @returns {Promise<GetResponse>} A promise that resolves to the query results.
   * @throws {Error} If there is an issue executing the query.
   *
   * @example
   * ```typescript
   * const results = await collection.peek({
   *   limit: 10
   * });
   * ```
   */
  async peek({ limit = 10 } = {}) {
    await this.client.init();
    return await this.client.api.aGet(
      this.id,
      this.client.tenant,
      this.client.database,
      {
        limit
      },
      this.client.api.options
    );
  }
  /**
   * Deletes items from the collection.
   * @param {Object} params - The parameters for deleting items from the collection.
   * @param {ID | IDs} [params.ids] - Optional ID or array of IDs of items to delete.
   * @param {Where} [params.where] - Optional query condition to filter items to delete based on metadata values.
   * @param {WhereDocument} [params.whereDocument] - Optional query condition to filter items to delete based on document content.
   * @returns {Promise<string[]>} A promise that resolves to the IDs of the deleted items.
   * @throws {Error} If there is an issue deleting items from the collection.
   *
   * @example
   * ```typescript
   * const results = await collection.delete({
   *   ids: "some_id",
   *   where: {"name": {"$eq": "John Doe"}},
   *   whereDocument: {"$contains":"search_string"}
   * });
   * ```
   */
  async delete({
    ids,
    where,
    whereDocument
  } = {}) {
    await this.client.init();
    let idsArray = void 0;
    if (ids !== void 0)
      idsArray = toArray(ids);
    await this.client.api.aDelete(
      this.id,
      this.client.tenant,
      this.client.database,
      { ids: idsArray, where, where_document: whereDocument },
      this.client.api.options
    );
  }
};

// src/utils.ts
function toArray(obj) {
  if (Array.isArray(obj)) {
    return obj;
  } else {
    return [obj];
  }
}
function toArrayOfArrays(obj) {
  if (Array.isArray(obj[0])) {
    return obj;
  } else {
    return [obj];
  }
}
async function validateTenantDatabase(adminClient, tenant, database) {
  try {
    await adminClient.getTenant({ name: tenant });
  } catch (error) {
    if (error instanceof ChromaConnectionError) {
      throw error;
    }
    throw new Error(
      `Could not connect to tenant ${tenant}. Are you sure it exists? Underlying error:
${error}`
    );
  }
  try {
    await adminClient.getDatabase({ name: database, tenantName: tenant });
  } catch (error) {
    if (error instanceof ChromaConnectionError) {
      throw error;
    }
    throw new Error(
      `Could not connect to database ${database} for tenant ${tenant}. Are you sure it exists? Underlying error:
${error}`
    );
  }
}
function isBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
}
function arrayifyParams(params) {
  return {
    ids: toArray(params.ids),
    embeddings: params.embeddings ? toArrayOfArrays(params.embeddings) : void 0,
    metadatas: params.metadatas ? toArray(params.metadatas) : void 0,
    documents: params.documents ? toArray(params.documents) : void 0
  };
}
async function prepareRecordRequest(reqParams, embeddingFunction, update) {
  const { ids, embeddings, metadatas, documents } = arrayifyParams(reqParams);
  if (!embeddings && !documents && !update) {
    throw new Error("embeddings and documents cannot both be undefined");
  }
  const embeddingsArray = embeddings ? embeddings : documents ? await embeddingFunction.generate(documents) : void 0;
  if (!embeddingsArray && !update) {
    throw new Error("Failed to generate embeddings for your request.");
  }
  for (let i = 0; i < ids.length; i += 1) {
    if (typeof ids[i] !== "string") {
      throw new Error(
        `Expected ids to be strings, found ${typeof ids[i]} at index ${i}`
      );
    }
  }
  if (embeddingsArray !== void 0 && ids.length !== embeddingsArray.length || metadatas !== void 0 && ids.length !== metadatas.length || documents !== void 0 && ids.length !== documents.length) {
    throw new Error(
      "ids, embeddings, metadatas, and documents must all be the same length"
    );
  }
  const uniqueIds = new Set(ids);
  if (uniqueIds.size !== ids.length) {
    const duplicateIds = ids.filter(
      (item, index) => ids.indexOf(item) !== index
    );
    throw new Error(
      `ID's must be unique, found duplicates for: ${duplicateIds}`
    );
  }
  return {
    ids,
    metadatas,
    documents,
    embeddings: embeddingsArray
  };
}
function wrapCollection(api, collection) {
  return new Collection(
    collection.name,
    collection.id,
    api,
    collection.embeddingFunction,
    collection.metadata
  );
}

// src/auth.ts
var tokenHeaderTypeToHeaderKey = (headerType) => {
  if (headerType === "AUTHORIZATION") {
    return "Authorization";
  } else {
    return "X-Chroma-Token";
  }
};
var base64Encode = (str) => {
  return Buffer.from(str).toString("base64");
};
var BasicAuthClientProvider = class {
  /**
   * Creates a new BasicAuthClientProvider.
   * @param textCredentials - The credentials for the authentication provider. Must be of the form "username:password". If not supplied, the environment variable CHROMA_CLIENT_AUTH_CREDENTIALS will be used.
   * @throws {Error} If neither credentials provider or text credentials are supplied.
   */
  constructor(textCredentials) {
    const creds = textCredentials != null ? textCredentials : process.env.CHROMA_CLIENT_AUTH_CREDENTIALS;
    if (creds === void 0) {
      throw new Error(
        "Credentials must be supplied via environment variable (CHROMA_CLIENT_AUTH_CREDENTIALS) or passed in as configuration."
      );
    }
    this.credentials = {
      Authorization: "Basic " + base64Encode(creds)
    };
  }
  authenticate() {
    return this.credentials;
  }
};
var TokenAuthClientProvider = class {
  constructor(textCredentials, headerType = "AUTHORIZATION") {
    const creds = textCredentials != null ? textCredentials : process.env.CHROMA_CLIENT_AUTH_CREDENTIALS;
    if (creds === void 0) {
      throw new Error(
        "Credentials must be supplied via environment variable (CHROMA_CLIENT_AUTH_CREDENTIALS) or passed in as configuration."
      );
    }
    const headerKey = tokenHeaderTypeToHeaderKey(headerType);
    const headerVal = headerType === "AUTHORIZATION" ? `Bearer ${creds}` : creds;
    this.credentials = {};
    this.credentials[headerKey] = headerVal;
  }
  authenticate() {
    return this.credentials;
  }
};
var authOptionsToAuthProvider = (auth) => {
  if (auth.provider === void 0) {
    throw new Error("Auth provider not specified");
  }
  if (auth.credentials === void 0) {
    throw new Error("Auth credentials not specified");
  }
  switch (auth.provider) {
    case "basic":
      return new BasicAuthClientProvider(auth.credentials);
    case "token":
      return new TokenAuthClientProvider(
        auth.credentials,
        auth.tokenHeaderType
      );
      break;
    default:
      throw new Error("Invalid auth provider");
  }
};

// src/ChromaFetch.ts
function isOfflineError(error) {
  var _a, _b, _c;
  return Boolean(
    ((error == null ? void 0 : error.name) === "TypeError" || (error == null ? void 0 : error.name) === "FetchError") && (((_a = error.message) == null ? void 0 : _a.includes("fetch failed")) || ((_b = error.message) == null ? void 0 : _b.includes("Failed to fetch")) || ((_c = error.message) == null ? void 0 : _c.includes("ENOTFOUND")))
  );
}
function parseServerError(error) {
  const regex = /(\w+)\('(.+)'\)/;
  const match = error == null ? void 0 : error.match(regex);
  if (match) {
    const [, name, message] = match;
    switch (name) {
      case "ValueError":
        return new ChromaValueError(message);
      default:
        return new ChromaError(name, message);
    }
  }
  return new ChromaServerError(
    "The server encountered an error while handling the request."
  );
}
var chromaFetch = async (input, init) => {
  try {
    const resp = await fetch(input, init);
    const clonedResp = resp.clone();
    const respBody = await clonedResp.json();
    if (!clonedResp.ok) {
      const error = createErrorByType(respBody == null ? void 0 : respBody.error, respBody == null ? void 0 : respBody.message);
      if (error) {
        throw error;
      }
      switch (resp.status) {
        case 400:
          throw new ChromaClientError(
            `Bad request to ${input} with status: ${resp.statusText}`
          );
        case 401:
          throw new ChromaUnauthorizedError(`Unauthorized`);
        case 403:
          throw new ChromaForbiddenError(
            `You do not have permission to access the requested resource.`
          );
        case 404:
          throw new ChromaNotFoundError(
            `The requested resource could not be found: ${input}`
          );
        case 409:
          throw new ChromaUniqueError("The resource already exists");
        case 500:
          throw parseServerError(respBody == null ? void 0 : respBody.error);
        case 502:
        case 503:
        case 504:
          throw new ChromaConnectionError(
            `Unable to connect to the chromadb server. Please try again later.`
          );
      }
      throw new Error(
        `Failed to fetch ${input} with status ${resp.status}: ${resp.statusText}`
      );
    }
    if (respBody == null ? void 0 : respBody.error) {
      throw parseServerError(respBody.error);
    }
    return resp;
  } catch (error) {
    if (isOfflineError(error)) {
      throw new ChromaConnectionError(
        "Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.",
        error
      );
    }
    throw error;
  }
};

// src/AdminClient.ts
var DEFAULT_TENANT = "default_tenant";
var DEFAULT_DATABASE = "default_database";
var AdminClient = class {
  /**
   * Creates a new AdminClient instance.
   * @param {Object} params - The parameters for creating a new client
   * @param {string} [params.path] - The base path for the Chroma API.
   * @returns {AdminClient} A new AdminClient instance.
   *
   * @example
   * ```typescript
   * const client = new AdminClient({
   *   path: "http://localhost:8000"
   * });
   * ```
   */
  constructor({
    path,
    fetchOptions,
    auth,
    tenant = DEFAULT_TENANT,
    database = DEFAULT_DATABASE
  } = {}) {
    this.tenant = DEFAULT_TENANT;
    this.database = DEFAULT_DATABASE;
    if (path === void 0)
      path = "http://localhost:8000";
    this.tenant = tenant;
    this.database = database;
    this.authProvider = void 0;
    const apiConfig = new Configuration({
      basePath: path
    });
    this.api = new ApiApi(apiConfig, void 0, chromaFetch);
    this.api.options = fetchOptions != null ? fetchOptions : {};
    if (auth !== void 0) {
      this.authProvider = authOptionsToAuthProvider(auth);
      this.api.options.headers = __spreadValues(__spreadValues({}, this.api.options.headers), this.authProvider.authenticate());
    }
  }
  /**
   * Sets the tenant and database for the client.
   *
   * @param {Object} params - The parameters for setting tenant and database.
   * @param {string} params.tenant - The name of the tenant.
   * @param {string} params.database - The name of the database.
   *
   * @returns {Promise<void>} A promise that returns nothing
   * @throws {Error} Any issues
   *
   * @example
   * ```typescript
   * await adminClient.setTenant({
   *   tenant: "my_tenant",
   *   database: "my_database",
   * });
   * ```
   */
  async setTenant({
    tenant = DEFAULT_TENANT,
    database = DEFAULT_DATABASE
  }) {
    await validateTenantDatabase(this, tenant, database);
    this.tenant = tenant;
    this.database = database;
  }
  /**
   * Sets the database for the client.
   *
   * @param {Object} params - The parameters for setting the database.
   * @param {string} params.database - The name of the database.
   *
   * @returns {Promise<void>} A promise that returns nothing
   * @throws {Error} Any issues
   *
   * @example
   * ```typescript
   * await adminClient.setDatabase({
   *   database: "my_database",
   * });
   * ```
   */
  async setDatabase({
    database = DEFAULT_DATABASE
  }) {
    await validateTenantDatabase(this, this.tenant, database);
    this.database = database;
  }
  /**
   * Creates a new tenant with the specified properties.
   *
   * @param {Object} params - The parameters for creating a new tenant.
   * @param {string} params.name - The name of the tenant.
   *
   * @returns {Promise<Tenant>} A promise that resolves to the created tenant.
   * @throws {Error} If there is an issue creating the tenant.
   *
   * @example
   * ```typescript
   * await adminClient.createTenant({
   *   name: "my_tenant",
   * });
   * ```
   */
  async createTenant({ name }) {
    await this.api.createTenant({ name }, this.api.options);
    return { name };
  }
  /**
   * Gets a tenant with the specified properties.
   *
   * @param {Object} params - The parameters for getting a tenant.
   * @param {string} params.name - The name of the tenant.
   *
   * @returns {Promise<Tenant>} A promise that resolves to the tenant.
   * @throws {Error} If there is an issue getting the tenant.
   *
   * @example
   * ```typescript
   * await adminClient.getTenant({
   *   name: "my_tenant",
   * });
   * ```
   */
  async getTenant({ name }) {
    const getTenant = await this.api.getTenant(
      name,
      this.api.options
    );
    return { name: getTenant.name };
  }
  /**
   * Creates a new database with the specified properties.
   *
   * @param {Object} params - The parameters for creating a new database.
   * @param {string} params.name - The name of the database.
   * @param {string} params.tenantName - The name of the tenant.
   *
   * @returns {Promise<Database>} A promise that resolves to the created database.
   * @throws {Error} If there is an issue creating the database.
   *
   * @example
   * ```typescript
   * await adminClient.createDatabase({
   *   name: "my_database",
   *   tenantName: "my_tenant",
   * });
   * ```
   */
  async createDatabase({
    name,
    tenantName
  }) {
    await this.api.createDatabase(tenantName, { name }, this.api.options);
    return { name };
  }
  /**
   * Gets a database with the specified properties.
   *
   * @param {Object} params - The parameters for getting a database.
   * @param {string} params.name - The name of the database.
   * @param {string} params.tenantName - The name of the tenant.
   *
   * @returns {Promise<Database>} A promise that resolves to the database.
   * @throws {Error} If there is an issue getting the database.
   *
   * @example
   * ```typescript
   * await adminClient.getDatabase({
   *   name: "my_database",
   *   tenantName: "my_tenant",
   * });
   * ```
   */
  async getDatabase({
    name,
    tenantName
  }) {
    const getDatabase = await this.api.getDatabase(
      name,
      tenantName,
      this.api.options
    );
    return { name: getDatabase.name };
  }
};

// src/embeddings/DefaultEmbeddingFunction.ts
var TransformersApi;
var DefaultEmbeddingFunction = class _DefaultEmbeddingFunction {
  /**
   * DefaultEmbeddingFunction constructor.
   * @param options The configuration options.
   * @param options.model The model to use to calculate embeddings. Defaults to 'Xenova/all-MiniLM-L6-v2', which is an ONNX port of `sentence-transformers/all-MiniLM-L6-v2`.
   * @param options.revision The specific model version to use (can be a branch, tag name, or commit id). Defaults to 'main'.
   * @param options.quantized Whether to load the 8-bit quantized version of the model. Defaults to `false`.
   * @param options.progress_callback If specified, this function will be called during model construction, to provide the user with progress updates.
   */
  constructor({
    model = "Xenova/all-MiniLM-L6-v2",
    revision = "main",
    quantized = false,
    progress_callback = null
  } = {}) {
    this.model = model;
    this.revision = revision;
    this.quantized = quantized;
    this.progress_callback = progress_callback;
  }
  async generate(texts) {
    await this.loadClient();
    this.pipelinePromise = new Promise(async (resolve, reject) => {
      try {
        const pipeline = this.transformersApi;
        const quantized = this.quantized;
        const revision = this.revision;
        const progress_callback = this.progress_callback;
        resolve(
          await pipeline("feature-extraction", this.model, {
            quantized,
            revision,
            progress_callback
          })
        );
      } catch (e) {
        reject(e);
      }
    });
    let pipe = await this.pipelinePromise;
    let output = await pipe(texts, { pooling: "mean", normalize: true });
    return output.tolist();
  }
  async loadClient() {
    if (this.transformersApi)
      return;
    try {
      let { pipeline } = await _DefaultEmbeddingFunction.import();
      TransformersApi = pipeline;
    } catch (_a) {
      if (_a.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Please install the chromadb-default-embed package to use the DefaultEmbeddingFunction, `npm install chromadb-default-embed`"
        );
      }
      throw _a;
    }
    this.transformersApi = TransformersApi;
  }
  /** @ignore */
  static async import() {
    try {
      let importResult;
      if (isBrowser()) {
        importResult = await import(
          // todo: we can't import chromadb-default-embed here yet because the `build` script was not run before publishing our fork to NPM, so the entrypoint in our forked package points to a non-existent file.
          // @ts-expect-error
          "https://unpkg.com/@xenova/transformers@2.13.2"
        );
      } else {
        importResult = await import("chromadb-default-embed");
      }
      const { pipeline, env } = importResult;
      env.allowLocalModels = false;
      return { pipeline };
    } catch (e) {
      throw new Error(
        "Please install chromadb-default-embed as a dependency with, e.g. `npm install chromadb-default-embed`"
      );
    }
  }
};

// src/ChromaClient.ts
var DEFAULT_TENANT2 = "default_tenant";
var DEFAULT_DATABASE2 = "default_database";
var ChromaClient = class {
  /**
   * Creates a new ChromaClient instance.
   * @param {Object} params - The parameters for creating a new client
   * @param {string} [params.path] - The base path for the Chroma API.
   * @returns {ChromaClient} A new ChromaClient instance.
   *
   * @example
   * ```typescript
   * const client = new ChromaClient({
   *   path: "http://localhost:8000"
   * });
   * ```
   */
  constructor({
    path = "http://localhost:8000",
    fetchOptions,
    auth,
    tenant = DEFAULT_TENANT2,
    database = DEFAULT_DATABASE2
  } = {}) {
    this.tenant = tenant;
    this.database = database;
    this.authProvider = void 0;
    const apiConfig = new Configuration({
      basePath: path
    });
    this.api = new ApiApi(apiConfig, void 0, chromaFetch);
    this.api.options = fetchOptions != null ? fetchOptions : {};
    if (auth !== void 0) {
      this.authProvider = authOptionsToAuthProvider(auth);
      this.api.options.headers = __spreadValues(__spreadValues({}, this.api.options.headers), this.authProvider.authenticate());
    }
    this._adminClient = new AdminClient({
      path,
      fetchOptions,
      auth,
      tenant,
      database
    });
  }
  /** @ignore */
  async init() {
    if (!this._initPromise) {
      if (this.authProvider !== void 0) {
        await this.getUserIdentity();
      }
      this._initPromise = validateTenantDatabase(
        this._adminClient,
        this.tenant,
        this.database
      );
    }
    return this._initPromise;
  }
  /**
   * Tries to set the tenant and database for the client.
   *
   * @returns {Promise<void>} A promise that resolves when the tenant/database is resolved.
   * @throws {Error} If there is an issue resolving the tenant and database.
   *
   */
  async getUserIdentity() {
    const user_identity = await this.api.getUserIdentity(
      this.api.options
    );
    const user_tenant = user_identity.tenant;
    const user_databases = user_identity.databases;
    if (user_tenant !== null && user_tenant !== void 0 && user_tenant !== "*" && this.tenant == DEFAULT_TENANT2) {
      this.tenant = user_tenant;
    }
    if (user_databases !== null && user_databases !== void 0 && user_databases.length == 1 && user_databases[0] !== "*" && this.database == DEFAULT_DATABASE2) {
      this.database = user_databases[0];
    }
  }
  /**
   * Resets the state of the object by making an API call to the reset endpoint.
   *
   * @returns {Promise<boolean>} A promise that resolves when the reset operation is complete.
   * @throws {ChromaConnectionError} If the client is unable to connect to the server.
   * @throws {ChromaServerError} If the server experienced an error while the state.
   *
   * @example
   * ```typescript
   * await client.reset();
   * ```
   */
  async reset() {
    await this.init();
    return await this.api.postV2Reset(this.api.options);
  }
  /**
   * Returns the version of the Chroma API.
   * @returns {Promise<string>} A promise that resolves to the version of the Chroma API.
   * @throws {ChromaConnectionError} If the client is unable to connect to the server.
   *
   * @example
   * ```typescript
   * const version = await client.version();
   * ```
   */
  async version() {
    return await this.api.getV2Version(this.api.options);
  }
  /**
   * Returns a heartbeat from the Chroma API.
   * @returns {Promise<number>} A promise that resolves to the heartbeat from the Chroma API.
   * @throws {ChromaConnectionError} If the client is unable to connect to the server.
   *
   * @example
   * ```typescript
   * const heartbeat = await client.heartbeat();
   * ```
   */
  async heartbeat() {
    const response = await this.api.getV2Heartbeat(this.api.options);
    return response["nanosecond heartbeat"];
  }
  /**
   * Creates a new collection with the specified properties.
   *
   * @param {Object} params - The parameters for creating a new collection.
   * @param {string} params.name - The name of the collection.
   * @param {CollectionMetadata} [params.metadata] - Optional metadata associated with the collection.
   * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
   *
   * @returns {Promise<Collection>} A promise that resolves to the created collection.
   * @throws {ChromaConnectionError} If the client is unable to connect to the server.
   * @throws {ChromaServerError} If there is an issue creating the collection.
   *
   * @example
   * ```typescript
   * const collection = await client.createCollection({
   *   name: "my_collection",
   *   metadata: {
   *     "description": "My first collection"
   *   }
   * });
   * ```
   */
  async createCollection({
    name,
    metadata,
    embeddingFunction = new DefaultEmbeddingFunction()
  }) {
    await this.init();
    const newCollection = await this.api.createCollection(
      this.tenant,
      this.database,
      {
        name,
        // @ts-ignore: we need to generate the client libraries again
        configuration: null,
        //TODO: Configuration type in JavaScript
        metadata
      },
      this.api.options
    );
    return wrapCollection(this, {
      name: newCollection.name,
      id: newCollection.id,
      metadata: newCollection.metadata,
      embeddingFunction
    });
  }
  /**
   * Gets or creates a collection with the specified properties.
   *
   * @param {Object} params - The parameters for creating a new collection.
   * @param {string} params.name - The name of the collection.
   * @param {CollectionMetadata} [params.metadata] - Optional metadata associated with the collection.
   * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
   *
   * @returns {Promise<Collection>} A promise that resolves to the got or created collection.
   * @throws {Error} If there is an issue getting or creating the collection.
   *
   * @example
   * ```typescript
   * const collection = await client.getOrCreateCollection({
   *   name: "my_collection",
   *   metadata: {
   *     "description": "My first collection"
   *   }
   * });
   * ```
   */
  async getOrCreateCollection({
    name,
    metadata,
    embeddingFunction = new DefaultEmbeddingFunction()
  }) {
    await this.init();
    const newCollection = await this.api.createCollection(
      this.tenant,
      this.database,
      {
        name,
        // @ts-ignore: we need to generate the client libraries again
        configuration: null,
        //TODO: Configuration type in JavaScript
        metadata,
        get_or_create: true
      },
      this.api.options
    );
    return wrapCollection(this, {
      name: newCollection.name,
      id: newCollection.id,
      metadata: newCollection.metadata,
      embeddingFunction
    });
  }
  /**
   * Lists all collections.
   *
   * @returns {Promise<CollectionType[]>} A promise that resolves to a list of collection names.
   * @param {PositiveInteger} [params.limit] - Optional limit on the number of items to get.
   * @param {PositiveInteger} [params.offset] - Optional offset on the items to get.
   * @throws {Error} If there is an issue listing the collections.
   *
   * @example
   * ```typescript
   * const collections = await client.listCollections({
   *     limit: 10,
   *     offset: 0,
   * });
   * ```
   */
  async listCollections({ limit, offset } = {}) {
    await this.init();
    return await this.api.listCollections(
      this.tenant,
      this.database,
      limit,
      offset,
      this.api.options
    );
  }
  /**
   * Counts all collections.
   *
   * @returns {Promise<number>} A promise that resolves to the number of collections.
   * @throws {Error} If there is an issue counting the collections.
   *
   * @example
   * ```typescript
   * const collections = await client.countCollections();
   * ```
   */
  async countCollections() {
    await this.init();
    return await this.api.countCollections(
      this.tenant,
      this.database,
      this.api.options
    );
  }
  /**
   * Gets a collection with the specified name.
   * @param {Object} params - The parameters for getting a collection.
   * @param {string} params.name - The name of the collection.
   * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
   * @returns {Promise<Collection>} A promise that resolves to the collection.
   * @throws {Error} If there is an issue getting the collection.
   *
   * @example
   * ```typescript
   * const collection = await client.getCollection({
   *   name: "my_collection"
   * });
   * ```
   */
  async getCollection({
    name,
    embeddingFunction
  }) {
    await this.init();
    const response = await this.api.getCollection(
      this.tenant,
      this.database,
      name,
      this.api.options
    );
    return wrapCollection(this, {
      name: response.name,
      id: response.id,
      metadata: response.metadata,
      embeddingFunction
    });
  }
  /**
   * Deletes a collection with the specified name.
   * @param {Object} params - The parameters for deleting a collection.
   * @param {string} params.name - The name of the collection.
   * @returns {Promise<void>} A promise that resolves when the collection is deleted.
   * @throws {Error} If there is an issue deleting the collection.
   *
   * @example
   * ```typescript
   * await client.deleteCollection({
   *  name: "my_collection"
   * });
   * ```
   */
  async deleteCollection({ name }) {
    await this.init();
    await this.api.deleteCollection(
      name,
      this.tenant,
      this.database,
      this.api.options
    );
  }
};

// src/CloudClient.ts
var CloudClient = class extends ChromaClient {
  constructor({
    apiKey,
    database,
    tenant,
    cloudHost,
    cloudPort
  }) {
    if (!apiKey) {
      apiKey = process.env.CHROMA_API_KEY;
    }
    if (!apiKey) {
      throw new Error("No API key provided");
    }
    cloudHost = cloudHost || "https://api.trychroma.com";
    cloudPort = cloudPort || "8000";
    const path = `${cloudHost}:${cloudPort}`;
    const auth = {
      provider: "token",
      credentials: apiKey,
      tokenHeaderType: "X_CHROMA_TOKEN"
    };
    return new ChromaClient({
      path,
      auth,
      database,
      tenant
    });
    super();
  }
};

// src/embeddings/OpenAIEmbeddingFunction.ts
var OpenAIApi;
var openAiVersion = null;
var openAiMajorVersion = null;
var OpenAIAPIv3 = class {
  constructor(configuration) {
    this.configuration = new OpenAIApi.Configuration({
      organization: configuration.organization,
      apiKey: configuration.apiKey
    });
    this.openai = new OpenAIApi.OpenAIApi(this.configuration);
  }
  async createEmbedding(params) {
    const embeddings = [];
    const response = await this.openai.createEmbedding({
      model: params.model,
      input: params.input
    }).catch((error) => {
      throw error;
    });
    const data = response.data["data"];
    for (let i = 0; i < data.length; i += 1) {
      embeddings.push(data[i]["embedding"]);
    }
    return embeddings;
  }
};
var OpenAIAPIv4 = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.openai = new OpenAIApi({
      apiKey: this.apiKey
    });
  }
  async createEmbedding(params) {
    const embeddings = [];
    const response = await this.openai.embeddings.create(params);
    const data = response["data"];
    for (let i = 0; i < data.length; i += 1) {
      embeddings.push(data[i]["embedding"]);
    }
    return embeddings;
  }
};
var OpenAIEmbeddingFunction = class _OpenAIEmbeddingFunction {
  constructor({
    openai_api_key,
    openai_model,
    openai_organization_id,
    openai_embedding_dimensions
  }) {
    this.api_key = openai_api_key;
    this.org_id = openai_organization_id || "";
    this.model = openai_model || "text-embedding-ada-002";
    this.dimensions = openai_embedding_dimensions;
  }
  async loadClient() {
    if (this.openaiApi)
      return;
    try {
      const { openai, version } = await _OpenAIEmbeddingFunction.import();
      OpenAIApi = openai;
      let versionVar = version;
      openAiVersion = versionVar.replace(/[^0-9.]/g, "");
      openAiMajorVersion = parseInt(openAiVersion.split(".")[0]);
    } catch (_a) {
      if (_a.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Please install the openai package to use the OpenAIEmbeddingFunction, e.g. `npm install openai`"
        );
      }
      throw _a;
    }
    if (openAiMajorVersion > 3) {
      this.openaiApi = new OpenAIAPIv4(this.api_key);
    } else {
      this.openaiApi = new OpenAIAPIv3({
        organization: this.org_id,
        apiKey: this.api_key
      });
    }
  }
  async generate(texts) {
    await this.loadClient();
    return await this.openaiApi.createEmbedding({
      model: this.model,
      input: texts,
      dimensions: this.dimensions
    }).catch((error) => {
      throw error;
    });
  }
  /** @ignore */
  static async import() {
    try {
      const { default: openai } = await import("openai");
      const { VERSION } = await import("openai/version");
      return { openai, version: VERSION };
    } catch (e) {
      throw new Error(
        "Please install the openai package to use the OpenAIEmbeddingFunction, e.g. `npm install openai`"
      );
    }
  }
};

// src/embeddings/CohereEmbeddingFunction.ts
var CohereAISDK56 = class {
  constructor(configuration) {
    this.apiKey = configuration.apiKey;
  }
  async loadClient() {
    if (this.cohereClient)
      return;
    const { default: cohere } = await import("cohere-ai");
    cohere.init(this.apiKey);
    this.cohereClient = cohere;
  }
  async createEmbedding(params) {
    await this.loadClient();
    return await this.cohereClient.embed({
      texts: params.input,
      model: params.model
    }).then((response) => {
      return response.body.embeddings;
    });
  }
};
var CohereAISDK7 = class {
  constructor(configuration) {
    this.apiKey = configuration.apiKey;
  }
  async loadClient() {
    if (this.cohereClient)
      return;
    const cohere = await import("cohere-ai").then((cohere2) => {
      return cohere2;
    });
    this.cohereClient = new cohere.CohereClient({
      token: this.apiKey
    });
  }
  async createEmbedding(params) {
    await this.loadClient();
    return await this.cohereClient.embed({ texts: params.input, model: params.model }).then((response) => {
      return response.embeddings;
    });
  }
};
var CohereEmbeddingFunction = class {
  constructor({
    cohere_api_key,
    model
  }) {
    this.model = model || "large";
    this.apiKey = cohere_api_key;
  }
  async initCohereClient() {
    if (this.cohereAiApi)
      return;
    try {
      this.cohereAiApi = await import("cohere-ai").then((cohere) => {
        if (cohere.CohereClient) {
          return new CohereAISDK7({ apiKey: this.apiKey });
        } else {
          return new CohereAISDK56({ apiKey: this.apiKey });
        }
      });
    } catch (e) {
      if (e.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Please install the cohere-ai package to use the CohereEmbeddingFunction, `npm install -S cohere-ai`"
        );
      }
      throw e;
    }
  }
  async generate(texts) {
    await this.initCohereClient();
    return await this.cohereAiApi.createEmbedding({
      model: this.model,
      input: texts
    });
  }
};

// src/embeddings/TransformersEmbeddingFunction.ts
var TransformersApi2;
var TransformersEmbeddingFunction = class _TransformersEmbeddingFunction {
  /**
   * TransformersEmbeddingFunction constructor.
   * @param options The configuration options.
   * @param options.model The model to use to calculate embeddings. Defaults to 'Xenova/all-MiniLM-L6-v2', which is an ONNX port of `sentence-transformers/all-MiniLM-L6-v2`.
   * @param options.revision The specific model version to use (can be a branch, tag name, or commit id). Defaults to 'main'.
   * @param options.quantized Whether to load the 8-bit quantized version of the model. Defaults to `false`.
   * @param options.progress_callback If specified, this function will be called during model construction, to provide the user with progress updates.
   */
  constructor({
    model = "Xenova/all-MiniLM-L6-v2",
    revision = "main",
    quantized = false,
    progress_callback = null
  } = {}) {
    this.model = model;
    this.revision = revision;
    this.quantized = quantized;
    this.progress_callback = progress_callback;
  }
  async generate(texts) {
    await this.loadClient();
    this.pipelinePromise = new Promise(async (resolve, reject) => {
      try {
        const pipeline = this.transformersApi;
        const quantized = this.quantized;
        const revision = this.revision;
        const progress_callback = this.progress_callback;
        resolve(
          await pipeline("feature-extraction", this.model, {
            quantized,
            revision,
            progress_callback
          })
        );
      } catch (e) {
        reject(e);
      }
    });
    let pipe = await this.pipelinePromise;
    let output = await pipe(texts, { pooling: "mean", normalize: true });
    return output.tolist();
  }
  async loadClient() {
    if (this.transformersApi)
      return;
    try {
      let { pipeline } = await _TransformersEmbeddingFunction.import();
      TransformersApi2 = pipeline;
    } catch (_a) {
      if (_a.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Please install the @xenova/transformers package to use the TransformersEmbeddingFunction, `npm install @xenova/transformers`"
        );
      }
      throw _a;
    }
    this.transformersApi = TransformersApi2;
  }
  /** @ignore */
  static async import() {
    try {
      const { pipeline } = await import("@xenova/transformers");
      return { pipeline };
    } catch (e) {
      throw new Error(
        "Please install @xenova/transformers as a dependency with, e.g. `npm install @xenova/transformers`"
      );
    }
  }
};

// src/embeddings/HuggingFaceEmbeddingServerFunction.ts
var HuggingFaceEmbeddingServerFunction = class {
  constructor({ url }) {
    this.url = url;
  }
  async generate(texts) {
    const response = await fetch(this.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ inputs: texts })
    });
    if (!response.ok) {
      throw new Error(`Failed to generate embeddings: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  }
};

// src/embeddings/JinaEmbeddingFunction.ts
var JinaEmbeddingFunction = class {
  constructor({
    jinaai_api_key,
    model_name
  }) {
    this.model_name = model_name || "jina-embeddings-v2-base-en";
    this.api_url = "https://api.jina.ai/v1/embeddings";
    this.headers = {
      Authorization: `Bearer ${jinaai_api_key}`,
      "Accept-Encoding": "identity",
      "Content-Type": "application/json"
    };
  }
  async generate(texts) {
    try {
      const response = await fetch(this.api_url, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify({
          input: texts,
          model: this.model_name
        })
      });
      const data = await response.json();
      if (!data || !data.data) {
        throw new Error(data.detail);
      }
      const embeddings = data.data;
      const sortedEmbeddings = embeddings.sort((a, b) => a.index - b.index);
      return sortedEmbeddings.map((result) => result.embedding);
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Error calling Jina AI API: ${error.message}`);
      } else {
        throw new Error(`Error calling Jina AI API: ${error}`);
      }
    }
  }
};

// src/embeddings/GoogleGeminiEmbeddingFunction.ts
var googleGenAiApi;
var GoogleGenerativeAiEmbeddingFunction = class _GoogleGenerativeAiEmbeddingFunction {
  constructor({
    googleApiKey,
    model,
    taskType
  }) {
    this.api_key = googleApiKey;
    this.model = model || "embedding-001";
    this.taskType = taskType || "RETRIEVAL_DOCUMENT";
  }
  async loadClient() {
    if (this.googleGenAiApi)
      return;
    try {
      const { googleGenAi } = await _GoogleGenerativeAiEmbeddingFunction.import();
      googleGenAiApi = googleGenAi;
      googleGenAiApi = new googleGenAiApi(this.api_key);
    } catch (_a) {
      if (_a.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Please install the @google/generative-ai package to use the GoogleGenerativeAiEmbeddingFunction, `npm install @google/generative-ai`"
        );
      }
      throw _a;
    }
    this.googleGenAiApi = googleGenAiApi;
  }
  async generate(texts) {
    await this.loadClient();
    const model = this.googleGenAiApi.getGenerativeModel({ model: this.model });
    const response = await model.batchEmbedContents({
      requests: texts.map((t) => ({
        content: { parts: [{ text: t }] },
        taskType: this.taskType
      }))
    });
    const embeddings = response.embeddings.map((e) => e.values);
    return embeddings;
  }
  /** @ignore */
  static async import() {
    try {
      const { GoogleGenerativeAI } = await import("@google/generative-ai");
      const googleGenAi = GoogleGenerativeAI;
      return { googleGenAi };
    } catch (e) {
      throw new Error(
        "Please install @google/generative-ai as a dependency with, e.g. `npm install @google/generative-ai`"
      );
    }
  }
};

// src/embeddings/OllamaEmbeddingFunction.ts
var OllamaEmbeddingFunction = class {
  constructor({ url, model }) {
    this.url = url;
    this.model = model;
  }
  async generate(texts) {
    let embeddings = [];
    for (let text of texts) {
      const response = await fetch(this.url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ model: this.model, prompt: text })
      });
      if (!response.ok) {
        throw new Error(
          `Failed to generate embeddings: ${response.status} (${response.statusText})`
        );
      }
      let finalResponse = await response.json();
      embeddings.push(finalResponse["embedding"]);
    }
    return embeddings;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AdminClient,
  ChromaClient,
  CloudClient,
  CohereEmbeddingFunction,
  DefaultEmbeddingFunction,
  GoogleGenerativeAiEmbeddingFunction,
  HuggingFaceEmbeddingServerFunction,
  JinaEmbeddingFunction,
  OllamaEmbeddingFunction,
  OpenAIEmbeddingFunction,
  TransformersEmbeddingFunction
});
//# sourceMappingURL=chromadb.cjs.map