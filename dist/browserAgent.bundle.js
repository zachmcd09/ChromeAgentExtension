/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@langchain/core/node_modules/ansi-styles/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/ansi-styles/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(e, r) { return new BabelRegExp(e, void 0, r); }; var e = RegExp.prototype, r = new WeakMap(); function BabelRegExp(e, t, p) { var o = RegExp(e, t); return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype); } function buildGroups(e, t) { var p = r.get(t); return Object.keys(p).reduce(function (r, t) { var o = p[t]; if ("number" == typeof o) r[t] = e[o];else { for (var i = 0; void 0 === e[o[i]] && i + 1 < o.length;) i++; r[t] = e[o[i]]; } return r; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) { var t = e.exec.call(this, r); if (t) { t.groups = buildGroups(t, this); var p = t.indices; p && (p.groups = buildGroups(p, this)); } return t; }, BabelRegExp.prototype[Symbol.replace] = function (t, p) { if ("string" == typeof p) { var o = r.get(this); return e[Symbol.replace].call(this, t, p.replace(/\$<([^>]+)>/g, function (e, r) { var t = o[r]; return "$" + (Array.isArray(t) ? t.join("$") : t); })); } if ("function" == typeof p) { var i = this; return e[Symbol.replace].call(this, t, function () { var e = arguments; return "object" != _typeof(e[e.length - 1]) && (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e); }); } return e[Symbol.replace].call(this, t, p); }, _wrapRegExp.apply(this, arguments); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi256 = function wrapAnsi256() {
  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function (code) {
    return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
  };
};
var wrapAnsi16m = function wrapAnsi16m() {
  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function (red, green, blue) {
    return "\x1B[".concat(38 + offset, ";2;").concat(red, ";").concat(green, ";").concat(blue, "m");
  };
};
function assembleStyles() {
  var codes = new Map();
  var styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };

  // Alias bright black as gray (and grey)
  styles.color.gray = styles.color.blackBright;
  styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
  styles.color.grey = styles.color.blackBright;
  styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
  for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      groupName = _Object$entries$_i[0],
      group = _Object$entries$_i[1];
    for (var _i2 = 0, _Object$entries2 = Object.entries(group); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        styleName = _Object$entries2$_i[0],
        style = _Object$entries2$_i[1];
      styles[styleName] = {
        open: "\x1B[".concat(style[0], "m"),
        close: "\x1B[".concat(style[1], "m")
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

  // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value: function value(red, green, blue) {
        // We use the extended greyscale palette here, with the exception of
        // black and white. normal palette only has 4 greyscale shades.
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value: function value(hex) {
        var matches = /*#__PURE__*/_wrapRegExp(/([a-f\d]{6}|[a-f\d]{3})/i, {
          colorString: 1
        }).exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        var colorString = matches.groups.colorString;
        if (colorString.length === 3) {
          colorString = colorString.split('').map(function (character) {
            return character + character;
          }).join('');
        }
        var integer = Number.parseInt(colorString, 16);
        return [integer >> 16 & 0xFF, integer >> 8 & 0xFF, integer & 0xFF];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: function value(hex) {
        return styles.rgbToAnsi256.apply(styles, _toConsumableArray(styles.hexToRgb(hex)));
      },
      enumerable: false
    }
  });
  return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/camelcase/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/camelcase/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var UPPERCASE = /(?:[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C89\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2F\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uA7BA\uA7BC\uA7BE\uA7C0\uA7C2\uA7C4-\uA7C7\uA7C9\uA7CB\uA7CC\uA7D0\uA7D6\uA7D8\uA7DA\uA7DC\uA7F5\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2\uDD50-\uDD65]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21])/;
var LOWERCASE = /(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1C8A\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5F\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C1\uA7C3\uA7C8\uA7CA\uA7CD\uA7D1\uA7D3\uA7D5\uA7D7\uA7D9\uA7DB\uA7F6\uA7FA\uAB30-\uAB5A\uAB60-\uAB68\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDCC0-\uDCF2\uDD70-\uDD85]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E\uDF25-\uDF2A]|\uD83A[\uDD22-\uDD43])/;
var LEADING_CAPITAL = /^(?:[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C89\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2F\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uA7BA\uA7BC\uA7BE\uA7C0\uA7C2\uA7C4-\uA7C7\uA7C9\uA7CB\uA7CC\uA7D0\uA7D6\uA7D8\uA7DA\uA7DC\uA7F5\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2\uDD50-\uDD65]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21])(?!(?:[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C89\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2F\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uA7BA\uA7BC\uA7BE\uA7C0\uA7C2\uA7C4-\uA7C7\uA7C9\uA7CB\uA7CC\uA7D0\uA7D6\uA7D8\uA7DA\uA7DC\uA7F5\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2\uDD50-\uDD65]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]))/g;
var IDENTIFIER = /((?:[0-9A-Z_a-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0363-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u0669\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0897\u08A0-\u08C9\u08D4-\u08DF\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFC\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F83\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1713\u171F-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1ABF\u1AC0\u1ACC-\u1ACE\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4C\u1B50-\u1B59\u1B80-\u1BA9\u1BAC-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C36\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1DD3-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2189\u2150-\u2182\u2460-\u249B\u24B6-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA805\uA807-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C3\uA8C5\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDD40-\uDD65\uDD69\uDD6F-\uDD85\uDE60-\uDE7E\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEC2-\uDEC4\uDEFC\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC45\uDC52-\uDC6F\uDC71-\uDC75\uDC80-\uDCB8\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD32\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDCE-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7-\uDFC0\uDFC2\uDFC5\uDFC7-\uDFCA\uDFCC\uDFCD\uDFD1\uDFD3]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB5\uDEB8\uDEC0-\uDEC9\uDED0-\uDEE3\uDF00-\uDF1A\uDF1D-\uDF2A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC38\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B\uDD3C\uDD3F-\uDD42\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDDF\uDDE1\uDDE3\uDDE4\uDE00-\uDE32\uDE35-\uDE3E\uDE50-\uDE97\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0\uDFF0-\uDFF9]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD41\uDD43\uDD46\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD96\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF40\uDF50-\uDF59\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD2E\uDD30-\uDD39]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDD70-\uDD79\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD833[\uDCF0-\uDCF9]|\uD834[\uDEC0-\uDED3\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDCD0-\uDCEB\uDCF0-\uDCF9\uDDD0-\uDDED\uDDF0-\uDDFA\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD47\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])|$)/;
var SEPARATORS = /[_.\- ]+/;
var LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
var NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');
var preserveCamelCase = function preserveCamelCase(string, toLowerCase, toUpperCase) {
  var isLastCharLower = false;
  var isLastCharUpper = false;
  var isLastLastCharUpper = false;
  for (var i = 0; i < string.length; i++) {
    var character = string[i];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, i) + '-' + string.slice(i);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = function preserveConsecutiveUppercase(input, toLowerCase) {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replace(LEADING_CAPITAL, function (m1) {
    return toLowerCase(m1);
  });
};
var postProcess = function postProcess(input, toUpperCase) {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replace(SEPARATORS_AND_IDENTIFIER, function (_, identifier) {
    return toUpperCase(identifier);
  }).replace(NUMBERS_AND_IDENTIFIER, function (m) {
    return toUpperCase(m);
  });
};
var camelCase = function camelCase(input, options) {
  if (!(typeof input === 'string' || Array.isArray(input))) {
    throw new TypeError('Expected the input to be `string | string[]`');
  }
  options = _objectSpread({
    pascalCase: false,
    preserveConsecutiveUppercase: false
  }, options);
  if (Array.isArray(input)) {
    input = input.map(function (x) {
      return x.trim();
    }).filter(function (x) {
      return x.length;
    }).join('-');
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return '';
  }
  var toLowerCase = options.locale === false ? function (string) {
    return string.toLowerCase();
  } : function (string) {
    return string.toLocaleLowerCase(options.locale);
  };
  var toUpperCase = options.locale === false ? function (string) {
    return string.toUpperCase();
  } : function (string) {
    return string.toLocaleUpperCase(options.locale);
  };
  if (input.length === 1) {
    return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  var hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase);
  }
  input = input.replace(LEADING_SEPARATORS, '');
  if (options.preserveConsecutiveUppercase) {
    input = preserveConsecutiveUppercase(input, toLowerCase);
  } else {
    input = toLowerCase(input);
  }
  if (options.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
};
module.exports = camelCase;
// TODO: Remove this for the next major release
module.exports["default"] = camelCase;

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/eventemitter3/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/eventemitter3/index.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty,
  prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }
  var listener = new EE(fn, context || emitter, once),
    evt = prefix ? prefix + event : event;
  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = [],
    events,
    name;
  if (this._eventsCount === 0) return names;
  for (name in events = this._events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }
  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }
  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event,
    handlers = this._events[evt];
  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];
  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }
  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event,
    listeners = this._events[evt];
  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return false;
  var listeners = this._events[evt],
    len = arguments.length,
    args,
    i;
  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
    switch (len) {
      case 1:
        return listeners.fn.call(listeners.context), true;
      case 2:
        return listeners.fn.call(listeners.context, a1), true;
      case 3:
        return listeners.fn.call(listeners.context, a1, a2), true;
      case 4:
        return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }
    for (i = 1, args = new Array(len - 1); i < len; i++) {
      args[i - 1] = arguments[i];
    }
    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length,
      j;
    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
      switch (len) {
        case 1:
          listeners[i].fn.call(listeners[i].context);
          break;
        case 2:
          listeners[i].fn.call(listeners[i].context, a1);
          break;
        case 3:
          listeners[i].fn.call(listeners[i].context, a1, a2);
          break;
        case 4:
          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
          break;
        default:
          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
            args[j - 1] = arguments[j];
          }
          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }
  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }
  var listeners = this._events[evt];
  if (listeners.fn) {
    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
  }
  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;
  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }
  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/p-queue/dist/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/p-queue/dist/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/@langchain/core/node_modules/eventemitter3/index.js");
var p_timeout_1 = __webpack_require__(/*! p-timeout */ "./node_modules/@langchain/core/node_modules/p-timeout/index.js");
var priority_queue_1 = __webpack_require__(/*! ./priority-queue */ "./node_modules/@langchain/core/node_modules/p-queue/dist/priority-queue.js");
// eslint-disable-next-line @typescript-eslint/no-empty-function
var empty = function empty() {};
var timeoutError = new p_timeout_1.TimeoutError();
/**
Promise queue with concurrency control.
*/
var PQueue = /*#__PURE__*/function (_EventEmitter) {
  function PQueue(options) {
    var _this;
    _classCallCheck(this, PQueue);
    var _a, _b, _c, _d;
    _this = _callSuper(this, PQueue);
    _this._intervalCount = 0;
    _this._intervalEnd = 0;
    _this._pendingCount = 0;
    _this._resolveEmpty = empty;
    _this._resolveIdle = empty;
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    options = Object.assign({
      carryoverConcurrencyCount: false,
      intervalCap: Infinity,
      interval: 0,
      concurrency: Infinity,
      autoStart: true,
      queueClass: priority_queue_1["default"]
    }, options);
    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
      throw new TypeError("Expected `intervalCap` to be a number from 1 and up, got `".concat((_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '', "` (").concat(_typeof(options.intervalCap), ")"));
    }
    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError("Expected `interval` to be a finite number >= 0, got `".concat((_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '', "` (").concat(_typeof(options.interval), ")"));
    }
    _this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    _this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
    _this._intervalCap = options.intervalCap;
    _this._interval = options.interval;
    _this._queue = new options.queueClass();
    _this._queueClass = options.queueClass;
    _this.concurrency = options.concurrency;
    _this._timeout = options.timeout;
    _this._throwOnTimeout = options.throwOnTimeout === true;
    _this._isPaused = options.autoStart === false;
    return _this;
  }
  _inherits(PQueue, _EventEmitter);
  return _createClass(PQueue, [{
    key: "_doesIntervalAllowAnother",
    get: function get() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
  }, {
    key: "_doesConcurrentAllowAnother",
    get: function get() {
      return this._pendingCount < this._concurrency;
    }
  }, {
    key: "_next",
    value: function _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit('next');
    }
  }, {
    key: "_resolvePromises",
    value: function _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty;
        this.emit('idle');
      }
    }
  }, {
    key: "_onResumeInterval",
    value: function _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = undefined;
    }
  }, {
    key: "_isIntervalPaused",
    value: function _isIntervalPaused() {
      var _this2 = this;
      var now = Date.now();
      if (this._intervalId === undefined) {
        var delay = this._intervalEnd - now;
        if (delay < 0) {
          // Act as the interval was done
          // We don't need to resume it here because it will be resumed on line 160
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          // Act as the interval is pending
          if (this._timeoutId === undefined) {
            this._timeoutId = setTimeout(function () {
              _this2._onResumeInterval();
            }, delay);
          }
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_tryToStartAnother",
    value: function _tryToStartAnother() {
      if (this._queue.size === 0) {
        // We can clear the interval ("pause")
        // Because we can redo it later ("resume")
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = undefined;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        var canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          var job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit('active');
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_initializeIntervalIfNeeded",
    value: function _initializeIntervalIfNeeded() {
      var _this3 = this;
      if (this._isIntervalIgnored || this._intervalId !== undefined) {
        return;
      }
      this._intervalId = setInterval(function () {
        _this3._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
  }, {
    key: "_onInterval",
    value: function _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = undefined;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
  }, {
    key: "_processQueue",
    value: function _processQueue() {
      // eslint-disable-next-line no-empty
      while (this._tryToStartAnother()) {}
    }
  }, {
    key: "concurrency",
    get: function get() {
      return this._concurrency;
    },
    set: function set(newConcurrency) {
      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(newConcurrency, "` (").concat(_typeof(newConcurrency), ")"));
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
  }, {
    key: "add",
    value: (function () {
      var _add = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fn) {
        var _this4 = this;
        var options,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var run = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                    var operation;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          _this4._pendingCount++;
                          _this4._intervalCount++;
                          _context.prev = 2;
                          operation = _this4._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1["default"](Promise.resolve(fn()), options.timeout === undefined ? _this4._timeout : options.timeout, function () {
                            if (options.throwOnTimeout === undefined ? _this4._throwOnTimeout : options.throwOnTimeout) {
                              reject(timeoutError);
                            }
                            return undefined;
                          });
                          _context.t0 = resolve;
                          _context.next = 7;
                          return operation;
                        case 7:
                          _context.t1 = _context.sent;
                          (0, _context.t0)(_context.t1);
                          _context.next = 14;
                          break;
                        case 11:
                          _context.prev = 11;
                          _context.t2 = _context["catch"](2);
                          reject(_context.t2);
                        case 14:
                          _this4._next();
                        case 15:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee, null, [[2, 11]]);
                  }));
                  return function run() {
                    return _ref.apply(this, arguments);
                  };
                }();
                _this4._queue.enqueue(run, options);
                _this4._tryToStartAnother();
                _this4.emit('add');
              }));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function add(_x) {
        return _add.apply(this, arguments);
      }
      return add;
    }()
    /**
    Same as `.add()`, but accepts an array of sync or async functions.
     @returns A promise that resolves when all functions are resolved.
    */
    )
  }, {
    key: "addAll",
    value: (function () {
      var _addAll = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(functions, options) {
        var _this5 = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", Promise.all(functions.map(/*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(function_) {
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        return _context3.abrupt("return", _this5.add(function_, options));
                      case 1:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }));
                return function (_x4) {
                  return _ref2.apply(this, arguments);
                };
              }())));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function addAll(_x2, _x3) {
        return _addAll.apply(this, arguments);
      }
      return addAll;
    }()
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    )
  }, {
    key: "start",
    value: function start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
  }, {
    key: "pause",
    value: function pause() {
      this._isPaused = true;
    }
    /**
    Clear the queue.
    */
  }, {
    key: "clear",
    value: function clear() {
      this._queue = new this._queueClass();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.
     @returns A promise that settles when the queue becomes empty.
    */
  }, {
    key: "onEmpty",
    value: (function () {
      var _onEmpty = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this6 = this;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(this._queue.size === 0)) {
                _context5.next = 2;
                break;
              }
              return _context5.abrupt("return");
            case 2:
              return _context5.abrupt("return", new Promise(function (resolve) {
                var existingResolve = _this6._resolveEmpty;
                _this6._resolveEmpty = function () {
                  existingResolve();
                  resolve();
                };
              }));
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function onEmpty() {
        return _onEmpty.apply(this, arguments);
      }
      return onEmpty;
    }()
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */
    )
  }, {
    key: "onIdle",
    value: (function () {
      var _onIdle = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var _this7 = this;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!(this._pendingCount === 0 && this._queue.size === 0)) {
                _context6.next = 2;
                break;
              }
              return _context6.abrupt("return");
            case 2:
              return _context6.abrupt("return", new Promise(function (resolve) {
                var existingResolve = _this7._resolveIdle;
                _this7._resolveIdle = function () {
                  existingResolve();
                  resolve();
                };
              }));
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function onIdle() {
        return _onIdle.apply(this, arguments);
      }
      return onIdle;
    }()
    /**
    Size of the queue.
    */
    )
  }, {
    key: "size",
    get: function get() {
      return this._queue.size;
    }
    /**
    Size of the queue, filtered by the given options.
     For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */
  }, {
    key: "sizeBy",
    value: function sizeBy(options) {
      // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
      return this._queue.filter(options).length;
    }
    /**
    Number of pending promises.
    */
  }, {
    key: "pending",
    get: function get() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }
  }, {
    key: "timeout",
    get: function get() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */,
    set: function set(milliseconds) {
      this._timeout = milliseconds;
    }
  }]);
}(EventEmitter);
exports["default"] = PQueue;

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/p-queue/dist/lower-bound.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/p-queue/dist/lower-bound.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
  var first = 0;
  var count = array.length;
  while (count > 0) {
    var step = count / 2 | 0;
    var it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
exports["default"] = lowerBound;

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/p-queue/dist/priority-queue.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/p-queue/dist/priority-queue.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var lower_bound_1 = __webpack_require__(/*! ./lower-bound */ "./node_modules/@langchain/core/node_modules/p-queue/dist/lower-bound.js");
var PriorityQueue = /*#__PURE__*/function () {
  function PriorityQueue() {
    _classCallCheck(this, PriorityQueue);
    this._queue = [];
  }
  return _createClass(PriorityQueue, [{
    key: "enqueue",
    value: function enqueue(run, options) {
      options = Object.assign({
        priority: 0
      }, options);
      var element = {
        priority: options.priority,
        run: run
      };
      if (this.size && this._queue[this.size - 1].priority >= options.priority) {
        this._queue.push(element);
        return;
      }
      var index = lower_bound_1["default"](this._queue, element, function (a, b) {
        return b.priority - a.priority;
      });
      this._queue.splice(index, 0, element);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      var item = this._queue.shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
  }, {
    key: "filter",
    value: function filter(options) {
      return this._queue.filter(function (element) {
        return element.priority === options.priority;
      }).map(function (element) {
        return element.run;
      });
    }
  }, {
    key: "size",
    get: function get() {
      return this._queue.length;
    }
  }]);
}();
exports["default"] = PriorityQueue;

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/p-retry/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/p-retry/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var retry = __webpack_require__(/*! retry */ "./node_modules/retry/index.js");
var networkErrorMsgs = ['Failed to fetch',
// Chrome
'NetworkError when attempting to fetch resource.',
// Firefox
'The Internet connection appears to be offline.',
// Safari
'Network request failed' // `cross-fetch`
];
var AbortError = /*#__PURE__*/function (_Error) {
  function AbortError(message) {
    var _this;
    _classCallCheck(this, AbortError);
    _this = _callSuper(this, AbortError);
    if (message instanceof Error) {
      _this.originalError = message;
      var _message = message;
      message = _message.message;
    } else {
      _this.originalError = new Error(message);
      _this.originalError.stack = _this.stack;
    }
    _this.name = 'AbortError';
    _this.message = message;
    return _this;
  }
  _inherits(AbortError, _Error);
  return _createClass(AbortError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
var decorateErrorWithCounts = function decorateErrorWithCounts(error, attemptNumber, options) {
  // Minus 1 from attemptNumber because the first attempt does not count as a retry
  var retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
var isNetworkError = function isNetworkError(errorMessage) {
  return networkErrorMsgs.includes(errorMessage);
};
var pRetry = function pRetry(input, options) {
  return new Promise(function (resolve, reject) {
    options = _objectSpread({
      onFailedAttempt: function onFailedAttempt() {},
      retries: 10
    }, options);
    var operation = retry.operation(options);
    operation.attempt(/*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(attemptNumber) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = resolve;
              _context.next = 4;
              return input(attemptNumber);
            case 4:
              _context.t1 = _context.sent;
              (0, _context.t0)(_context.t1);
              _context.next = 34;
              break;
            case 8:
              _context.prev = 8;
              _context.t2 = _context["catch"](0);
              if (_context.t2 instanceof Error) {
                _context.next = 13;
                break;
              }
              reject(new TypeError("Non-error was thrown: \"".concat(_context.t2, "\". You should only throw errors.")));
              return _context.abrupt("return");
            case 13:
              if (!(_context.t2 instanceof AbortError)) {
                _context.next = 18;
                break;
              }
              operation.stop();
              reject(_context.t2.originalError);
              _context.next = 34;
              break;
            case 18:
              if (!(_context.t2 instanceof TypeError && !isNetworkError(_context.t2.message))) {
                _context.next = 23;
                break;
              }
              operation.stop();
              reject(_context.t2);
              _context.next = 34;
              break;
            case 23:
              decorateErrorWithCounts(_context.t2, attemptNumber, options);
              _context.prev = 24;
              _context.next = 27;
              return options.onFailedAttempt(_context.t2);
            case 27:
              _context.next = 33;
              break;
            case 29:
              _context.prev = 29;
              _context.t3 = _context["catch"](24);
              reject(_context.t3);
              return _context.abrupt("return");
            case 33:
              if (!operation.retry(_context.t2)) {
                reject(operation.mainError());
              }
            case 34:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 8], [24, 29]]);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
};
module.exports = pRetry;
// TODO: remove this in the next major version
module.exports["default"] = pRetry;
module.exports.AbortError = AbortError;

/***/ }),

/***/ "./node_modules/@langchain/core/node_modules/p-timeout/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/p-timeout/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var pFinally = __webpack_require__(/*! p-finally */ "./node_modules/p-finally/index.js");
var TimeoutError = /*#__PURE__*/function (_Error) {
  function TimeoutError(message) {
    var _this;
    _classCallCheck(this, TimeoutError);
    _this = _callSuper(this, TimeoutError, [message]);
    _this.name = 'TimeoutError';
    return _this;
  }
  _inherits(TimeoutError, _Error);
  return _createClass(TimeoutError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
var pTimeout = function pTimeout(promise, milliseconds, fallback) {
  return new Promise(function (resolve, reject) {
    if (typeof milliseconds !== 'number' || milliseconds < 0) {
      throw new TypeError('Expected `milliseconds` to be a positive number');
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    var timer = setTimeout(function () {
      if (typeof fallback === 'function') {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      var message = typeof fallback === 'string' ? fallback : "Promise timed out after ".concat(milliseconds, " milliseconds");
      var timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === 'function') {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);

    // TODO: Use native `finally` keyword when targeting Node.js 10
    pFinally(
    // eslint-disable-next-line promise/prefer-await-to-then
    promise.then(resolve, reject), function () {
      clearTimeout(timer);
    });
  });
};
module.exports = pTimeout;
// TODO: Remove this for the next major release
module.exports["default"] = pTimeout;
module.exports.TimeoutError = TimeoutError;

/***/ }),

/***/ "./node_modules/decamelize/index.js":
/*!******************************************!*\
  !*** ./node_modules/decamelize/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


module.exports = function (str, sep) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  sep = typeof sep === 'undefined' ? '_' : sep;
  return str.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2').replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2').toLowerCase();
};

/***/ }),

/***/ "./node_modules/langsmith/node_modules/eventemitter3/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/eventemitter3/index.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty,
  prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }
  var listener = new EE(fn, context || emitter, once),
    evt = prefix ? prefix + event : event;
  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = [],
    events,
    name;
  if (this._eventsCount === 0) return names;
  for (name in events = this._events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }
  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }
  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event,
    handlers = this._events[evt];
  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];
  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }
  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event,
    listeners = this._events[evt];
  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return false;
  var listeners = this._events[evt],
    len = arguments.length,
    args,
    i;
  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
    switch (len) {
      case 1:
        return listeners.fn.call(listeners.context), true;
      case 2:
        return listeners.fn.call(listeners.context, a1), true;
      case 3:
        return listeners.fn.call(listeners.context, a1, a2), true;
      case 4:
        return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }
    for (i = 1, args = new Array(len - 1); i < len; i++) {
      args[i - 1] = arguments[i];
    }
    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length,
      j;
    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
      switch (len) {
        case 1:
          listeners[i].fn.call(listeners[i].context);
          break;
        case 2:
          listeners[i].fn.call(listeners[i].context, a1);
          break;
        case 3:
          listeners[i].fn.call(listeners[i].context, a1, a2);
          break;
        case 4:
          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
          break;
        default:
          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
            args[j - 1] = arguments[j];
          }
          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }
  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }
  var listeners = this._events[evt];
  if (listeners.fn) {
    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
  }
  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;
  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }
  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}

/***/ }),

/***/ "./node_modules/langsmith/node_modules/p-queue/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/p-queue/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/langsmith/node_modules/eventemitter3/index.js");
var p_timeout_1 = __webpack_require__(/*! p-timeout */ "./node_modules/langsmith/node_modules/p-timeout/index.js");
var priority_queue_1 = __webpack_require__(/*! ./priority-queue */ "./node_modules/langsmith/node_modules/p-queue/dist/priority-queue.js");
// eslint-disable-next-line @typescript-eslint/no-empty-function
var empty = function empty() {};
var timeoutError = new p_timeout_1.TimeoutError();
/**
Promise queue with concurrency control.
*/
var PQueue = /*#__PURE__*/function (_EventEmitter) {
  function PQueue(options) {
    var _this;
    _classCallCheck(this, PQueue);
    var _a, _b, _c, _d;
    _this = _callSuper(this, PQueue);
    _this._intervalCount = 0;
    _this._intervalEnd = 0;
    _this._pendingCount = 0;
    _this._resolveEmpty = empty;
    _this._resolveIdle = empty;
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    options = Object.assign({
      carryoverConcurrencyCount: false,
      intervalCap: Infinity,
      interval: 0,
      concurrency: Infinity,
      autoStart: true,
      queueClass: priority_queue_1["default"]
    }, options);
    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
      throw new TypeError("Expected `intervalCap` to be a number from 1 and up, got `".concat((_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '', "` (").concat(_typeof(options.intervalCap), ")"));
    }
    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError("Expected `interval` to be a finite number >= 0, got `".concat((_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '', "` (").concat(_typeof(options.interval), ")"));
    }
    _this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    _this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
    _this._intervalCap = options.intervalCap;
    _this._interval = options.interval;
    _this._queue = new options.queueClass();
    _this._queueClass = options.queueClass;
    _this.concurrency = options.concurrency;
    _this._timeout = options.timeout;
    _this._throwOnTimeout = options.throwOnTimeout === true;
    _this._isPaused = options.autoStart === false;
    return _this;
  }
  _inherits(PQueue, _EventEmitter);
  return _createClass(PQueue, [{
    key: "_doesIntervalAllowAnother",
    get: function get() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
  }, {
    key: "_doesConcurrentAllowAnother",
    get: function get() {
      return this._pendingCount < this._concurrency;
    }
  }, {
    key: "_next",
    value: function _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit('next');
    }
  }, {
    key: "_resolvePromises",
    value: function _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty;
        this.emit('idle');
      }
    }
  }, {
    key: "_onResumeInterval",
    value: function _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = undefined;
    }
  }, {
    key: "_isIntervalPaused",
    value: function _isIntervalPaused() {
      var _this2 = this;
      var now = Date.now();
      if (this._intervalId === undefined) {
        var delay = this._intervalEnd - now;
        if (delay < 0) {
          // Act as the interval was done
          // We don't need to resume it here because it will be resumed on line 160
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          // Act as the interval is pending
          if (this._timeoutId === undefined) {
            this._timeoutId = setTimeout(function () {
              _this2._onResumeInterval();
            }, delay);
          }
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_tryToStartAnother",
    value: function _tryToStartAnother() {
      if (this._queue.size === 0) {
        // We can clear the interval ("pause")
        // Because we can redo it later ("resume")
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = undefined;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        var canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          var job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit('active');
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_initializeIntervalIfNeeded",
    value: function _initializeIntervalIfNeeded() {
      var _this3 = this;
      if (this._isIntervalIgnored || this._intervalId !== undefined) {
        return;
      }
      this._intervalId = setInterval(function () {
        _this3._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
  }, {
    key: "_onInterval",
    value: function _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = undefined;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
  }, {
    key: "_processQueue",
    value: function _processQueue() {
      // eslint-disable-next-line no-empty
      while (this._tryToStartAnother()) {}
    }
  }, {
    key: "concurrency",
    get: function get() {
      return this._concurrency;
    },
    set: function set(newConcurrency) {
      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(newConcurrency, "` (").concat(_typeof(newConcurrency), ")"));
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
  }, {
    key: "add",
    value: (function () {
      var _add = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fn) {
        var _this4 = this;
        var options,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var run = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                    var operation;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          _this4._pendingCount++;
                          _this4._intervalCount++;
                          _context.prev = 2;
                          operation = _this4._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1["default"](Promise.resolve(fn()), options.timeout === undefined ? _this4._timeout : options.timeout, function () {
                            if (options.throwOnTimeout === undefined ? _this4._throwOnTimeout : options.throwOnTimeout) {
                              reject(timeoutError);
                            }
                            return undefined;
                          });
                          _context.t0 = resolve;
                          _context.next = 7;
                          return operation;
                        case 7:
                          _context.t1 = _context.sent;
                          (0, _context.t0)(_context.t1);
                          _context.next = 14;
                          break;
                        case 11:
                          _context.prev = 11;
                          _context.t2 = _context["catch"](2);
                          reject(_context.t2);
                        case 14:
                          _this4._next();
                        case 15:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee, null, [[2, 11]]);
                  }));
                  return function run() {
                    return _ref.apply(this, arguments);
                  };
                }();
                _this4._queue.enqueue(run, options);
                _this4._tryToStartAnother();
                _this4.emit('add');
              }));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function add(_x) {
        return _add.apply(this, arguments);
      }
      return add;
    }()
    /**
    Same as `.add()`, but accepts an array of sync or async functions.
     @returns A promise that resolves when all functions are resolved.
    */
    )
  }, {
    key: "addAll",
    value: (function () {
      var _addAll = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(functions, options) {
        var _this5 = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", Promise.all(functions.map(/*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(function_) {
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        return _context3.abrupt("return", _this5.add(function_, options));
                      case 1:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }));
                return function (_x4) {
                  return _ref2.apply(this, arguments);
                };
              }())));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function addAll(_x2, _x3) {
        return _addAll.apply(this, arguments);
      }
      return addAll;
    }()
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    )
  }, {
    key: "start",
    value: function start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
  }, {
    key: "pause",
    value: function pause() {
      this._isPaused = true;
    }
    /**
    Clear the queue.
    */
  }, {
    key: "clear",
    value: function clear() {
      this._queue = new this._queueClass();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.
     @returns A promise that settles when the queue becomes empty.
    */
  }, {
    key: "onEmpty",
    value: (function () {
      var _onEmpty = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this6 = this;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(this._queue.size === 0)) {
                _context5.next = 2;
                break;
              }
              return _context5.abrupt("return");
            case 2:
              return _context5.abrupt("return", new Promise(function (resolve) {
                var existingResolve = _this6._resolveEmpty;
                _this6._resolveEmpty = function () {
                  existingResolve();
                  resolve();
                };
              }));
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function onEmpty() {
        return _onEmpty.apply(this, arguments);
      }
      return onEmpty;
    }()
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */
    )
  }, {
    key: "onIdle",
    value: (function () {
      var _onIdle = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var _this7 = this;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!(this._pendingCount === 0 && this._queue.size === 0)) {
                _context6.next = 2;
                break;
              }
              return _context6.abrupt("return");
            case 2:
              return _context6.abrupt("return", new Promise(function (resolve) {
                var existingResolve = _this7._resolveIdle;
                _this7._resolveIdle = function () {
                  existingResolve();
                  resolve();
                };
              }));
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function onIdle() {
        return _onIdle.apply(this, arguments);
      }
      return onIdle;
    }()
    /**
    Size of the queue.
    */
    )
  }, {
    key: "size",
    get: function get() {
      return this._queue.size;
    }
    /**
    Size of the queue, filtered by the given options.
     For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */
  }, {
    key: "sizeBy",
    value: function sizeBy(options) {
      // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
      return this._queue.filter(options).length;
    }
    /**
    Number of pending promises.
    */
  }, {
    key: "pending",
    get: function get() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }
  }, {
    key: "timeout",
    get: function get() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */,
    set: function set(milliseconds) {
      this._timeout = milliseconds;
    }
  }]);
}(EventEmitter);
exports["default"] = PQueue;

/***/ }),

/***/ "./node_modules/langsmith/node_modules/p-queue/dist/lower-bound.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/p-queue/dist/lower-bound.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
  var first = 0;
  var count = array.length;
  while (count > 0) {
    var step = count / 2 | 0;
    var it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
exports["default"] = lowerBound;

/***/ }),

/***/ "./node_modules/langsmith/node_modules/p-queue/dist/priority-queue.js":
/*!****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/p-queue/dist/priority-queue.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var lower_bound_1 = __webpack_require__(/*! ./lower-bound */ "./node_modules/langsmith/node_modules/p-queue/dist/lower-bound.js");
var PriorityQueue = /*#__PURE__*/function () {
  function PriorityQueue() {
    _classCallCheck(this, PriorityQueue);
    this._queue = [];
  }
  return _createClass(PriorityQueue, [{
    key: "enqueue",
    value: function enqueue(run, options) {
      options = Object.assign({
        priority: 0
      }, options);
      var element = {
        priority: options.priority,
        run: run
      };
      if (this.size && this._queue[this.size - 1].priority >= options.priority) {
        this._queue.push(element);
        return;
      }
      var index = lower_bound_1["default"](this._queue, element, function (a, b) {
        return b.priority - a.priority;
      });
      this._queue.splice(index, 0, element);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      var item = this._queue.shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
  }, {
    key: "filter",
    value: function filter(options) {
      return this._queue.filter(function (element) {
        return element.priority === options.priority;
      }).map(function (element) {
        return element.run;
      });
    }
  }, {
    key: "size",
    get: function get() {
      return this._queue.length;
    }
  }]);
}();
exports["default"] = PriorityQueue;

/***/ }),

/***/ "./node_modules/langsmith/node_modules/p-retry/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/p-retry/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var retry = __webpack_require__(/*! retry */ "./node_modules/retry/index.js");
var networkErrorMsgs = ['Failed to fetch',
// Chrome
'NetworkError when attempting to fetch resource.',
// Firefox
'The Internet connection appears to be offline.',
// Safari
'Network request failed' // `cross-fetch`
];
var AbortError = /*#__PURE__*/function (_Error) {
  function AbortError(message) {
    var _this;
    _classCallCheck(this, AbortError);
    _this = _callSuper(this, AbortError);
    if (message instanceof Error) {
      _this.originalError = message;
      var _message = message;
      message = _message.message;
    } else {
      _this.originalError = new Error(message);
      _this.originalError.stack = _this.stack;
    }
    _this.name = 'AbortError';
    _this.message = message;
    return _this;
  }
  _inherits(AbortError, _Error);
  return _createClass(AbortError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
var decorateErrorWithCounts = function decorateErrorWithCounts(error, attemptNumber, options) {
  // Minus 1 from attemptNumber because the first attempt does not count as a retry
  var retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
var isNetworkError = function isNetworkError(errorMessage) {
  return networkErrorMsgs.includes(errorMessage);
};
var pRetry = function pRetry(input, options) {
  return new Promise(function (resolve, reject) {
    options = _objectSpread({
      onFailedAttempt: function onFailedAttempt() {},
      retries: 10
    }, options);
    var operation = retry.operation(options);
    operation.attempt(/*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(attemptNumber) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = resolve;
              _context.next = 4;
              return input(attemptNumber);
            case 4:
              _context.t1 = _context.sent;
              (0, _context.t0)(_context.t1);
              _context.next = 34;
              break;
            case 8:
              _context.prev = 8;
              _context.t2 = _context["catch"](0);
              if (_context.t2 instanceof Error) {
                _context.next = 13;
                break;
              }
              reject(new TypeError("Non-error was thrown: \"".concat(_context.t2, "\". You should only throw errors.")));
              return _context.abrupt("return");
            case 13:
              if (!(_context.t2 instanceof AbortError)) {
                _context.next = 18;
                break;
              }
              operation.stop();
              reject(_context.t2.originalError);
              _context.next = 34;
              break;
            case 18:
              if (!(_context.t2 instanceof TypeError && !isNetworkError(_context.t2.message))) {
                _context.next = 23;
                break;
              }
              operation.stop();
              reject(_context.t2);
              _context.next = 34;
              break;
            case 23:
              decorateErrorWithCounts(_context.t2, attemptNumber, options);
              _context.prev = 24;
              _context.next = 27;
              return options.onFailedAttempt(_context.t2);
            case 27:
              _context.next = 33;
              break;
            case 29:
              _context.prev = 29;
              _context.t3 = _context["catch"](24);
              reject(_context.t3);
              return _context.abrupt("return");
            case 33:
              if (!operation.retry(_context.t2)) {
                reject(operation.mainError());
              }
            case 34:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 8], [24, 29]]);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
};
module.exports = pRetry;
// TODO: remove this in the next major version
module.exports["default"] = pRetry;
module.exports.AbortError = AbortError;

/***/ }),

/***/ "./node_modules/langsmith/node_modules/p-timeout/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/p-timeout/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var pFinally = __webpack_require__(/*! p-finally */ "./node_modules/p-finally/index.js");
var TimeoutError = /*#__PURE__*/function (_Error) {
  function TimeoutError(message) {
    var _this;
    _classCallCheck(this, TimeoutError);
    _this = _callSuper(this, TimeoutError, [message]);
    _this.name = 'TimeoutError';
    return _this;
  }
  _inherits(TimeoutError, _Error);
  return _createClass(TimeoutError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
var pTimeout = function pTimeout(promise, milliseconds, fallback) {
  return new Promise(function (resolve, reject) {
    if (typeof milliseconds !== 'number' || milliseconds < 0) {
      throw new TypeError('Expected `milliseconds` to be a positive number');
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    var timer = setTimeout(function () {
      if (typeof fallback === 'function') {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      var message = typeof fallback === 'string' ? fallback : "Promise timed out after ".concat(milliseconds, " milliseconds");
      var timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === 'function') {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);

    // TODO: Use native `finally` keyword when targeting Node.js 10
    pFinally(
    // eslint-disable-next-line promise/prefer-await-to-then
    promise.then(resolve, reject), function () {
      clearTimeout(timer);
    });
  });
};
module.exports = pTimeout;
// TODO: Remove this for the next major release
module.exports["default"] = pTimeout;
module.exports.TimeoutError = TimeoutError;

/***/ }),

/***/ "./node_modules/moo/moo.js":
/*!*********************************!*\
  !*** ./node_modules/moo/moo.js ***!
  \*********************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); /* global define */
  } else {}
})(this, function () {
  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var assign = typeof Object.assign === 'function' ? Object.assign :
  // https://tc39.github.io/ecma262/#sec-object.assign
  function (target, sources) {
    if (target == null) {
      throw new TypeError('Target cannot be null or undefined');
    }
    target = Object(target);
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      if (source == null) continue;
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var hasSticky = typeof new RegExp().sticky === 'boolean';
  function isRegExp(o) {
    return o && o.constructor === RegExp;
  }
  function reEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  function reGroups(s) {
    var re = new RegExp('|' + s);
    return re.exec('').length - 1;
  }
  function reCapture(s) {
    return '(' + s + ')';
  }
  function reUnion(regexps) {
    var source = regexps.map(function (s) {
      return "(?:" + s + ")";
    }).join('|');
    return "(?:" + source + ")";
  }
  function compareLength(a, b) {
    return b.length - a.length;
  }
  function regexpOrLiteral(obj) {
    if (typeof obj === 'string') {
      return '(?:' + reEscape(obj) + ')';
    } else if (isRegExp(obj)) {
      // TODO: consider /u support
      if (obj.ignoreCase) {
        throw new Error('RegExp /i flag not allowed');
      }
      if (obj.global) {
        throw new Error('RegExp /g flag is implied');
      }
      if (obj.sticky) {
        throw new Error('RegExp /y flag is implied');
      }
      if (obj.multiline) {
        throw new Error('RegExp /m flag is implied');
      }
      return obj.source;
    } else {
      throw new Error('not a pattern: ' + obj);
    }
  }
  function objectToRules(object) {
    var keys = Object.getOwnPropertyNames(object);
    var result = [];
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      result.push(ruleOptions(key, object[key]));
    }
    return result;
  }
  function arrayToRules(array) {
    var result = [];
    for (var i = 0; i < array.length; i++) {
      var obj = array[i];
      if (!obj.name) {
        throw new Error('Rule has no name: ' + JSON.stringify(obj));
      }
      result.push(ruleOptions(obj.name, obj));
    }
    return result;
  }
  function ruleOptions(name, obj) {
    if (_typeof(obj) !== 'object' || Array.isArray(obj) || isRegExp(obj)) {
      obj = {
        match: obj
      };
    }

    // nb. error implies lineBreaks
    var options = assign({
      tokenType: name,
      lineBreaks: !!obj.error,
      pop: false,
      next: null,
      push: null,
      error: false
    }, obj);
    options.keywords = null;

    // convert to array
    var match = options.match;
    options.match = Array.isArray(match) ? match : match ? [match] : [];
    return options;
  }
  function sortRules(rules) {
    var result = [];
    for (var i = 0; i < rules.length; i++) {
      var options = rules[i];
      var match = options.match;

      // sort literals by length to ensure longest match
      var capturingPatterns = [];
      var patterns = [];
      var literals = [];
      for (var j = 0; j < match.length; j++) {
        var obj = match[j];
        if (!isRegExp(obj)) literals.push(obj);else if (reGroups(obj.source) > 0) capturingPatterns.push(obj);else patterns.push(obj);
      }
      literals.sort(compareLength);

      // append regexps to the end
      options.match = literals.concat(patterns);
      result.push(options);

      // add each capturing regexp as a separate rule
      for (var j = 0; j < capturingPatterns.length; j++) {
        result.push(assign({}, options, {
          match: [capturingPatterns[j]]
        }));
      }
    }
    return result;
  }
  function getIdentifier(literal, otherRules) {
    for (var i = 0; i < otherRules.length; i++) {
      var rule = otherRules[i];
      var match = rule.match;
      for (var j = 0; j < match.length; j++) {
        var pat = match[j];
        if (!isRegExp(pat)) {
          continue;
        }
        var m = pat.exec(literal);
        if (m && m[0] === literal) {
          return rule;
        }
      }
    }
  }
  function compileRules(rules, hasStates) {
    rules = Array.isArray(rules) ? arrayToRules(rules) : objectToRules(rules);
    rules = sortRules(rules);
    var errorRule = null;
    var groups = [];
    var parts = [];
    for (var i = 0; i < rules.length; i++) {
      var options = rules[i];
      if (options.error) {
        if (errorRule) {
          throw new Error("Multiple error rules not allowed: (for token '" + options.tokenType + "')");
        }
        errorRule = options;
      }

      // look for keywords
      var match = options.match;
      var notKeywords = [];
      for (var j = 0; j < match.length; j++) {
        var word = match[j];
        if (typeof word === 'string') {
          // does it match an existing rule (e.g. identifier?)
          var other = getIdentifier(word, rules);
          if (other) {
            if (!other.keywords) {
              other.keywords = Object.create(null);
            }
            other.keywords[word] = options;
            continue;
          }
        }
        notKeywords.push(word);
      }
      options.match = notKeywords;

      // skip rules with no match
      if (options.match.length === 0) {
        continue;
      }
      groups.push(options);

      // convert to RegExp
      var pat = reUnion(options.match.map(regexpOrLiteral));

      // validate
      var regexp = new RegExp(pat);
      if (regexp.test("")) {
        throw new Error("RegExp matches empty string: " + regexp);
      }
      var groupCount = reGroups(pat);
      if (groupCount > 1) {
        throw new Error("RegExp has more than one capture group: " + regexp);
      }
      if (!hasStates && (options.pop || options.push || options.next)) {
        throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.tokenType + "')");
      }

      // try and detect rules matching newlines
      if (!options.lineBreaks && regexp.test('\n')) {
        throw new Error('Rule should declare lineBreaks: ' + regexp);
      }

      // store regex
      var isCapture = !!groupCount;
      if (!isCapture) pat = reCapture(pat);
      parts.push(pat);
    }
    var suffix = hasSticky ? '' : '|(?:)';
    var flags = hasSticky ? 'ym' : 'gm';
    var regexp = new RegExp(reUnion(parts) + suffix, flags);
    return {
      regexp: regexp,
      groups: groups,
      error: errorRule
    };
  }
  function compile(rules) {
    var result = compileRules(rules);
    return new Lexer({
      start: result
    }, 'start');
  }
  function compileStates(states, start) {
    var keys = Object.getOwnPropertyNames(states);
    if (!start) start = keys[0];
    var map = Object.create(null);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      map[key] = compileRules(states[key], true);
    }
    for (var i = 0; i < keys.length; i++) {
      var groups = map[keys[i]].groups;
      for (var j = 0; j < groups.length; j++) {
        var g = groups[i];
        var state = g && (g.push || g.next);
        if (state && !map[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.tokenType + "' of state '" + keys[i] + "')");
        }
      }
    }
    return new Lexer(map, start);
  }
  var Lexer = function Lexer(states, state) {
    this.startState = state;
    this.states = states;
    this.buffer = '';
    this.stack = [];
    this.reset();
  };
  Lexer.prototype.setState = function (state) {
    if (!state || this.state === state) return;
    this.state = state;
    var info = this.states[state];
    this.groups = info.groups;
    this.error = info.error;
    this.re = info.regexp;
  };
  Lexer.prototype.popState = function () {
    this.setState(this.stack.pop());
  };
  Lexer.prototype.pushState = function (state) {
    this.stack.push(this.state);
    this.setState(state);
  };
  Lexer.prototype.eat = hasSticky ? function (re) {
    // assume re is /y
    return re.exec(this.buffer);
  } : function (re) {
    // assume re is /g
    var match = re.exec(this.buffer);
    // will always match, since we used the |(?:) trick
    if (match[0].length === 0) {
      return null;
    }
    return match;
  };
  function tokenToString() {
    return this.value || this.type;
  }
  Lexer.prototype.next = function () {
    var re = this.re;
    var buffer = this.buffer;
    var index = re.lastIndex = this.index;
    if (index === buffer.length) {
      return; // EOF
    }
    var match = this.eat(re);
    var group, value, text;
    if (match === null) {
      group = this.error;

      // consume rest of buffer
      text = value = buffer.slice(index);
    } else {
      text = match[0];
      var groups = this.groups;
      for (var i = 0; i < groups.length; i++) {
        value = match[i + 1];
        if (value !== undefined) {
          group = groups[i];
          // TODO is `buffer` being leaked here?
          break;
        }
      }
      // assert(i < groupCount)

      // check for keywords
      if (group.keywords) {
        group = group.keywords[text] || group;
      }
    }

    // count line breaks
    var lineBreaks = 0;
    if (!group || group.lineBreaks) {
      var matchNL = /\n/g;
      var nl = 1;
      if (text === '\n') {
        lineBreaks = 1;
      } else {
        while (matchNL.exec(text)) {
          lineBreaks++;
          nl = matchNL.lastIndex;
        }
      }
    }
    var size = text.length;
    var token = {
      type: group && group.tokenType,
      value: value,
      toString: tokenToString,
      offset: index,
      size: size,
      lineBreaks: lineBreaks,
      line: this.line,
      col: this.col
    };
    this.index += size;
    this.line += lineBreaks;
    if (lineBreaks !== 0) {
      this.col = size - nl + 1;
    } else {
      this.col += size;
    }
    // throw, if no rule with {error: true}
    if (!group) {
      throw new Error(this.formatError(token, "invalid syntax"));
    }
    if (group.pop) this.popState();else if (group.push) this.pushState(group.push);else if (group.next) this.setState(group.next);
    return token;
  };
  if (typeof Symbol !== 'undefined' && Symbol.iterator) {
    var LexerIterator = function LexerIterator(lexer) {
      this.lexer = lexer;
    };
    LexerIterator.prototype.next = function () {
      var token = this.lexer.next();
      return {
        value: token,
        done: !token
      };
    };
    Lexer.prototype[Symbol.iterator] = function () {
      return new LexerIterator(this);
    };
  }
  Lexer.prototype.formatError = function (token, message) {
    var value = token.value;
    var index = token.offset;
    var eol = token.lineBreaks ? value.indexOf('\n') : value.length;
    var start = Math.max(0, index - token.col + 1);
    var firstLine = this.buffer.substring(start, index + eol);
    message += " at line " + token.line + " col " + token.col + ":\n\n";
    message += "  " + firstLine + "\n";
    message += "  " + Array(token.col).join(" ") + "^";
    return message;
  };
  Lexer.prototype.reset = function (data, info) {
    this.buffer = data || '';
    this.index = 0;
    this.line = info ? info.line : 1;
    this.col = info ? info.col : 1;
    this.setState(info ? info.state : this.startState);
    return this;
  };
  Lexer.prototype.save = function () {
    return {
      line: this.line,
      col: this.col,
      state: this.state
    };
  };
  Lexer.prototype.clone = function () {
    return new Lexer(this.states, this.state);
  };
  Lexer.prototype.has = function (tokenType) {
    for (var s in this.states) {
      var groups = this.states[s].groups;
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group.tokenType === tokenType) return true;
        if (group.keywords) {
          for (var k in group.keywords) {
            if (group.keywords[k].tokenType === tokenType) return true;
          }
        }
      }
    }
    return false;
  };
  return {
    compile: compile,
    states: compileStates,
    error: Object.freeze({
      error: true
    })
  };
});

/***/ }),

/***/ "./node_modules/p-finally/index.js":
/*!*****************************************!*\
  !*** ./node_modules/p-finally/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


module.exports = function (promise, onFinally) {
  onFinally = onFinally || function () {};
  return promise.then(function (val) {
    return new Promise(function (resolve) {
      resolve(onFinally());
    }).then(function () {
      return val;
    });
  }, function (err) {
    return new Promise(function (resolve) {
      resolve(onFinally());
    }).then(function () {
      throw err;
    });
  });
};

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/retry */ "./node_modules/retry/lib/retry.js");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var RetryOperation = __webpack_require__(/*! ./retry_operation */ "./node_modules/retry/lib/retry_operation.js");
exports.operation = function (options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
    forever: options && (options.forever || options.retries === Infinity),
    unref: options && options.unref,
    maxRetryTime: options && options.maxRetryTime
  });
};
exports.timeouts = function (options) {
  if (options instanceof Array) {
    return [].concat(options);
  }
  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) {
    opts[key] = options[key];
  }
  if (opts.minTimeout > opts.maxTimeout) {
    throw new Error('minTimeout is greater than maxTimeout');
  }
  var timeouts = [];
  for (var i = 0; i < opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }
  if (options && options.forever && !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  }

  // sort the array numerically ascending
  timeouts.sort(function (a, b) {
    return a - b;
  });
  return timeouts;
};
exports.createTimeout = function (attempt, opts) {
  var random = opts.randomize ? Math.random() + 1 : 1;
  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);
  return timeout;
};
exports.wrap = function (obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }
  if (!methods) {
    methods = [];
    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        methods.push(key);
      }
    }
  }
  for (var i = 0; i < methods.length; i++) {
    var method = methods[i];
    var original = obj[method];
    obj[method] = function retryWrapper(original) {
      var op = exports.operation(options);
      var args = Array.prototype.slice.call(arguments, 1);
      var callback = args.pop();
      args.push(function (err) {
        if (op.retry(err)) {
          return;
        }
        if (err) {
          arguments[0] = op.mainError();
        }
        callback.apply(this, arguments);
      });
      op.attempt(function () {
        original.apply(obj, args);
      });
    }.bind(obj, original);
    obj[method].options = options;
  }
};

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/***/ ((module) => {

function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') {
    options = {
      forever: options
    };
  }
  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;
  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
module.exports = RetryOperation;
RetryOperation.prototype.reset = function () {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function () {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._timeouts = [];
  this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function (err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (!err) {
    return false;
  }
  var currentTime = new Date().getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error('RetryOperation timeout occurred'));
    return false;
  }
  this._errors.push(err);
  var timeout = this._timeouts.shift();
  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }
  var self = this;
  this._timer = setTimeout(function () {
    self._attempts++;
    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function () {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);
      if (self._options.unref) {
        self._timeout.unref();
      }
    }
    self._fn(self._attempts);
  }, timeout);
  if (this._options.unref) {
    this._timer.unref();
  }
  return true;
};
RetryOperation.prototype.attempt = function (fn, timeoutOps) {
  this._fn = fn;
  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }
  var self = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function () {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }
  this._operationStart = new Date().getTime();
  this._fn(this._attempts);
};
RetryOperation.prototype["try"] = function (fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};
RetryOperation.prototype.start = function (fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype["try"];
RetryOperation.prototype.errors = function () {
  return this._errors;
};
RetryOperation.prototype.attempts = function () {
  return this._attempts;
};
RetryOperation.prototype.mainError = function () {
  if (this._errors.length === 0) {
    return null;
  }
  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;
  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;
    counts[message] = count;
    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }
  return mainError;
};

/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
var Comparator = /*#__PURE__*/function () {
  function Comparator(comp, options) {
    _classCallCheck(this, Comparator);
    options = parseOptions(options);
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    comp = comp.trim().split(/\s+/).join(' ');
    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug('comp', this);
  }
  return _createClass(Comparator, [{
    key: "parse",
    value: function parse(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: ".concat(comp));
      }
      this.operator = m[1] !== undefined ? m[1] : '';
      if (this.operator === '=') {
        this.operator = '';
      }

      // if it literally is just '>' or '' then allow anything.
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.value;
    }
  }, {
    key: "test",
    value: function test(version) {
      debug('Comparator.test', version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
  }, {
    key: "intersects",
    value: function intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }
      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);

      // Special cases where nothing can possibly be lower
      if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
        return false;
      }

      // Same direction increasing (> or >=)
      if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
        return true;
      }
      // Same direction decreasing (< or <=)
      if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
        return true;
      }
      // same SemVer and both sides are inclusive (<= or >=)
      if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
        return true;
      }
      // opposite directions less than
      if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
        return true;
      }
      // opposite directions greater than
      if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
        return true;
      }
      return false;
    }
  }], [{
    key: "ANY",
    get: function get() {
      return ANY;
    }
  }]);
}();
module.exports = Comparator;
var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");
var _require = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
  re = _require.safeRe,
  t = _require.t;
var cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js");
var debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js");
var SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js");
var Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js");

/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SPACE_CHARACTERS = /\s+/g;

// hoisted class for cyclic dependency
var Range = /*#__PURE__*/function () {
  function Range(range, options) {
    var _this = this;
    _classCallCheck(this, Range);
    options = parseOptions(options);
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value;
      this.set = [[range]];
      this.formatted = undefined;
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

    // First, split on ||
    this.set = this.raw.split('||')
    // map the range to a 2d array of comparators
    .map(function (r) {
      return _this.parseRange(r.trim());
    })
    // throw out any comparator lists that are empty
    // this generally means that it was not a valid range, which is allowed
    // in loose mode, but will still throw if the WHOLE range is invalid.
    .filter(function (c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: ".concat(this.raw));
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      var first = this.set[0];
      this.set = this.set.filter(function (c) {
        return !isNullSet(c[0]);
      });
      if (this.set.length === 0) {
        this.set = [first];
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        var _iterator = _createForOfIteratorHelper(this.set),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var c = _step.value;
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    this.formatted = undefined;
  }
  return _createClass(Range, [{
    key: "range",
    get: function get() {
      if (this.formatted === undefined) {
        this.formatted = '';
        for (var i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += '||';
          }
          var comps = this.set[i];
          for (var k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += ' ';
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
  }, {
    key: "format",
    value: function format() {
      return this.range;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.range;
    }
  }, {
    key: "parseRange",
    value: function parseRange(range) {
      var _this2 = this;
      // memoize range parsing for performance.
      // this is a very hot path, and fully deterministic.
      var memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      var memoKey = memoOpts + ':' + range;
      var cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      var loose = this.options.loose;
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug('hyphen replace', range);

      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range);

      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug('tilde trim', range);

      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug('caret trim', range);

      // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      var rangeList = range.split(' ').map(function (comp) {
        return parseComparator(comp, _this2.options);
      }).join(' ').split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(function (comp) {
        return replaceGTE0(comp, _this2.options);
      });
      if (loose) {
        // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter(function (comp) {
          debug('loose invalid filter', comp, _this2.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug('range list', rangeList);

      // if any comparators are the null set, then replace with JUST null set
      // if more than one comparator, remove any * comparators
      // also, don't include the same comparator more than once
      var rangeMap = new Map();
      var comparators = rangeList.map(function (comp) {
        return new Comparator(comp, _this2.options);
      });
      var _iterator2 = _createForOfIteratorHelper(comparators),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var comp = _step2.value;
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (rangeMap.size > 1 && rangeMap.has('')) {
        rangeMap["delete"]('');
      }
      var result = _toConsumableArray(rangeMap.values());
      cache.set(memoKey, result);
      return result;
    }
  }, {
    key: "intersects",
    value: function intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }
      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }

    // if ANY of the sets match ALL of its comparators, then pass
  }, {
    key: "test",
    value: function test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }]);
}();
module.exports = Range;
var LRU = __webpack_require__(/*! ../internal/lrucache */ "./node_modules/semver/internal/lrucache.js");
var cache = new LRU();
var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");
var Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js");
var debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js");
var SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js");
var _require = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
  re = _require.safeRe,
  t = _require.t,
  comparatorTrimReplace = _require.comparatorTrimReplace,
  tildeTrimReplace = _require.tildeTrimReplace,
  caretTrimReplace = _require.caretTrimReplace;
var _require2 = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js"),
  FLAG_INCLUDE_PRERELEASE = _require2.FLAG_INCLUDE_PRERELEASE,
  FLAG_LOOSE = _require2.FLAG_LOOSE;
var isNullSet = function isNullSet(c) {
  return c.value === '<0.0.0-0';
};
var isAny = function isAny(c) {
  return c.value === '';
};

// take a set of comparators and determine whether there
// exists a version which can satisfy it
var isSatisfiable = function isSatisfiable(comparators, options) {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
var parseComparator = function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
};
var isX = function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
};

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
var replaceTildes = function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (c) {
    return replaceTilde(c, options);
  }).join(' ');
};
var replaceTilde = function replaceTilde(comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;
    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
    }
    debug('tilde return', ret);
    return ret;
  });
};

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
var replaceCarets = function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (c) {
    return replaceCaret(c, options);
  }).join(' ');
};
var replaceCaret = function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  var z = options.includePrerelease ? '-0' : '';
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;
    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
    } else if (isX(p)) {
      if (M === '0') {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
      } else {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (M === '0') {
        if (m === '0') {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
        }
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
      }
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0') {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
        }
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
      }
    }
    debug('caret return', ret);
    return ret;
  });
};
var replaceXRanges = function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (c) {
    return replaceXRange(c, options);
  }).join(' ');
};
var replaceXRange = function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;
    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : '';
    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }
      p = 0;
      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }
      if (gtlt === '<') {
        pr = '-0';
      }
      ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
    } else if (xm) {
      ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
    } else if (xp) {
      ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
    }
    debug('xRange return', ret);
    return ret;
  });
};

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
var replaceStars = function replaceStars(comp, options) {
  debug('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '');
};
var replaceGTE0 = function replaceGTE0(comp, options) {
  debug('replaceGTE0', comp, options);
  return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
};

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
var hyphenReplace = function hyphenReplace(incPr) {
  return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
    } else if (isX(fp)) {
      from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
    } else if (fpr) {
      from = ">=".concat(from);
    } else {
      from = ">=".concat(from).concat(incPr ? '-0' : '');
    }
    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = "<".concat(+tM + 1, ".0.0-0");
    } else if (isX(tp)) {
      to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
    } else if (tpr) {
      to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
    } else if (incPr) {
      to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
    } else {
      to = "<=".concat(to);
    }
    return "".concat(from, " ").concat(to).trim();
  };
};
var testSet = function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var _i = 0; _i < set.length; _i++) {
      debug(set[_i].semver);
      if (set[_i].semver === Comparator.ANY) {
        continue;
      }
      if (set[_i].semver.prerelease.length > 0) {
        var allowed = set[_i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }
  return true;
};

/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js");
var _require = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js"),
  MAX_LENGTH = _require.MAX_LENGTH,
  MAX_SAFE_INTEGER = _require.MAX_SAFE_INTEGER;
var _require2 = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
  re = _require2.safeRe,
  t = _require2.t;
var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");
var _require3 = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js"),
  compareIdentifiers = _require3.compareIdentifiers;
var SemVer = /*#__PURE__*/function () {
  function SemVer(version, options) {
    _classCallCheck(this, SemVer);
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError("Invalid version. Must be a string. Got type \"".concat(_typeof(version), "\"."));
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
    }
    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: ".concat(version));
    }
    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }
  return _createClass(SemVer, [{
    key: "format",
    value: function format() {
      this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
      if (this.prerelease.length) {
        this.version += "-".concat(this.prerelease.join('.'));
      }
      return this.version;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.version;
    }
  }, {
    key: "compare",
    value: function compare(other) {
      debug('SemVer.compare', this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
  }, {
    key: "compareMain",
    value: function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
  }, {
    key: "comparePre",
    value: function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
  }, {
    key: "compareBuild",
    value: function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i = 0;
      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('build compare', i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }

    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
  }, {
    key: "inc",
    value: function inc(release, identifier, identifierBase) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier, identifierBase);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier, identifierBase);
          break;
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier, identifierBase);
          this.inc('pre', identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier, identifierBase);
          }
          this.inc('pre', identifier, identifierBase);
          break;
        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case 'pre':
          {
            var base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error('invalid increment argument: identifier is empty');
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              var i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                // didn't increment anything
                if (identifier === this.prerelease.join('.') && identifierBase === false) {
                  throw new Error('invalid increment argument: identifier already exists');
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
              var prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
        default:
          throw new Error("invalid increment argument: ".concat(release));
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += "+".concat(this.build.join('.'));
      }
      return this;
    }
  }]);
}();
module.exports = SemVer;

/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");
var clean = function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
};
module.exports = clean;

/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js");
var neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js");
var gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js");
var gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js");
var lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js");
var lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js");
var cmp = function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') {
        a = a.version;
      }
      if (_typeof(b) === 'object') {
        b = b.version;
      }
      return a === b;
    case '!==':
      if (_typeof(a) === 'object') {
        a = a.version;
      }
      if (_typeof(b) === 'object') {
        b = b.version;
      }
      return a !== b;
    case '':
    case '=':
    case '==':
      return eq(a, b, loose);
    case '!=':
      return neq(a, b, loose);
    case '>':
      return gt(a, b, loose);
    case '>=':
      return gte(a, b, loose);
    case '<':
      return lt(a, b, loose);
    case '<=':
      return lte(a, b, loose);
    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};
module.exports = cmp;

/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");
var _require = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
  re = _require.safeRe,
  t = _require.t;
var coerce = function coerce(version, options) {
  if (version instanceof SemVer) {
    return version;
  }
  if (typeof version === 'number') {
    version = String(version);
  }
  if (typeof version !== 'string') {
    return null;
  }
  options = options || {};
  var match = null;
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    var next;
    while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  var major = match[2];
  var minor = match[3] || '0';
  var patch = match[4] || '0';
  var prerelease = options.includePrerelease && match[5] ? "-".concat(match[5]) : '';
  var build = options.includePrerelease && match[6] ? "+".concat(match[6]) : '';
  return parse("".concat(major, ".").concat(minor, ".").concat(patch).concat(prerelease).concat(build), options);
};
module.exports = coerce;

/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var compareBuild = function compareBuild(a, b, loose) {
  var versionA = new SemVer(a, loose);
  var versionB = new SemVer(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;

/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var compareLoose = function compareLoose(a, b) {
  return compare(a, b, true);
};
module.exports = compareLoose;

/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var compare = function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
};
module.exports = compare;

/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(/*! ./parse.js */ "./node_modules/semver/functions/parse.js");
var diff = function diff(version1, version2) {
  var v1 = parse(version1, null, true);
  var v2 = parse(version2, null, true);
  var comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  var v1Higher = comparison > 0;
  var highVersion = v1Higher ? v1 : v2;
  var lowVersion = v1Higher ? v2 : v1;
  var highHasPre = !!highVersion.prerelease.length;
  var lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major';
    }

    // Otherwise it can be determined by checking the high version

    if (highVersion.patch) {
      // anything higher than a patch bump would result in the wrong version
      return 'patch';
    }
    if (highVersion.minor) {
      // anything higher than a minor bump would result in the wrong version
      return 'minor';
    }

    // bumping major/minor/patch all have same result
    return 'major';
  }

  // add the `pre` prefix if we are going to a prerelease version
  var prefix = highHasPre ? 'pre' : '';
  if (v1.major !== v2.major) {
    return prefix + 'major';
  }
  if (v1.minor !== v2.minor) {
    return prefix + 'minor';
  }
  if (v1.patch !== v2.patch) {
    return prefix + 'patch';
  }

  // high and low are preleases
  return 'prerelease';
};
module.exports = diff;

/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var eq = function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
};
module.exports = eq;

/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var gt = function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
};
module.exports = gt;

/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var gte = function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
};
module.exports = gte;

/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var inc = function inc(version, release, options, identifier, identifierBase) {
  if (typeof options === 'string') {
    identifierBase = identifier;
    identifier = options;
    options = undefined;
  }
  try {
    return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
module.exports = inc;

/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var lt = function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
};
module.exports = lt;

/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var lte = function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
};
module.exports = lte;

/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var major = function major(a, loose) {
  return new SemVer(a, loose).major;
};
module.exports = major;

/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var minor = function minor(a, loose) {
  return new SemVer(a, loose).minor;
};
module.exports = minor;

/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var neq = function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
};
module.exports = neq;

/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var parse = function parse(version, options) {
  var throwErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (version instanceof SemVer) {
    return version;
  }
  try {
    return new SemVer(version, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
module.exports = parse;

/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var patch = function patch(a, loose) {
  return new SemVer(a, loose).patch;
};
module.exports = patch;

/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");
var prerelease = function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;

/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");
var rcompare = function rcompare(a, b, loose) {
  return compare(b, a, loose);
};
module.exports = rcompare;

/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js");
var rsort = function rsort(list, loose) {
  return list.sort(function (a, b) {
    return compareBuild(b, a, loose);
  });
};
module.exports = rsort;

/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var satisfies = function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }
  return range.test(version);
};
module.exports = satisfies;

/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js");
var sort = function sort(list, loose) {
  return list.sort(function (a, b) {
    return compareBuild(a, b, loose);
  });
};
module.exports = sort;

/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");
var valid = function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
};
module.exports = valid;

/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
var internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js");
var constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js");
var SemVer = __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js");
var identifiers = __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js");
var parse = __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js");
var valid = __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js");
var clean = __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js");
var inc = __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js");
var diff = __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js");
var major = __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js");
var minor = __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js");
var patch = __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js");
var prerelease = __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js");
var compare = __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js");
var rcompare = __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js");
var compareLoose = __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js");
var compareBuild = __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js");
var sort = __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js");
var rsort = __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js");
var gt = __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js");
var lt = __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js");
var eq = __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js");
var neq = __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js");
var gte = __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js");
var lte = __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js");
var cmp = __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js");
var coerce = __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js");
var Comparator = __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js");
var Range = __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js");
var satisfies = __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js");
var toComparators = __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js");
var maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js");
var minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js");
var minVersion = __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js");
var validRange = __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js");
var outside = __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js");
var gtr = __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js");
var ltr = __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js");
var intersects = __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js");
var simplifyRange = __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js");
var subset = __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js");
module.exports = {
  parse: parse,
  valid: valid,
  clean: clean,
  inc: inc,
  diff: diff,
  major: major,
  minor: minor,
  patch: patch,
  prerelease: prerelease,
  compare: compare,
  rcompare: rcompare,
  compareLoose: compareLoose,
  compareBuild: compareBuild,
  sort: sort,
  rsort: rsort,
  gt: gt,
  lt: lt,
  eq: eq,
  neq: neq,
  gte: gte,
  lte: lte,
  cmp: cmp,
  coerce: coerce,
  Comparator: Comparator,
  Range: Range,
  satisfies: satisfies,
  toComparators: toComparators,
  maxSatisfying: maxSatisfying,
  minSatisfying: minSatisfying,
  minVersion: minVersion,
  validRange: validRange,
  outside: outside,
  gtr: gtr,
  ltr: ltr,
  intersects: intersects,
  simplifyRange: simplifyRange,
  subset: subset,
  SemVer: SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};

/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
var SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
var RELEASE_TYPES = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
module.exports = {
  MAX_LENGTH: MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  RELEASE_TYPES: RELEASE_TYPES,
  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};

/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var debug = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
  var _console;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
} : function () {};
module.exports = debug;

/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

var numeric = /^[0-9]+$/;
var compareIdentifiers = function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
};
module.exports = {
  compareIdentifiers: compareIdentifiers,
  rcompareIdentifiers: rcompareIdentifiers
};

/***/ }),

/***/ "./node_modules/semver/internal/lrucache.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/internal/lrucache.js ***!
  \**************************************************/
/***/ ((module) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var LRUCache = /*#__PURE__*/function () {
  function LRUCache() {
    _classCallCheck(this, LRUCache);
    this.max = 1000;
    this.map = new Map();
  }
  return _createClass(LRUCache, [{
    key: "get",
    value: function get(key) {
      var value = this.map.get(key);
      if (value === undefined) {
        return undefined;
      } else {
        // Remove the key from the map and add it to the end
        this.map["delete"](key);
        this.map.set(key, value);
        return value;
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      return this.map["delete"](key);
    }
  }, {
    key: "set",
    value: function set(key, value) {
      var deleted = this["delete"](key);
      if (!deleted && value !== undefined) {
        // If cache is full, delete the least recently used item
        if (this.map.size >= this.max) {
          var firstKey = this.map.keys().next().value;
          this["delete"](firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }]);
}();
module.exports = LRUCache;

/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// parse out just the options we care about
var looseOption = Object.freeze({
  loose: true
});
var emptyOpts = Object.freeze({});
var parseOptions = function parseOptions(options) {
  if (!options) {
    return emptyOpts;
  }
  if (_typeof(options) !== 'object') {
    return looseOption;
  }
  return options;
};
module.exports = parseOptions;

/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var _require = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js"),
  MAX_SAFE_COMPONENT_LENGTH = _require.MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH = _require.MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH = _require.MAX_LENGTH;
var debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js");
exports = module.exports = {};

// The actual regexps go on exports.re
var re = exports.re = [];
var safeRe = exports.safeRe = [];
var src = exports.src = [];
var t = exports.t = {};
var R = 0;
var LETTERDASHNUMBER = '[a-zA-Z0-9-]';

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
var safeRegexReplacements = [['\\s', 1], ['\\d', MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]];
var makeSafeRegex = function makeSafeRegex(value) {
  for (var _i = 0, _safeRegexReplacement = safeRegexReplacements; _i < _safeRegexReplacement.length; _i++) {
    var _safeRegexReplacement2 = _slicedToArray(_safeRegexReplacement[_i], 2),
      token = _safeRegexReplacement2[0],
      max = _safeRegexReplacement2[1];
    value = value.split("".concat(token, "*")).join("".concat(token, "{0,").concat(max, "}")).split("".concat(token, "+")).join("".concat(token, "{1,").concat(max, "}"));
  }
  return value;
};
var createToken = function createToken(name, value, isGlobal) {
  var safe = makeSafeRegex(value);
  var index = R++;
  debug(name, index, value);
  t[name] = index;
  src[index] = value;
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
};

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', "\\d*[a-zA-Z-]".concat(LETTERDASHNUMBER, "*"));

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")"));

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))"));

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', "".concat(LETTERDASHNUMBER, "+"));

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))"));

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
createToken('FULL', "^".concat(src[t.FULLPLAIN], "$"));

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
createToken('GTLT', '((?:<|>)?=?)');

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$"));

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?"));
createToken('COERCE', "".concat(src[t.COERCEPLAIN], "(?:$|[^\\d])"));
createToken('COERCEFULL', src[t.COERCEPLAIN] + "(?:".concat(src[t.PRERELEASE], ")?") + "(?:".concat(src[t.BUILD], ")?") + "(?:$|[^\\d])");
createToken('COERCERTL', src[t.COERCE], true);
createToken('COERCERTLFULL', src[t.COERCEFULL], true);

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$"));

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
exports.caretTrimReplace = '$1^';
createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$"));

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$"));

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
exports.comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$");

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');

/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
var outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js");
var gtr = function gtr(version, range, options) {
  return outside(version, range, '>', options);
};
module.exports = gtr;

/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var intersects = function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2, options);
};
module.exports = intersects;

/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js");
// Determine if version is less than all the versions possible in the range
var ltr = function ltr(version, range, options) {
  return outside(version, range, '<', options);
};
module.exports = ltr;

/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var maxSatisfying = function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;
  var rangeObj = null;
  try {
    rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
};
module.exports = maxSatisfying;

/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var minSatisfying = function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;
  var rangeObj = null;
  try {
    rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
};
module.exports = minSatisfying;

/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js");
var minVersion = function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');
  if (range.test(minver)) {
    return minver;
  }
  minver = new SemVer('0.0.0-0');
  if (range.test(minver)) {
    return minver;
  }
  minver = null;
  var _loop = function _loop() {
    var comparators = range.set[i];
    var setMin = null;
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver;
          }
          break;
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;
        /* istanbul ignore next */
        default:
          throw new Error("Unexpected operation: ".concat(comparator.operator));
      }
    });
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin;
    }
  };
  for (var i = 0; i < range.set.length; ++i) {
    _loop();
  }
  if (minver && range.test(minver)) {
    return minver;
  }
  return null;
};
module.exports = minVersion;

/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");
var Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js");
var ANY = Comparator.ANY;
var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js");
var gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js");
var lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js");
var lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js");
var gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js");
var outside = function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.
  var _loop = function _loop() {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0');
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      // If the edge version comparator has a operator then our version
      // isn't outside it
      if (high.operator === comp || high.operator === ecomp) {
        return {
          v: false
        };
      }

      // If the lowest version comparator has an operator and our version
      // is less than it then it isn't higher than the range
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return {
          v: false
        };
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return {
          v: false
        };
      }
    },
    _ret;
  for (var i = 0; i < range.set.length; ++i) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return true;
};
module.exports = outside;

/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
var satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js");
var compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js");
module.exports = function (versions, range, options) {
  var set = [];
  var first = null;
  var prev = null;
  var v = versions.sort(function (a, b) {
    return compare(a, b, options);
  });
  var _iterator = _createForOfIteratorHelper(v),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var version = _step.value;
      var included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (first) {
    set.push([first, null]);
  }
  var ranges = [];
  for (var _i = 0, _set = set; _i < _set.length; _i++) {
    var _set$_i = _slicedToArray(_set[_i], 2),
      min = _set$_i[0],
      max = _set$_i[1];
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push('*');
    } else if (!max) {
      ranges.push(">=".concat(min));
    } else if (min === v[0]) {
      ranges.push("<=".concat(max));
    } else {
      ranges.push("".concat(min, " - ").concat(max));
    }
  }
  var simplified = ranges.join(' || ');
  var original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range;
};

/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js");
var Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js");
var ANY = Comparator.ANY;
var satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js");
var compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js");

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

var subset = function subset(sub, dom) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (sub === dom) {
    return true;
  }
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  var sawNonNull = false;
  var _iterator = _createForOfIteratorHelper(sub.set),
    _step;
  try {
    OUTER: for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var simpleSub = _step.value;
      var _iterator2 = _createForOfIteratorHelper(dom.set),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var simpleDom = _step2.value;
          var isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (sawNonNull) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
};
var minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
var minimumVersion = [new Comparator('>=0.0.0')];
var simpleSubset = function simpleSubset(sub, dom, options) {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  var eqSet = new Set();
  var gt, lt;
  var _iterator3 = _createForOfIteratorHelper(sub),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var c = _step3.value;
      if (c.operator === '>' || c.operator === '>=') {
        gt = higherGT(gt, c, options);
      } else if (c.operator === '<' || c.operator === '<=') {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  if (eqSet.size > 1) {
    return null;
  }
  var gtltComp;
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null;
    }
  }

  // will iterate one or zero times
  var _iterator4 = _createForOfIteratorHelper(eqSet),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var eq = _step4.value;
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      var _iterator6 = _createForOfIteratorHelper(dom),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _c = _step6.value;
          if (!satisfies(eq, String(_c), options)) {
            return false;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return true;
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  var higher, lower;
  var hasDomLT, hasDomGT;
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  var needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
  var needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  var _iterator5 = _createForOfIteratorHelper(dom),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _c2 = _step5.value;
      hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
      hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';
      if (gt) {
        if (needDomGTPre) {
          if (_c2.semver.prerelease && _c2.semver.prerelease.length && _c2.semver.major === needDomGTPre.major && _c2.semver.minor === needDomGTPre.minor && _c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (_c2.operator === '>' || _c2.operator === '>=') {
          higher = higherGT(gt, _c2, options);
          if (higher === _c2 && higher !== gt) {
            return false;
          }
        } else if (gt.operator === '>=' && !satisfies(gt.semver, String(_c2), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (_c2.semver.prerelease && _c2.semver.prerelease.length && _c2.semver.major === needDomLTPre.major && _c2.semver.minor === needDomLTPre.minor && _c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (_c2.operator === '<' || _c2.operator === '<=') {
          lower = lowerLT(lt, _c2, options);
          if (lower === _c2 && lower !== lt) {
            return false;
          }
        } else if (lt.operator === '<=' && !satisfies(lt.semver, String(_c2), options)) {
          return false;
        }
      }
      if (!_c2.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }

    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false;
  }
  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false;
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};

// >=1.2.3 is lower than >1.2.3
var higherGT = function higherGT(a, b, options) {
  if (!a) {
    return b;
  }
  var comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
};

// <=1.2.3 is higher than <1.2.3
var lowerLT = function lowerLT(a, b, options) {
  if (!a) {
    return b;
  }
  var comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};
module.exports = subset;

/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

// Mostly just for testing and legacy API reasons
var toComparators = function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
};
module.exports = toComparators;

/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");
var validRange = function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
};
module.exports = validRange;

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID: randomUUID
});

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).

var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  //
  // Note to future-self: No, you can't remove the `toLowerCase()` call.
  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var uuid = unsafeStringify(arr, offset);
  // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-browser/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");

function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./scripts/browserAgent.js":
/*!*********************************!*\
  !*** ./scripts/browserAgent.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   browserAgent: () => (/* binding */ browserAgent)
/* harmony export */ });
/* harmony import */ var _browserControl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserControl.js */ "./scripts/browserControl.js");
/* harmony import */ var _vectorStore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vectorStore.js */ "./scripts/vectorStore.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * browserAgent.js
 * 
 * DESCRIPTION:
 * The BrowserAgent handles processing page content and preparing embeddings, as well as performing
 * embedding searches when requested by Chromie's function calls.
 * 
 * CHANGES:
 * - No calls to vectorStore.initialize() here.
 * - Ensure that embeddings are always associated with the same URL for searches.
 * - Remove references to storeEmbeddings(); now we only have addDocuments().
 * - No use of lastProcessedUrl.
 * - No attempt to call similaritySearchByVector directly.
 * - The search logic remains the same, we trust service-worker and vectorStore to do correct queries.
 * - Ensure final link is trimmed and correct.
 * - Do not append results to chat here; just return them.
 */



var DEBUG = true;
function log() {
  if (DEBUG) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    (_console = console).log.apply(_console, ['[Browser Agent]'].concat(args));
  }
}
var BROWSER_AGENT_PROMPT = "I am a Browser Agent specialized in processing and formatting webpage content search results. My role is to:\n\n1. Process Search Results:\n- Analyze embedding search results from the current webpage\n- Extract and format the most relevant information\n- Combine related content for better context\n- Always maintain proper formatting with tags\n\n2. Link Analysis:\n- Find and extract relevant URLs from search results\n- Understand link context and relevance\n- Return complete, untruncated URLs\n- Preserve link text and surrounding context\n\n3. Response Format:\nFor navigation queries (when [LINK] tag is in query):\n- Find the most relevant URL from search results\n- Format: [LINK]full_url[/LINK]\n[CONTENT]surrounding context[/CONTENT]\n- Always return complete, untruncated URLs\n\nFor content queries (when [CONTENT] tag is in query):\n- Extract relevant content sections from search results\n- Format: [CONTENT]relevant content[/CONTENT]\n- Combine related information for better context\n- Focus on answering the specific query\n\n4. Context Rules:\n- Always provide complete URLs, never truncate\n- Include surrounding context for better understanding\n- Preserve exact link text and descriptions\n- Maintain proper formatting with tags\n\nExample Outputs:\nFor navigation query \"[LINK]space.com[/LINK] [CONTENT]what causes northern lights[/CONTENT]\":\n[LINK]https://www.space.com/15139-northern-lights-auroras-earth-facts-sdcmp.html[/LINK]\n[CONTENT]What causes the northern lights? This comprehensive guide explains how the Sun's charged particles interact with Earth's magnetic field to create the aurora borealis.[/CONTENT]\n\nFor content query \"[CONTENT]explain how aurora works[/CONTENT]\":\n[CONTENT]The aurora borealis occurs when charged particles from the Sun collide with atoms in Earth's atmosphere. These collisions cause the atoms to release photons of light, creating the colorful displays we see. The different colors come from different types of atoms: oxygen produces green and red, while nitrogen creates blue and purple hues.[/CONTENT]";
var BrowserAgent = /*#__PURE__*/function () {
  function BrowserAgent() {
    _classCallCheck(this, BrowserAgent);
    this.settings = {
      contextWindow: 4000,
      maxTokensPerChunk: 500,
      maxResults: 4
    };
    this.state = {
      currentUrl: null,
      pageContent: null,
      contentProcessed: false,
      processingUrls: new Set(),
      linkMap: new Map(),
      currentContextSize: 0,
      contextHistory: [],
      pageChunks: []
    };
  }
  return _createClass(BrowserAgent, [{
    key: "processPageContent",
    value: function () {
      var _processPageContent = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(content, url) {
        var hasExisting, formattedContent, response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              log('Starting processPageContent with URL:', url);
              if (!(!content || !url)) {
                _context.next = 3;
                break;
              }
              throw new Error('Content and URL are required');
            case 3:
              if (!this.state.processingUrls.has(url)) {
                _context.next = 8;
                break;
              }
              log('Content processing already in progress for:', url);
              _context.next = 7;
              return this.waitForEmbeddingsReady(url);
            case 7:
              return _context.abrupt("return", null);
            case 8:
              this.state.processingUrls.add(url);
              this.state.currentUrl = url;
              this.state.pageContent = content;
              this.state.contentProcessed = false;
              this.state.linkMap.clear();
              _context.next = 15;
              return _vectorStore_js__WEBPACK_IMPORTED_MODULE_1__.vectorStore.hasEmbeddings(url);
            case 15:
              hasExisting = _context.sent;
              if (!hasExisting) {
                _context.next = 21;
                break;
              }
              log('Embeddings already exist for URL:', url);
              this.state.contentProcessed = true;
              this.state.processingUrls["delete"](url);
              return _context.abrupt("return", null);
            case 21:
              formattedContent = this._formatDOMContent(content);
              log('Formatted content length:', formattedContent.length);
              _context.next = 25;
              return chrome.runtime.sendMessage({
                action: "generateEmbeddings",
                url: url,
                content: formattedContent
              });
            case 25:
              response = _context.sent;
              if (response.success) {
                _context.next = 37;
                break;
              }
              if (!(response.error && response.error.includes("already being generated"))) {
                _context.next = 32;
                break;
              }
              _context.next = 30;
              return this.waitForEmbeddingsReady(url);
            case 30:
              _context.next = 35;
              break;
            case 32:
              console.error('Failed to generate embeddings:', response.error);
              this.state.processingUrls["delete"](url);
              throw new Error(response.error);
            case 35:
              _context.next = 38;
              break;
            case 37:
              log('Embeddings generated for:', url);
            case 38:
              // Embeddings ready
              this.state.contentProcessed = true;
              this.state.currentUrl = url;
              this.state.processingUrls["delete"](url);
              return _context.abrupt("return", response.result);
            case 42:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function processPageContent(_x, _x2) {
        return _processPageContent.apply(this, arguments);
      }
      return processPageContent;
    }()
  }, {
    key: "waitForEmbeddingsReady",
    value: function () {
      var _waitForEmbeddingsReady = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {
        var attempts;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              attempts = 0;
            case 1:
              _context2.next = 3;
              return _vectorStore_js__WEBPACK_IMPORTED_MODULE_1__.vectorStore.hasEmbeddings(url);
            case 3:
              if (_context2.sent) {
                _context2.next = 11;
                break;
              }
              attempts++;
              if (!(attempts > 30)) {
                _context2.next = 7;
                break;
              }
              throw new Error('Timed out waiting for embeddings to be ready.');
            case 7:
              _context2.next = 9;
              return new Promise(function (resolve) {
                return setTimeout(resolve, 1000);
              });
            case 9:
              _context2.next = 1;
              break;
            case 11:
              this.state.contentProcessed = true;
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function waitForEmbeddingsReady(_x3) {
        return _waitForEmbeddingsReady.apply(this, arguments);
      }
      return waitForEmbeddingsReady;
    }()
  }, {
    key: "searchEmbeddings",
    value: function () {
      var _searchEmbeddings = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(query) {
        var parsedCommand, searchQuery, response, formattedResults;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              log('Starting searchEmbeddings with query:', query);
              if (!(!this.state.contentProcessed || !this.state.currentUrl)) {
                _context3.next = 4;
                break;
              }
              log('No active page. Process page content first.');
              throw new Error('No active page. Process page content first.');
            case 4:
              parsedCommand = this.parseCommand(query);
              searchQuery = '';
              if (parsedCommand.link) searchQuery += "URL: ".concat(parsedCommand.link, " ");
              if (parsedCommand.content) searchQuery += parsedCommand.content;
              if (!searchQuery) searchQuery = query;
              log('Searching embeddings with query:', searchQuery);
              _context3.next = 12;
              return chrome.runtime.sendMessage({
                action: "performEmbeddingSearch",
                url: this.state.currentUrl,
                query: searchQuery
              });
            case 12:
              response = _context3.sent;
              if (response.success) {
                _context3.next = 15;
                break;
              }
              throw new Error(response.error || 'Failed to search embeddings');
            case 15:
              log('Received search results:', response.results);
              _context3.next = 18;
              return this.formatSearchResults(response.results, parsedCommand);
            case 18:
              formattedResults = _context3.sent;
              log('Formatted results:', formattedResults);
              return _context3.abrupt("return", formattedResults);
            case 21:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function searchEmbeddings(_x4) {
        return _searchEmbeddings.apply(this, arguments);
      }
      return searchEmbeddings;
    }()
  }, {
    key: "formatSearchResults",
    value: function () {
      var _formatSearchResults = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(results, parsedCommand) {
        var messages, response, formattedContent;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(!results || results.length === 0)) {
                _context4.next = 2;
                break;
              }
              return _context4.abrupt("return", 'No relevant results found.');
            case 2:
              log('Formatting search results:', {
                results: results,
                parsedCommand: parsedCommand
              });
              messages = [{
                role: "system",
                content: BROWSER_AGENT_PROMPT
              }, {
                role: "system",
                content: "Current webpage content from embedding search:\n\n".concat(results.map(function (r) {
                  return r.content;
                }).join('\n\n'))
              }, {
                role: "user",
                content: parsedCommand.link ? "Find and format the most relevant link about: ".concat(parsedCommand.content) : "Extract and format relevant content about: ".concat(parsedCommand.content)
              }];
              log('Sending format request to LMStudio');
              _context4.next = 7;
              return chrome.runtime.sendMessage({
                action: "queryLMStudio",
                messages: messages
              });
            case 7:
              response = _context4.sent;
              if (response.success) {
                _context4.next = 10;
                break;
              }
              throw new Error(response.error || 'Failed to format results');
            case 10:
              formattedContent = response.content.trim(); // Ensure no trailing spaces in the URL
              formattedContent = formattedContent.replace(/\s+\[\/LINK\]/, '[/LINK]');
              log('Received formatted content:', formattedContent);
              return _context4.abrupt("return", formattedContent);
            case 14:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function formatSearchResults(_x5, _x6) {
        return _formatSearchResults.apply(this, arguments);
      }
      return formatSearchResults;
    }()
  }, {
    key: "parseCommand",
    value: function parseCommand(command) {
      log('Parsing command:', command);
      var linkMatch = command.match(/\[LINK\](.*?)\[\/LINK\]/);
      var contentMatch = command.match(/\[CONTENT\](.*?)\[\/CONTENT\]/);
      var parsed = {
        link: linkMatch ? linkMatch[1].trim() : null,
        content: contentMatch ? contentMatch[1].trim() : null
      };
      log('Parsed command:', parsed);
      return parsed;
    }
  }, {
    key: "_formatDOMContent",
    value: function _formatDOMContent(content) {
      var _this = this;
      log('Formatting DOM content...');
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      tempDiv.querySelectorAll('a').forEach(function (link, index) {
        var url = link.href;
        var text = link.textContent.trim();
        var placeholder = "[LINK_".concat(index, "]");
        _this.state.linkMap.set(placeholder, {
          url: url,
          text: text
        });
        link.replaceWith(placeholder);
      });
      tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(function (heading) {
        var level = heading.tagName[1];
        var text = heading.textContent.trim();
        heading.replaceWith("\n\n[HEADING".concat(level, "] ").concat(text, "\n\n"));
      });
      tempDiv.querySelectorAll('ul, ol').forEach(function (list) {
        var items = Array.from(list.querySelectorAll('li')).map(function (item) {
          return "\u2022 ".concat(item.textContent.trim());
        }).join('\n');
        list.replaceWith("\n".concat(items, "\n"));
      });
      var processedContent = tempDiv.textContent;
      this.state.linkMap.forEach(function (linkData, placeholder) {
        processedContent = processedContent.replace(placeholder, "".concat(linkData.text, " [LINK] ").concat(linkData.url, " [/LINK]]"));
      });
      processedContent = processedContent.replace(/\s+/g, ' ').replace(/\[LINK:/g, '\n[LINK:').replace(/\[HEADING/g, '\n\n[HEADING').replace(//g, '\n').trim();
      log('Final processed content:', processedContent);
      return processedContent;
    }
  }, {
    key: "executeCommand",
    value: function () {
      var _executeCommand = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(command) {
        var params,
          _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              params = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
              log('Delegating command execution to browserController:', {
                command: command,
                params: params
              });
              _context5.next = 4;
              return _browserControl_js__WEBPACK_IMPORTED_MODULE_0__.browserController.executeCommand(command, params);
            case 4:
              return _context5.abrupt("return", _context5.sent);
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      function executeCommand(_x7) {
        return _executeCommand.apply(this, arguments);
      }
      return executeCommand;
    }()
  }, {
    key: "updateSettings",
    value: function updateSettings(settings) {
      log('Updating settings:', settings);
      this.settings = _objectSpread(_objectSpread({}, this.settings), settings);
      _vectorStore_js__WEBPACK_IMPORTED_MODULE_1__.vectorStore.updateSettings(settings);
      log('Settings updated:', this.settings);
    }
  }, {
    key: "checkContextSize",
    value: function checkContextSize(text) {
      var estimatedTokens = Math.ceil(text.length / 4);
      var newSize = this.state.currentContextSize + estimatedTokens;
      return {
        canAdd: newSize <= this.settings.contextWindow,
        message: newSize > this.settings.contextWindow ? 'Context window full. Clearing history to continue.' : null
      };
    }
  }, {
    key: "updateContextSize",
    value: function updateContextSize(text) {
      var estimatedTokens = Math.ceil(text.length / 4);
      this.state.currentContextSize += estimatedTokens;
      this.state.contextHistory.push({
        text: text,
        tokens: estimatedTokens
      });
      while (this.state.currentContextSize > this.settings.contextWindow && this.state.contextHistory.length > 0) {
        var removed = this.state.contextHistory.shift();
        this.state.currentContextSize -= removed.tokens;
      }
    }
  }, {
    key: "resetContext",
    value: function resetContext() {
      log('Resetting context tracking.');
      this.state.currentContextSize = 0;
      this.state.contextHistory = [];
      this.state.pageContent = null;
      this.state.pageChunks = [];
      this.state.contentProcessed = false;
      this.state.linkMap.clear();
    }
  }]);
}();
var browserAgent = new BrowserAgent();
var globalScope = typeof window !== 'undefined' ? window : self;
globalScope.browserAgent = browserAgent;

/***/ }),

/***/ "./scripts/browserControl.js":
/*!***********************************!*\
  !*** ./scripts/browserControl.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   browserController: () => (/* binding */ browserController)
/* harmony export */ });
/* harmony import */ var _browserAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserAgent.js */ "./scripts/browserAgent.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * ./scripts/browserControl.js
 * 
 * This module provides browser control functionality for the Chrome extension.
 */


var BrowserController = /*#__PURE__*/function () {
  function BrowserController() {
    var _this = this;
    _classCallCheck(this, BrowserController);
    // Debounced Google search
    _defineProperty(this, "googleSearch", this.debounce(/*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(query) {
        var url, tab;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (query) {
                _context.next = 2;
                break;
              }
              throw new Error('Search query is required');
            case 2:
              url = "https://www.google.com/search?q=".concat(encodeURIComponent(query));
              _context.next = 5;
              return _this.openNewTab(url);
            case 5:
              tab = _context.sent;
              _this.activeTab = tab;
              return _context.abrupt("return", tab);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }(), 1000));
    // Debounced YouTube search
    _defineProperty(this, "youtubeSearch", this.debounce(/*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(query) {
        var url;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (query) {
                _context2.next = 2;
                break;
              }
              throw new Error('Search query is required');
            case 2:
              url = "https://www.youtube.com/results?search_query=".concat(encodeURIComponent(query));
              _context2.next = 5;
              return _this.openNewTab(url);
            case 5:
              return _context2.abrupt("return", _context2.sent);
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }(), 1000));
    this.activeTab = null;
    this.pendingRequests = new Map();
    this.contentProcessingDebounce = new Map();
    this.setupTabListeners();
  }

  // Debounce function
  return _createClass(BrowserController, [{
    key: "debounce",
    value: function debounce(func, wait) {
      var timeout;
      return function executedFunction() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var later = function later() {
          clearTimeout(timeout);
          func.apply(void 0, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
  }, {
    key: "setupTabListeners",
    value: function setupTabListeners() {
      // Debounced content processing function
      var processPageDebounced = this.debounce(function (tabId, tab) {
        var _tab$url;
        if ((_tab$url = tab.url) !== null && _tab$url !== void 0 && _tab$url.includes('google.com/search')) {
          chrome.scripting.executeScript({
            target: {
              tabId: tabId
            },
            files: ['dist/content-script.bundle.js']
          }).then(function () {
            // Send message to content script to process page
            chrome.tabs.sendMessage(tabId, {
              action: 'processPage'
            });
          })["catch"](function (error) {
            console.error('Error injecting content script:', error);
          });
        }
      }, 1000); // 1 second debounce

      // Listen for tab updates
      chrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {
        if (changeInfo.status === 'complete') {
          processPageDebounced(tabId, tab);
        }
      });

      // Listen for content script messages
      chrome.runtime.onMessage.addListener(function (message, sender) {
        if (message.action === "processedContent") {
          _browserAgent_js__WEBPACK_IMPORTED_MODULE_0__.browserAgent.processPageContent(message.content, message.url)["catch"](function (error) {
            console.error('Error processing content:', error);
          });
        }
        // Must return true for async message handling
        return true;
      });
    }
  }, {
    key: "executeCommand",
    value: function () {
      var _executeCommand = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(command) {
        var params,
          requestId,
          _controller,
          controller,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              params = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              // Generate unique request ID
              requestId = Date.now().toString(); // Cancel any existing request for this command
              if (this.pendingRequests.has(command)) {
                _controller = this.pendingRequests.get(command);
                _controller.abort();
                this.pendingRequests["delete"](command);
              }

              // Create new AbortController for this request
              controller = new AbortController();
              this.pendingRequests.set(command, controller);
              _context3.prev = 5;
              _context3.t0 = command;
              _context3.next = _context3.t0 === 'googleSearch' ? 9 : _context3.t0 === 'youtubeSearch' ? 12 : _context3.t0 === 'newTab' ? 15 : _context3.t0 === 'closeTab' ? 18 : _context3.t0 === 'newWindow' ? 21 : _context3.t0 === 'incognito' ? 24 : _context3.t0 === 'reload' ? 27 : _context3.t0 === 'hardReload' ? 30 : _context3.t0 === 'goBack' ? 33 : _context3.t0 === 'goForward' ? 36 : _context3.t0 === 'callBrowserAgent' ? 39 : _context3.t0 === 'scrollDown' ? 44 : _context3.t0 === 'scrollUp' ? 47 : _context3.t0 === 'scrollTop' ? 50 : _context3.t0 === 'scrollBottom' ? 53 : _context3.t0 === 'clickLink' ? 56 : 61;
              break;
            case 9:
              _context3.next = 11;
              return this.googleSearch(params.query);
            case 11:
              return _context3.abrupt("return", _context3.sent);
            case 12:
              _context3.next = 14;
              return this.youtubeSearch(params.query);
            case 14:
              return _context3.abrupt("return", _context3.sent);
            case 15:
              _context3.next = 17;
              return this.openNewTab(params.url);
            case 17:
              return _context3.abrupt("return", _context3.sent);
            case 18:
              _context3.next = 20;
              return this.closeCurrentTab();
            case 20:
              return _context3.abrupt("return", _context3.sent);
            case 21:
              _context3.next = 23;
              return this.openNewWindow();
            case 23:
              return _context3.abrupt("return", _context3.sent);
            case 24:
              _context3.next = 26;
              return this.openIncognitoWindow();
            case 26:
              return _context3.abrupt("return", _context3.sent);
            case 27:
              _context3.next = 29;
              return this.reloadPage();
            case 29:
              return _context3.abrupt("return", _context3.sent);
            case 30:
              _context3.next = 32;
              return this.hardReloadPage();
            case 32:
              return _context3.abrupt("return", _context3.sent);
            case 33:
              _context3.next = 35;
              return this.goBack();
            case 35:
              return _context3.abrupt("return", _context3.sent);
            case 36:
              _context3.next = 38;
              return this.goForward();
            case 38:
              return _context3.abrupt("return", _context3.sent);
            case 39:
              if (params.query) {
                _context3.next = 41;
                break;
              }
              throw new Error('Query is required for callBrowserAgent');
            case 41:
              _context3.next = 43;
              return _browserAgent_js__WEBPACK_IMPORTED_MODULE_0__.browserAgent.searchEmbeddings(params.query);
            case 43:
              return _context3.abrupt("return", _context3.sent);
            case 44:
              _context3.next = 46;
              return this.scrollDown();
            case 46:
              return _context3.abrupt("return", _context3.sent);
            case 47:
              _context3.next = 49;
              return this.scrollUp();
            case 49:
              return _context3.abrupt("return", _context3.sent);
            case 50:
              _context3.next = 52;
              return this.scrollTop();
            case 52:
              return _context3.abrupt("return", _context3.sent);
            case 53:
              _context3.next = 55;
              return this.scrollBottom();
            case 55:
              return _context3.abrupt("return", _context3.sent);
            case 56:
              if (params.url) {
                _context3.next = 58;
                break;
              }
              throw new Error('URL is required for clickLink');
            case 58:
              _context3.next = 60;
              return this.clickLink(params.url);
            case 60:
              return _context3.abrupt("return", _context3.sent);
            case 61:
              throw new Error("Unknown command: ".concat(command));
            case 62:
              _context3.next = 68;
              break;
            case 64:
              _context3.prev = 64;
              _context3.t1 = _context3["catch"](5);
              console.error("Error executing command ".concat(command, ":"), _context3.t1);
              throw _context3.t1;
            case 68:
              _context3.prev = 68;
              // Clean up AbortController
              if (this.pendingRequests.get(command) === controller) {
                this.pendingRequests["delete"](command);
              }
              return _context3.finish(68);
            case 71:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[5, 64, 68, 71]]);
      }));
      function executeCommand(_x3) {
        return _executeCommand.apply(this, arguments);
      }
      return executeCommand;
    }()
  }, {
    key: "openNewTab",
    value: function () {
      var _openNewTab = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", new Promise(function (resolve, reject) {
                try {
                  chrome.tabs.create({
                    url: url || 'chrome://newtab'
                  }, function (tab) {
                    if (chrome.runtime.lastError) {
                      reject(chrome.runtime.lastError);
                    } else {
                      _this2.activeTab = tab;
                      resolve(tab);
                    }
                  });
                } catch (error) {
                  reject(error);
                }
              }));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function openNewTab(_x4) {
        return _openNewTab.apply(this, arguments);
      }
      return openNewTab;
    }()
  }, {
    key: "closeCurrentTab",
    value: function () {
      var _closeCurrentTab = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.tabs.remove(tabs[0].id, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      function closeCurrentTab() {
        return _closeCurrentTab.apply(this, arguments);
      }
      return closeCurrentTab;
    }()
  }, {
    key: "openNewWindow",
    value: function () {
      var _openNewWindow = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", new Promise(function (resolve, reject) {
                chrome.windows.create({}, function (window) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                  } else {
                    resolve(window);
                  }
                });
              }));
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      function openNewWindow() {
        return _openNewWindow.apply(this, arguments);
      }
      return openNewWindow;
    }()
  }, {
    key: "openIncognitoWindow",
    value: function () {
      var _openIncognitoWindow = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              return _context7.abrupt("return", new Promise(function (resolve, reject) {
                chrome.windows.create({
                  incognito: true
                }, function (window) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                  } else {
                    resolve(window);
                  }
                });
              }));
            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      function openIncognitoWindow() {
        return _openIncognitoWindow.apply(this, arguments);
      }
      return openIncognitoWindow;
    }()
  }, {
    key: "reloadPage",
    value: function () {
      var _reloadPage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.tabs.reload(tabs[0].id, {}, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function reloadPage() {
        return _reloadPage.apply(this, arguments);
      }
      return reloadPage;
    }()
  }, {
    key: "hardReloadPage",
    value: function () {
      var _hardReloadPage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.tabs.reload(tabs[0].id, {
                      bypassCache: true
                    }, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function hardReloadPage() {
        return _hardReloadPage.apply(this, arguments);
      }
      return hardReloadPage;
    }()
  }, {
    key: "goBack",
    value: function () {
      var _goBack = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.tabs.goBack(tabs[0].id, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function goBack() {
        return _goBack.apply(this, arguments);
      }
      return goBack;
    }()
  }, {
    key: "goForward",
    value: function () {
      var _goForward = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.tabs.goForward(tabs[0].id, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function goForward() {
        return _goForward.apply(this, arguments);
      }
      return goForward;
    }()
  }, {
    key: "scrollDown",
    value: function () {
      var _scrollDown = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.scripting.executeScript({
                      target: {
                        tabId: tabs[0].id
                      },
                      "function": function _function() {
                        document.dispatchEvent(new KeyboardEvent('keydown', {
                          key: ' ',
                          code: 'Space',
                          keyCode: 32,
                          which: 32
                        }));
                        document.dispatchEvent(new KeyboardEvent('keyup', {
                          key: ' ',
                          code: 'Space',
                          keyCode: 32,
                          which: 32
                        }));
                      }
                    }, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));
      function scrollDown() {
        return _scrollDown.apply(this, arguments);
      }
      return scrollDown;
    }()
  }, {
    key: "scrollUp",
    value: function () {
      var _scrollUp = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.scripting.executeScript({
                      target: {
                        tabId: tabs[0].id
                      },
                      "function": function _function() {
                        document.dispatchEvent(new KeyboardEvent('keydown', {
                          key: ' ',
                          code: 'Space',
                          keyCode: 32,
                          which: 32,
                          shiftKey: true
                        }));
                        document.dispatchEvent(new KeyboardEvent('keyup', {
                          key: ' ',
                          code: 'Space',
                          keyCode: 32,
                          which: 32,
                          shiftKey: true
                        }));
                      }
                    }, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13);
      }));
      function scrollUp() {
        return _scrollUp.apply(this, arguments);
      }
      return scrollUp;
    }()
  }, {
    key: "scrollTop",
    value: function () {
      var _scrollTop = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.scripting.executeScript({
                      target: {
                        tabId: tabs[0].id
                      },
                      "function": function _function() {
                        document.dispatchEvent(new KeyboardEvent('keydown', {
                          key: 'ArrowUp',
                          code: 'ArrowUp',
                          keyCode: 38,
                          which: 38,
                          metaKey: true
                        }));
                        document.dispatchEvent(new KeyboardEvent('keyup', {
                          key: 'ArrowUp',
                          code: 'ArrowUp',
                          keyCode: 38,
                          which: 38,
                          metaKey: true
                        }));
                      }
                    }, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));
      function scrollTop() {
        return _scrollTop.apply(this, arguments);
      }
      return scrollTop;
    }()
  }, {
    key: "scrollBottom",
    value: function () {
      var _scrollBottom = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              return _context15.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.scripting.executeScript({
                      target: {
                        tabId: tabs[0].id
                      },
                      "function": function _function() {
                        document.dispatchEvent(new KeyboardEvent('keydown', {
                          key: 'ArrowDown',
                          code: 'ArrowDown',
                          keyCode: 40,
                          which: 40,
                          metaKey: true
                        }));
                        document.dispatchEvent(new KeyboardEvent('keyup', {
                          key: 'ArrowDown',
                          code: 'ArrowDown',
                          keyCode: 40,
                          which: 40,
                          metaKey: true
                        }));
                      }
                    }, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context15.stop();
          }
        }, _callee15);
      }));
      function scrollBottom() {
        return _scrollBottom.apply(this, arguments);
      }
      return scrollBottom;
    }()
  }, {
    key: "clickLink",
    value: function () {
      var _clickLink = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(url) {
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              return _context16.abrupt("return", new Promise(function (resolve, reject) {
                chrome.tabs.query({
                  active: true,
                  currentWindow: true
                }, function (tabs) {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                  }
                  if (tabs[0]) {
                    chrome.scripting.executeScript({
                      target: {
                        tabId: tabs[0].id
                      },
                      "function": function _function(url) {
                        var link = document.querySelector("a[href=\"".concat(url, "\"]"));
                        if (link) {
                          link.click();
                        } else {
                          throw new Error("Link with URL ".concat(url, " not found"));
                        }
                      },
                      args: [url]
                    }, function () {
                      if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                      } else {
                        resolve();
                      }
                    });
                  } else {
                    reject(new Error('No active tab found'));
                  }
                });
              }));
            case 1:
            case "end":
              return _context16.stop();
          }
        }, _callee16);
      }));
      function clickLink(_x5) {
        return _clickLink.apply(this, arguments);
      }
      return clickLink;
    }()
  }]);
}();
var browserController = new BrowserController();

/***/ }),

/***/ "./scripts/vectorStore.js":
/*!********************************!*\
  !*** ./scripts/vectorStore.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   vectorStore: () => (/* binding */ vectorStore)
/* harmony export */ });
/* harmony import */ var langchain_vectorstores_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langchain/vectorstores/memory */ "./node_modules/langchain/vectorstores/memory.js");
/* harmony import */ var moo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moo */ "./node_modules/moo/moo.js");
/* harmony import */ var moo__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moo__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * ./scripts/vectorStore.js
 * 
 * This module now uses moo instead of tiktoken. We define a custom moo lexer to tokenize
 * the DOM-like content, focusing on isolating links and the text around them into their own chunks.
 * 
 * Steps:
 * 1. Tokenize with moo.
 * 2. Identify links ([LINK]...[/LINK]) and their associated content ([CONTENT]...[/CONTENT]).
 * 3. If text is unrelated to links, chunk it into maxTokensPerChunk-character segments.
 * 4. Return these chunks. The embeddings are still done later by the vector store.
 */



var CustomVectorStore = /*#__PURE__*/function () {
  function CustomVectorStore() {
    var _this = this;
    _classCallCheck(this, CustomVectorStore);
    // Map to store vector stores for different URLs
    this.vectorStores = new Map();
    // Flag to indicate if the vector store is initialized
    this.initialized = false;
    // Maximum characters per chunk
    this.maxTokensPerChunk = 500;
    // Debug flag
    this.debug = true;
    // Promise for initialization
    this.initializationPromise = null;
    // Maximum number of retries for API calls
    this.maxRetries = 3;
    // Delay between retries in milliseconds
    this.retryDelay = 2000;
    // Base URL for LM Studio API
    this.baseUrl = "http://127.0.0.1:1234";
    // Model to use for embeddings
    this.model = "text-embedding-all-minilm-l6-v2-embedding";
    // Map to store pending requests
    this.pendingRequests = new Map();
    // Map to store document metadata
    this.documentMap = new Map();

    // Embeddings object with methods for generating embeddings
    this.embeddings = {
      // Method to generate embeddings for multiple texts
      embedDocuments: function () {
        var _embedDocuments = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(texts) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this.retryOperation(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  var batchSize, results, i, batch, controller, requestId, response, data, progress;
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        // Batch size for processing texts
                        batchSize = 5;
                        results = []; // Loop through texts in batches
                        i = 0;
                      case 3:
                        if (!(i < texts.length)) {
                          _context.next = 29;
                          break;
                        }
                        batch = texts.slice(i, i + batchSize); // Abort controller for fetch requests
                        controller = new AbortController();
                        requestId = Date.now().toString() + i;
                        _this.pendingRequests.set(requestId, controller);
                        _context.prev = 8;
                        _context.next = 11;
                        return fetch("".concat(_this.baseUrl, "/v1/embeddings"), {
                          method: 'POST',
                          headers: {
                            'Content-Type': 'application/json'
                          },
                          body: JSON.stringify({
                            model: _this.model,
                            input: batch
                          }),
                          signal: controller.signal
                        });
                      case 11:
                        response = _context.sent;
                        if (response.ok) {
                          _context.next = 14;
                          break;
                        }
                        throw new Error("Failed to generate embeddings: ".concat(response.status));
                      case 14:
                        _context.next = 16;
                        return response.json();
                      case 16:
                        data = _context.sent;
                        // Extract embeddings from response
                        results.push.apply(results, _toConsumableArray(data.data.map(function (item) {
                          return item.embedding;
                        })));

                        // Send progress update to extension
                        progress = Math.round((i + batch.length) / texts.length * 100);
                        chrome.runtime.sendMessage({
                          action: "embeddingProgress",
                          progress: progress,
                          message: "Processing embeddings: ".concat(progress, "%")
                        });
                      case 20:
                        _context.prev = 20;
                        // Remove request from pending requests
                        _this.pendingRequests["delete"](requestId);
                        return _context.finish(20);
                      case 23:
                        if (!(i + batchSize < texts.length)) {
                          _context.next = 26;
                          break;
                        }
                        _context.next = 26;
                        return new Promise(function (resolve) {
                          return setTimeout(resolve, 100);
                        });
                      case 26:
                        i += batchSize;
                        _context.next = 3;
                        break;
                      case 29:
                        // Send completion message to extension
                        chrome.runtime.sendMessage({
                          action: "embeddingProgress",
                          progress: 100,
                          message: "Embedding processing complete",
                          hide: true
                        });
                        return _context.abrupt("return", results);
                      case 31:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee, null, [[8,, 20, 23]]);
                })));
              case 2:
                return _context2.abrupt("return", _context2.sent);
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function embedDocuments(_x) {
          return _embedDocuments.apply(this, arguments);
        }
        return embedDocuments;
      }(),
      // Method to generate embedding for a single query
      embedQuery: function () {
        var _embedQuery = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(text) {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return _this.retryOperation(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  var controller, requestId, response, data;
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        // Abort controller for fetch request
                        controller = new AbortController();
                        requestId = Date.now().toString();
                        _this.pendingRequests.set(requestId, controller);
                        _context3.prev = 3;
                        _context3.next = 6;
                        return fetch("".concat(_this.baseUrl, "/v1/embeddings"), {
                          method: 'POST',
                          headers: {
                            'Content-Type': 'application/json'
                          },
                          body: JSON.stringify({
                            model: _this.model,
                            input: text
                          }),
                          signal: controller.signal
                        });
                      case 6:
                        response = _context3.sent;
                        if (response.ok) {
                          _context3.next = 9;
                          break;
                        }
                        throw new Error("Failed to generate embedding: ".concat(response.status));
                      case 9:
                        _context3.next = 11;
                        return response.json();
                      case 11:
                        data = _context3.sent;
                        return _context3.abrupt("return", data.data[0].embedding);
                      case 13:
                        _context3.prev = 13;
                        // Remove request from pending requests
                        _this.pendingRequests["delete"](requestId);
                        return _context3.finish(13);
                      case 16:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[3,, 13, 16]]);
                })));
              case 2:
                return _context4.abrupt("return", _context4.sent);
              case 3:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        function embedQuery(_x2) {
          return _embedQuery.apply(this, arguments);
        }
        return embedQuery;
      }()
    };
  }

  // Method to retry an operation with exponential backoff
  return _createClass(CustomVectorStore, [{
    key: "retryOperation",
    value: function () {
      var _retryOperation = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(operation) {
        var _this2 = this;
        var maxRetries,
          lastError,
          _loop,
          _ret,
          attempt,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              maxRetries = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : this.maxRetries;
              lastError = null; // Loop through retries
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(attempt) {
                return _regeneratorRuntime().wrap(function _loop$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.prev = 0;
                      _context5.next = 3;
                      return operation();
                    case 3:
                      _context5.t0 = _context5.sent;
                      return _context5.abrupt("return", {
                        v: _context5.t0
                      });
                    case 7:
                      _context5.prev = 7;
                      _context5.t1 = _context5["catch"](0);
                      // Store the error
                      lastError = _context5.t1;
                      console.warn("Attempt ".concat(attempt + 1, " failed:"), _context5.t1);
                      // Wait before retrying
                      if (!(attempt < maxRetries - 1)) {
                        _context5.next = 14;
                        break;
                      }
                      _context5.next = 14;
                      return new Promise(function (resolve) {
                        return setTimeout(resolve, _this2.retryDelay * (attempt + 1));
                      });
                    case 14:
                    case "end":
                      return _context5.stop();
                  }
                }, _loop, null, [[0, 7]]);
              });
              attempt = 0;
            case 4:
              if (!(attempt < maxRetries)) {
                _context6.next = 12;
                break;
              }
              return _context6.delegateYield(_loop(attempt), "t0", 6);
            case 6:
              _ret = _context6.t0;
              if (!_ret) {
                _context6.next = 9;
                break;
              }
              return _context6.abrupt("return", _ret.v);
            case 9:
              attempt++;
              _context6.next = 4;
              break;
            case 12:
              throw lastError;
            case 13:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function retryOperation(_x3) {
        return _retryOperation.apply(this, arguments);
      }
      return retryOperation;
    }() // Method to check if the LM Studio server is running
  }, {
    key: "checkServerStatus",
    value: function () {
      var _checkServerStatus = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var response, data;
        return _regeneratorRuntime().wrap(function _callee6$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return fetch("".concat(this.baseUrl, "/v1/models"), {
                method: 'GET'
              });
            case 3:
              response = _context7.sent;
              if (response.ok) {
                _context7.next = 6;
                break;
              }
              throw new Error("Server responded with status: ".concat(response.status));
            case 6:
              _context7.next = 8;
              return response.json();
            case 8:
              data = _context7.sent;
              if (!(!data.data || !data.data.length)) {
                _context7.next = 11;
                break;
              }
              throw new Error('No models available from LMStudio');
            case 11:
              return _context7.abrupt("return", true);
            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](0);
              console.error('LMStudio server is not running or not accessible:', _context7.t0);
              return _context7.abrupt("return", false);
            case 18:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this, [[0, 14]]);
      }));
      function checkServerStatus() {
        return _checkServerStatus.apply(this, arguments);
      }
      return checkServerStatus;
    }() // Method to initialize the vector store
  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee8$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (!this.initialized) {
                _context9.next = 2;
                break;
              }
              return _context9.abrupt("return");
            case 2:
              if (!this.initializationPromise) {
                _context9.next = 4;
                break;
              }
              return _context9.abrupt("return", this.initializationPromise);
            case 4:
              // Create a promise for initialization
              this.initializationPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                var serverRunning, response, data, modelAvailable;
                return _regeneratorRuntime().wrap(function _callee7$(_context8) {
                  while (1) switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return _this3.checkServerStatus();
                    case 2:
                      serverRunning = _context8.sent;
                      if (serverRunning) {
                        _context8.next = 5;
                        break;
                      }
                      throw new Error('LMStudio server is not running');
                    case 5:
                      _context8.next = 7;
                      return fetch("".concat(_this3.baseUrl, "/v1/models"));
                    case 7:
                      response = _context8.sent;
                      if (response.ok) {
                        _context8.next = 10;
                        break;
                      }
                      throw new Error("Failed to connect to LMStudio: ".concat(response.status));
                    case 10:
                      _context8.next = 12;
                      return response.json();
                    case 12:
                      data = _context8.sent;
                      if (!(!data.data || !data.data.length)) {
                        _context8.next = 15;
                        break;
                      }
                      throw new Error('No models available from LMStudio');
                    case 15:
                      // Check if the specified model is available
                      modelAvailable = data.data.some(function (m) {
                        return m.id === _this3.model;
                      });
                      if (!modelAvailable) {
                        console.warn("Model ".concat(_this3.model, " not found, using first available model"));
                        _this3.model = data.data[0].id;
                      }

                      // Set initialized flag to true
                      _this3.initialized = true;
                      console.log('Vector store initialized successfully');
                    case 19:
                    case "end":
                      return _context8.stop();
                  }
                }, _callee7);
              }))();
              return _context9.abrupt("return", this.initializationPromise);
            case 6:
            case "end":
              return _context9.stop();
          }
        }, _callee8, this);
      }));
      function initialize() {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }() // Method to get or create a vector store for a given URL
  }, {
    key: "getOrCreateVectorStore",
    value: function () {
      var _getOrCreateVectorStore = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(url) {
        var store;
        return _regeneratorRuntime().wrap(function _callee9$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.initialize();
            case 2:
              // Get the vector store from the map
              store = this.vectorStores.get(url); // If the store doesn't exist, create a new one
              if (!store) {
                store = new langchain_vectorstores_memory__WEBPACK_IMPORTED_MODULE_0__.MemoryVectorStore(this.embeddings);
                this.vectorStores.set(url, store);
              }
              return _context10.abrupt("return", store);
            case 5:
            case "end":
              return _context10.stop();
          }
        }, _callee9, this);
      }));
      function getOrCreateVectorStore(_x4) {
        return _getOrCreateVectorStore.apply(this, arguments);
      }
      return getOrCreateVectorStore;
    }() // Define a moo lexer to tokenize the formatted content
  }, {
    key: "createLexer",
    value: function createLexer() {
      return moo__WEBPACK_IMPORTED_MODULE_1___default().compile({
        // Match start of link format tag
        linkFormatStart: {
          match: /\[LINK\]/,
          lineBreaks: false
        },
        // Match end of link format tag
        linkFormatEnd: {
          match: /\[\/LINK\]/,
          lineBreaks: false
        },
        // Match start of content format tag
        contentFormatStart: {
          match: /\[CONTENT\]/,
          lineBreaks: false
        },
        // Match end of content format tag
        contentFormatEnd: {
          match: /\[\/CONTENT\]/,
          lineBreaks: false
        },
        // Match any text that is not a tag
        text: {
          match: /[^<]+/,
          lineBreaks: true
        },
        // Match whitespace
        WS: {
          match: /\s+/,
          lineBreaks: true
        }
      });
    }

    /**
     * Updated parsing logic:
     *  - If we encounter a [LINK] block, we parse it fully until [/LINK].
     *  - After we finish parsing the link block, we check if the next token is [CONTENT].
     *    If yes, we parse that [CONTENT] block immediately and combine it with the link block
     *    into a single chunk.
     * 
     * This ensures sequences like [LINK]...[/LINK][CONTENT]...[/CONTENT] remain atomic and are
     * not split across multiple chunks, preserving link continuity.
     */
  }, {
    key: "createChunksFromTokens",
    value: function createChunksFromTokens(tokens) {
      var _this4 = this;
      var chunks = [];
      var textBuffer = '';
      var flushTextBuffer = function flushTextBuffer() {
        var txt = textBuffer.trim();
        textBuffer = '';
        while (txt.length > 0) {
          var piece = txt.slice(0, _this4.maxTokensPerChunk);
          txt = txt.slice(_this4.maxTokensPerChunk);
          chunks.push({
            pageContent: "[CONTENT]".concat(piece.trim(), "[/CONTENT]")
          });
        }
      };
      var i = 0;
      while (i < tokens.length) {
        var tok = tokens[i];
        if (tok.type === 'contentFormatStart') {
          // Flush outside text before reading content block
          if (textBuffer.trim().length > 0) {
            flushTextBuffer();
          }
          i++;
          var contentText = '';
          while (i < tokens.length && tokens[i].type !== 'contentFormatEnd') {
            contentText += tokens[i].value;
            i++;
          }

          // Close CONTENT
          if (i < tokens.length && tokens[i].type === 'contentFormatEnd') {
            i++;
          }
          chunks.push({
            pageContent: "[CONTENT]".concat(contentText.trim(), "[/CONTENT]")
          });
        } else if (tok.type === 'linkFormatStart') {
          // Flush outside text before reading link block
          if (textBuffer.trim().length > 0) {
            flushTextBuffer();
          }
          i++;
          var linkText = '';
          while (i < tokens.length && tokens[i].type !== 'linkFormatEnd') {
            linkText += tokens[i].value;
            i++;
          }

          // Close LINK
          if (i < tokens.length && tokens[i].type === 'linkFormatEnd') {
            i++;
          }
          var combinedChunk = "[LINK]".concat(linkText.trim(), "[/LINK]");

          // Check if next token is [CONTENT]. If so, parse it immediately and append.
          if (i < tokens.length && tokens[i].type === 'contentFormatStart') {
            i++;
            var _contentText = '';
            while (i < tokens.length && tokens[i].type !== 'contentFormatEnd') {
              _contentText += tokens[i].value;
              i++;
            }
            // Close CONTENT
            if (i < tokens.length && tokens[i].type === 'contentFormatEnd') {
              i++;
            }
            combinedChunk += "[CONTENT]".concat(_contentText.trim(), "[/CONTENT]");
          }

          // Push the combined [LINK][CONTENT] chunk
          chunks.push({
            pageContent: combinedChunk
          });
        } else if (tok.type === 'text' || tok.type === 'WS') {
          // Accumulate text outside LINK/CONTENT blocks
          textBuffer += tok.value;
          i++;
        } else {
          // Unknown token type, treat as text
          textBuffer += tok.value;
          i++;
        }
      }

      // Flush remaining text as [CONTENT] if any
      if (textBuffer.trim().length > 0) {
        flushTextBuffer();
      }
      return chunks;
    }

    // Method to add documents to the vector store
  }, {
    key: "addDocuments",
    value: function () {
      var _addDocuments = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(url, content) {
        var metadata,
          lexer,
          tokens,
          documents,
          vectorStore,
          existingDocs,
          _args12 = arguments;
        return _regeneratorRuntime().wrap(function _callee11$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              metadata = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {};
              if (content) {
                _context12.next = 3;
                break;
              }
              throw new Error('Content must not be empty');
            case 3:
              _context12.next = 5;
              return this.initialize();
            case 5:
              // Use moo to tokenize
              lexer = this.createLexer();
              lexer.reset(content);
              tokens = Array.from(lexer); // Create chunks from tokens
              documents = this.createChunksFromTokens(tokens); // Get the vector store for the given URL
              _context12.next = 11;
              return this.getOrCreateVectorStore(url);
            case 11:
              vectorStore = _context12.sent;
              _context12.next = 14;
              return this.retryOperation(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                return _regeneratorRuntime().wrap(function _callee10$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      documents.forEach(function (doc) {
                        doc.metadata = _objectSpread({
                          url: url
                        }, metadata);
                      });
                      _context11.next = 3;
                      return vectorStore.addDocuments(documents);
                    case 3:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee10);
              })));
            case 14:
              // Update the document map
              existingDocs = this.documentMap.get(url) || [];
              this.documentMap.set(url, existingDocs.concat(documents));
              return _context12.abrupt("return", {
                status: 'completed',
                chunks: documents.length
              });
            case 17:
            case "end":
              return _context12.stop();
          }
        }, _callee11, this);
      }));
      function addDocuments(_x5, _x6) {
        return _addDocuments.apply(this, arguments);
      }
      return addDocuments;
    }() // Method to perform an embedding search
  }, {
    key: "performEmbeddingSearch",
    value: function () {
      var _performEmbeddingSearch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(queryText, url) {
        var numResults,
          vectorStore,
          queryEmbedding,
          similaritySearchWithScoreResults,
          _args13 = arguments;
        return _regeneratorRuntime().wrap(function _callee12$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              numResults = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : 5;
              _context13.next = 3;
              return this.initialize();
            case 3:
              _context13.next = 5;
              return this.getOrCreateVectorStore(url);
            case 5:
              vectorStore = _context13.sent;
              _context13.next = 8;
              return this.embeddings.embedQuery(queryText);
            case 8:
              queryEmbedding = _context13.sent;
              _context13.next = 11;
              return vectorStore.similaritySearchVectorWithScore(queryEmbedding, numResults);
            case 11:
              similaritySearchWithScoreResults = _context13.sent;
              return _context13.abrupt("return", similaritySearchWithScoreResults.map(function (_ref5) {
                var _ref6 = _slicedToArray(_ref5, 2),
                  doc = _ref6[0],
                  _score = _ref6[1];
                return {
                  link: doc.metadata.url,
                  content: doc.pageContent
                };
              }));
            case 13:
            case "end":
              return _context13.stop();
          }
        }, _callee12, this);
      }));
      function performEmbeddingSearch(_x7, _x8) {
        return _performEmbeddingSearch.apply(this, arguments);
      }
      return performEmbeddingSearch;
    }() // Method to delete a collection from the vector store
  }, {
    key: "deleteCollection",
    value: function () {
      var _deleteCollection = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(url) {
        var store;
        return _regeneratorRuntime().wrap(function _callee13$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              // Get the vector store for the given URL
              store = this.vectorStores.get(url); // If the store exists, delete it
              if (store) {
                this.vectorStores["delete"](url);
              }
              // Delete the document map for the given URL
              this.documentMap["delete"](url);
            case 3:
            case "end":
              return _context14.stop();
          }
        }, _callee13, this);
      }));
      function deleteCollection(_x9) {
        return _deleteCollection.apply(this, arguments);
      }
      return deleteCollection;
    }() // Method to reset the vector store
  }, {
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var _iterator, _step, controller;
        return _regeneratorRuntime().wrap(function _callee14$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              // Abort all pending requests
              _iterator = _createForOfIteratorHelper(this.pendingRequests.values());
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  controller = _step.value;
                  controller.abort();
                }
                // Clear pending requests
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              this.pendingRequests.clear();
              // Clear vector stores
              this.vectorStores.clear();
              // Clear document map
              this.documentMap.clear();
              // Reset initialized flag
              this.initialized = false;
              // Reset initialization promise
              this.initializationPromise = null;
            case 7:
            case "end":
              return _context15.stop();
          }
        }, _callee14, this);
      }));
      function reset() {
        return _reset.apply(this, arguments);
      }
      return reset;
    }() // Method to update settings
  }, {
    key: "updateSettings",
    value: function () {
      var _updateSettings = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(settings) {
        var needsReset;
        return _regeneratorRuntime().wrap(function _callee15$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              needsReset = false; // Update max tokens per chunk if provided
              if (settings.maxTokensPerChunk) {
                this.maxTokensPerChunk = settings.maxTokensPerChunk;
                needsReset = true;
              }
              // Update LM Studio endpoint if provided
              if (settings.lmStudioEndpoint) {
                this.baseUrl = settings.lmStudioEndpoint;
                needsReset = true;
              }
              // Update LM Studio model if provided
              if (settings.lmStudioModel) {
                this.model = settings.lmStudioModel;
                needsReset = true;
              }

              // If any settings were updated, reset the vector store
              if (!needsReset) {
                _context16.next = 9;
                break;
              }
              _context16.next = 7;
              return this.reset();
            case 7:
              _context16.next = 9;
              return this.initialize();
            case 9:
            case "end":
              return _context16.stop();
          }
        }, _callee15, this);
      }));
      function updateSettings(_x10) {
        return _updateSettings.apply(this, arguments);
      }
      return updateSettings;
    }() // Method to check if embeddings exist for a given URL
  }, {
    key: "hasEmbeddings",
    value: function () {
      var _hasEmbeddings = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(url) {
        var docs;
        return _regeneratorRuntime().wrap(function _callee16$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              docs = this.documentMap.get(url);
              return _context17.abrupt("return", docs && docs.length > 0);
            case 2:
            case "end":
              return _context17.stop();
          }
        }, _callee16, this);
      }));
      function hasEmbeddings(_x11) {
        return _hasEmbeddings.apply(this, arguments);
      }
      return hasEmbeddings;
    }()
  }]);
}(); // Export the vector store instance
var vectorStore = new CustomVectorStore();

/***/ }),

/***/ "./node_modules/@langchain/core/dist/callbacks/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseCallbackHandler: () => (/* binding */ BaseCallbackHandler)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ "./node_modules/@langchain/core/dist/load/serializable.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ "./node_modules/@langchain/core/dist/utils/env.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }



/**
 * Abstract class that provides a set of optional methods that can be
 * overridden in derived classes to handle various events during the
 * execution of a LangChain application.
 */
var BaseCallbackHandlerMethodsClass = /*#__PURE__*/_createClass(function BaseCallbackHandlerMethodsClass() {
  _classCallCheck(this, BaseCallbackHandlerMethodsClass);
});
/**
 * Abstract base class for creating callback handlers in the LangChain
 * framework. It provides a set of optional methods that can be overridden
 * in derived classes to handle various events during the execution of a
 * LangChain application.
 */
var BaseCallbackHandler = /*#__PURE__*/function (_BaseCallbackHandlerM) {
  function BaseCallbackHandler(input) {
    var _this;
    _classCallCheck(this, BaseCallbackHandler);
    _this = _callSuper(this, BaseCallbackHandler);
    Object.defineProperty(_this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "ignoreLLM", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "ignoreChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "ignoreAgent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "ignoreRetriever", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "ignoreCustomEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "raiseError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "awaitHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
    });
    _this.lc_kwargs = input || {};
    if (input) {
      var _input$ignoreLLM, _input$ignoreChain, _input$ignoreAgent, _input$ignoreRetrieve, _input$ignoreCustomEv, _input$raiseError, _input$_awaitHandler;
      _this.ignoreLLM = (_input$ignoreLLM = input.ignoreLLM) !== null && _input$ignoreLLM !== void 0 ? _input$ignoreLLM : _this.ignoreLLM;
      _this.ignoreChain = (_input$ignoreChain = input.ignoreChain) !== null && _input$ignoreChain !== void 0 ? _input$ignoreChain : _this.ignoreChain;
      _this.ignoreAgent = (_input$ignoreAgent = input.ignoreAgent) !== null && _input$ignoreAgent !== void 0 ? _input$ignoreAgent : _this.ignoreAgent;
      _this.ignoreRetriever = (_input$ignoreRetrieve = input.ignoreRetriever) !== null && _input$ignoreRetrieve !== void 0 ? _input$ignoreRetrieve : _this.ignoreRetriever;
      _this.ignoreCustomEvent = (_input$ignoreCustomEv = input.ignoreCustomEvent) !== null && _input$ignoreCustomEv !== void 0 ? _input$ignoreCustomEv : _this.ignoreCustomEvent;
      _this.raiseError = (_input$raiseError = input.raiseError) !== null && _input$raiseError !== void 0 ? _input$raiseError : _this.raiseError;
      _this.awaitHandlers = _this.raiseError || ((_input$_awaitHandler = input._awaitHandler) !== null && _input$_awaitHandler !== void 0 ? _input$_awaitHandler : _this.awaitHandlers);
    }
    return _this;
  }
  _inherits(BaseCallbackHandler, _BaseCallbackHandlerM);
  return _createClass(BaseCallbackHandler, [{
    key: "lc_namespace",
    get: function get() {
      return ["langchain_core", "callbacks", this.name];
    }
  }, {
    key: "lc_secrets",
    get: function get() {
      return undefined;
    }
  }, {
    key: "lc_attributes",
    get: function get() {
      return undefined;
    }
  }, {
    key: "lc_aliases",
    get: function get() {
      return undefined;
    }
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
  }, {
    key: "lc_id",
    get:
    /**
     * The final serialized identifier for the module.
     */
    function get() {
      return [].concat(_toConsumableArray(this.lc_namespace), [(0,_load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.get_lc_unique_name)(this.constructor)]);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new this.constructor(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSON.call(this);
    }
  }, {
    key: "toJSONNotImplemented",
    value: function toJSONNotImplemented() {
      return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSONNotImplemented.call(this);
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return this.name;
    }
  }, {
    key: "fromMethods",
    value: function fromMethods(methods) {
      var Handler = /*#__PURE__*/function (_BaseCallbackHandler) {
        function Handler() {
          var _this2;
          _classCallCheck(this, Handler);
          _this2 = _callSuper(this, Handler);
          Object.defineProperty(_this2, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uuid__WEBPACK_IMPORTED_MODULE_2__["default"]()
          });
          Object.assign(_this2, methods);
          return _this2;
        }
        _inherits(Handler, _BaseCallbackHandler);
        return _createClass(Handler);
      }(BaseCallbackHandler);
      return new Handler();
    }
  }]);
}(BaseCallbackHandlerMethodsClass);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/callbacks/manager.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/manager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseCallbackManager: () => (/* binding */ BaseCallbackManager),
/* harmony export */   BaseRunManager: () => (/* binding */ BaseRunManager),
/* harmony export */   CallbackManager: () => (/* binding */ CallbackManager),
/* harmony export */   CallbackManagerForChainRun: () => (/* binding */ CallbackManagerForChainRun),
/* harmony export */   CallbackManagerForLLMRun: () => (/* binding */ CallbackManagerForLLMRun),
/* harmony export */   CallbackManagerForRetrieverRun: () => (/* binding */ CallbackManagerForRetrieverRun),
/* harmony export */   CallbackManagerForToolRun: () => (/* binding */ CallbackManagerForToolRun),
/* harmony export */   TraceGroup: () => (/* binding */ TraceGroup),
/* harmony export */   ensureHandler: () => (/* binding */ ensureHandler),
/* harmony export */   parseCallbackConfigArg: () => (/* binding */ parseCallbackConfigArg),
/* harmony export */   traceAsGroup: () => (/* binding */ traceAsGroup)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/callbacks/base.js");
/* harmony import */ var _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tracers/console.js */ "./node_modules/@langchain/core/dist/tracers/console.js");
/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/utils.js */ "./node_modules/@langchain/core/dist/messages/utils.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/env.js */ "./node_modules/@langchain/core/dist/utils/env.js");
/* harmony import */ var _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tracers/tracer_langchain.js */ "./node_modules/@langchain/core/dist/tracers/tracer_langchain.js");
/* harmony import */ var _promises_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./promises.js */ "./node_modules/@langchain/core/dist/callbacks/promises.js");
/* harmony import */ var _utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/callbacks.js */ "./node_modules/@langchain/core/dist/utils/callbacks.js");
/* harmony import */ var _tracers_base_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tracers/base.js */ "./node_modules/@langchain/core/dist/tracers/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }









function parseCallbackConfigArg(arg) {
  if (!arg) {
    return {};
  } else if (Array.isArray(arg) || "name" in arg) {
    return {
      callbacks: arg
    };
  } else {
    return arg;
  }
}
/**
 * Manage callbacks from different components of LangChain.
 */
var BaseCallbackManager = /*#__PURE__*/function () {
  function BaseCallbackManager() {
    _classCallCheck(this, BaseCallbackManager);
  }
  return _createClass(BaseCallbackManager, [{
    key: "setHandler",
    value: function setHandler(handler) {
      return this.setHandlers([handler]);
    }
  }]);
}();
/**
 * Base class for run manager in LangChain.
 */
var BaseRunManager = /*#__PURE__*/function () {
  function BaseRunManager(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
    _classCallCheck(this, BaseRunManager);
    Object.defineProperty(this, "runId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: runId
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: handlers
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableHandlers
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tags
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableTags
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: metadata
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableMetadata
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _parentRunId
    });
  }
  return _createClass(BaseRunManager, [{
    key: "parentRunId",
    get: function get() {
      return this._parentRunId;
    }
  }, {
    key: "handleText",
    value: function () {
      var _handleText = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(text) {
        var _this = this;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  var _handler$handleText, logFunction;
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        _context.next = 3;
                        return (_handler$handleText = handler.handleText) === null || _handler$handleText === void 0 ? void 0 : _handler$handleText.call(handler, text, _this.runId, _this._parentRunId, _this.tags);
                      case 3:
                        _context.next = 11;
                        break;
                      case 5:
                        _context.prev = 5;
                        _context.t0 = _context["catch"](0);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleText: ").concat(_context.t0));
                        if (!handler.raiseError) {
                          _context.next = 11;
                          break;
                        }
                        throw _context.t0;
                      case 11:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee, null, [[0, 5]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function handleText(_x) {
        return _handleText.apply(this, arguments);
      }
      return handleText;
    }()
  }, {
    key: "handleCustomEvent",
    value: function () {
      var _handleCustomEvent = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(eventName,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      data, _runId, _tags,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _metadata) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  var _handler$handleCustom, logFunction;
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.prev = 0;
                        _context3.next = 3;
                        return (_handler$handleCustom = handler.handleCustomEvent) === null || _handler$handleCustom === void 0 ? void 0 : _handler$handleCustom.call(handler, eventName, data, _this2.runId, _this2.tags, _this2.metadata);
                      case 3:
                        _context3.next = 11;
                        break;
                      case 5:
                        _context3.prev = 5;
                        _context3.t0 = _context3["catch"](0);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleCustomEvent: ").concat(_context3.t0));
                        if (!handler.raiseError) {
                          _context3.next = 11;
                          break;
                        }
                        throw _context3.t0;
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[0, 5]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function handleCustomEvent(_x2, _x3, _x4, _x5, _x6) {
        return _handleCustomEvent.apply(this, arguments);
      }
      return handleCustomEvent;
    }()
  }]);
}();
/**
 * Manages callbacks for retriever runs.
 */
var CallbackManagerForRetrieverRun = /*#__PURE__*/function (_BaseRunManager) {
  function CallbackManagerForRetrieverRun() {
    _classCallCheck(this, CallbackManagerForRetrieverRun);
    return _callSuper(this, CallbackManagerForRetrieverRun, arguments);
  }
  _inherits(CallbackManagerForRetrieverRun, _BaseRunManager);
  return _createClass(CallbackManagerForRetrieverRun, [{
    key: "getChild",
    value: function getChild(tag) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      var manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([tag], false);
      }
      return manager;
    }
  }, {
    key: "handleRetrieverEnd",
    value: function () {
      var _handleRetrieverEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(documents) {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                  var _handler$handleRetrie, logFunction;
                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                    while (1) switch (_context5.prev = _context5.next) {
                      case 0:
                        if (handler.ignoreRetriever) {
                          _context5.next = 12;
                          break;
                        }
                        _context5.prev = 1;
                        _context5.next = 4;
                        return (_handler$handleRetrie = handler.handleRetrieverEnd) === null || _handler$handleRetrie === void 0 ? void 0 : _handler$handleRetrie.call(handler, documents, _this3.runId, _this3._parentRunId, _this3.tags);
                      case 4:
                        _context5.next = 12;
                        break;
                      case 6:
                        _context5.prev = 6;
                        _context5.t0 = _context5["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleRetriever"));
                        if (!handler.raiseError) {
                          _context5.next = 12;
                          break;
                        }
                        throw _context5.t0;
                      case 12:
                      case "end":
                        return _context5.stop();
                    }
                  }, _callee5, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function handleRetrieverEnd(_x7) {
        return _handleRetrieverEnd.apply(this, arguments);
      }
      return handleRetrieverEnd;
    }()
  }, {
    key: "handleRetrieverError",
    value: function () {
      var _handleRetrieverError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(err) {
        var _this4 = this;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                  var _handler$handleRetrie2, logFunction;
                  return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                    while (1) switch (_context7.prev = _context7.next) {
                      case 0:
                        if (handler.ignoreRetriever) {
                          _context7.next = 12;
                          break;
                        }
                        _context7.prev = 1;
                        _context7.next = 4;
                        return (_handler$handleRetrie2 = handler.handleRetrieverError) === null || _handler$handleRetrie2 === void 0 ? void 0 : _handler$handleRetrie2.call(handler, err, _this4.runId, _this4._parentRunId, _this4.tags);
                      case 4:
                        _context7.next = 12;
                        break;
                      case 6:
                        _context7.prev = 6;
                        _context7.t0 = _context7["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleRetrieverError: ").concat(_context7.t0));
                        if (!handler.raiseError) {
                          _context7.next = 12;
                          break;
                        }
                        throw err;
                      case 12:
                      case "end":
                        return _context7.stop();
                    }
                  }, _callee7, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function handleRetrieverError(_x8) {
        return _handleRetrieverError.apply(this, arguments);
      }
      return handleRetrieverError;
    }()
  }]);
}(BaseRunManager);
var CallbackManagerForLLMRun = /*#__PURE__*/function (_BaseRunManager2) {
  function CallbackManagerForLLMRun() {
    _classCallCheck(this, CallbackManagerForLLMRun);
    return _callSuper(this, CallbackManagerForLLMRun, arguments);
  }
  _inherits(CallbackManagerForLLMRun, _BaseRunManager2);
  return _createClass(CallbackManagerForLLMRun, [{
    key: "handleLLMNewToken",
    value: function () {
      var _handleLLMNewToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(token, idx, _runId, _parentRunId, _tags, fields) {
        var _this5 = this;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                  var _handler$handleLLMNew, logFunction;
                  return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                    while (1) switch (_context9.prev = _context9.next) {
                      case 0:
                        if (handler.ignoreLLM) {
                          _context9.next = 12;
                          break;
                        }
                        _context9.prev = 1;
                        _context9.next = 4;
                        return (_handler$handleLLMNew = handler.handleLLMNewToken) === null || _handler$handleLLMNew === void 0 ? void 0 : _handler$handleLLMNew.call(handler, token, idx !== null && idx !== void 0 ? idx : {
                          prompt: 0,
                          completion: 0
                        }, _this5.runId, _this5._parentRunId, _this5.tags, fields);
                      case 4:
                        _context9.next = 12;
                        break;
                      case 6:
                        _context9.prev = 6;
                        _context9.t0 = _context9["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleLLMNewToken: ").concat(_context9.t0));
                        if (!handler.raiseError) {
                          _context9.next = 12;
                          break;
                        }
                        throw _context9.t0;
                      case 12:
                      case "end":
                        return _context9.stop();
                    }
                  }, _callee9, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function handleLLMNewToken(_x9, _x10, _x11, _x12, _x13, _x14) {
        return _handleLLMNewToken.apply(this, arguments);
      }
      return handleLLMNewToken;
    }()
  }, {
    key: "handleLLMError",
    value: function () {
      var _handleLLMError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(err) {
        var _this6 = this;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                  var _handler$handleLLMErr, logFunction;
                  return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                    while (1) switch (_context11.prev = _context11.next) {
                      case 0:
                        if (handler.ignoreLLM) {
                          _context11.next = 12;
                          break;
                        }
                        _context11.prev = 1;
                        _context11.next = 4;
                        return (_handler$handleLLMErr = handler.handleLLMError) === null || _handler$handleLLMErr === void 0 ? void 0 : _handler$handleLLMErr.call(handler, err, _this6.runId, _this6._parentRunId, _this6.tags);
                      case 4:
                        _context11.next = 12;
                        break;
                      case 6:
                        _context11.prev = 6;
                        _context11.t0 = _context11["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleLLMError: ").concat(_context11.t0));
                        if (!handler.raiseError) {
                          _context11.next = 12;
                          break;
                        }
                        throw _context11.t0;
                      case 12:
                      case "end":
                        return _context11.stop();
                    }
                  }, _callee11, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function handleLLMError(_x15) {
        return _handleLLMError.apply(this, arguments);
      }
      return handleLLMError;
    }()
  }, {
    key: "handleLLMEnd",
    value: function () {
      var _handleLLMEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(output) {
        var _this7 = this;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                  var _handler$handleLLMEnd, logFunction;
                  return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                    while (1) switch (_context13.prev = _context13.next) {
                      case 0:
                        if (handler.ignoreLLM) {
                          _context13.next = 12;
                          break;
                        }
                        _context13.prev = 1;
                        _context13.next = 4;
                        return (_handler$handleLLMEnd = handler.handleLLMEnd) === null || _handler$handleLLMEnd === void 0 ? void 0 : _handler$handleLLMEnd.call(handler, output, _this7.runId, _this7._parentRunId, _this7.tags);
                      case 4:
                        _context13.next = 12;
                        break;
                      case 6:
                        _context13.prev = 6;
                        _context13.t0 = _context13["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleLLMEnd: ").concat(_context13.t0));
                        if (!handler.raiseError) {
                          _context13.next = 12;
                          break;
                        }
                        throw _context13.t0;
                      case 12:
                      case "end":
                        return _context13.stop();
                    }
                  }, _callee13, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function handleLLMEnd(_x16) {
        return _handleLLMEnd.apply(this, arguments);
      }
      return handleLLMEnd;
    }()
  }]);
}(BaseRunManager);
var CallbackManagerForChainRun = /*#__PURE__*/function (_BaseRunManager3) {
  function CallbackManagerForChainRun() {
    _classCallCheck(this, CallbackManagerForChainRun);
    return _callSuper(this, CallbackManagerForChainRun, arguments);
  }
  _inherits(CallbackManagerForChainRun, _BaseRunManager3);
  return _createClass(CallbackManagerForChainRun, [{
    key: "getChild",
    value: function getChild(tag) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      var manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([tag], false);
      }
      return manager;
    }
  }, {
    key: "handleChainError",
    value: function () {
      var _handleChainError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(err, _runId, _parentRunId, _tags, kwargs) {
        var _this8 = this;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                  var _handler$handleChainE, logFunction;
                  return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                    while (1) switch (_context15.prev = _context15.next) {
                      case 0:
                        if (handler.ignoreChain) {
                          _context15.next = 12;
                          break;
                        }
                        _context15.prev = 1;
                        _context15.next = 4;
                        return (_handler$handleChainE = handler.handleChainError) === null || _handler$handleChainE === void 0 ? void 0 : _handler$handleChainE.call(handler, err, _this8.runId, _this8._parentRunId, _this8.tags, kwargs);
                      case 4:
                        _context15.next = 12;
                        break;
                      case 6:
                        _context15.prev = 6;
                        _context15.t0 = _context15["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleChainError: ").concat(_context15.t0));
                        if (!handler.raiseError) {
                          _context15.next = 12;
                          break;
                        }
                        throw _context15.t0;
                      case 12:
                      case "end":
                        return _context15.stop();
                    }
                  }, _callee15, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function handleChainError(_x17, _x18, _x19, _x20, _x21) {
        return _handleChainError.apply(this, arguments);
      }
      return handleChainError;
    }()
  }, {
    key: "handleChainEnd",
    value: function () {
      var _handleChainEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(output, _runId, _parentRunId, _tags, kwargs) {
        var _this9 = this;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
                  var _handler$handleChainE2, logFunction;
                  return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                    while (1) switch (_context17.prev = _context17.next) {
                      case 0:
                        if (handler.ignoreChain) {
                          _context17.next = 12;
                          break;
                        }
                        _context17.prev = 1;
                        _context17.next = 4;
                        return (_handler$handleChainE2 = handler.handleChainEnd) === null || _handler$handleChainE2 === void 0 ? void 0 : _handler$handleChainE2.call(handler, output, _this9.runId, _this9._parentRunId, _this9.tags, kwargs);
                      case 4:
                        _context17.next = 12;
                        break;
                      case 6:
                        _context17.prev = 6;
                        _context17.t0 = _context17["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleChainEnd: ").concat(_context17.t0));
                        if (!handler.raiseError) {
                          _context17.next = 12;
                          break;
                        }
                        throw _context17.t0;
                      case 12:
                      case "end":
                        return _context17.stop();
                    }
                  }, _callee17, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function handleChainEnd(_x22, _x23, _x24, _x25, _x26) {
        return _handleChainEnd.apply(this, arguments);
      }
      return handleChainEnd;
    }()
  }, {
    key: "handleAgentAction",
    value: function () {
      var _handleAgentAction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(action) {
        var _this10 = this;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
                  var _handler$handleAgentA, logFunction;
                  return _regeneratorRuntime().wrap(function _callee19$(_context19) {
                    while (1) switch (_context19.prev = _context19.next) {
                      case 0:
                        if (handler.ignoreAgent) {
                          _context19.next = 12;
                          break;
                        }
                        _context19.prev = 1;
                        _context19.next = 4;
                        return (_handler$handleAgentA = handler.handleAgentAction) === null || _handler$handleAgentA === void 0 ? void 0 : _handler$handleAgentA.call(handler, action, _this10.runId, _this10._parentRunId, _this10.tags);
                      case 4:
                        _context19.next = 12;
                        break;
                      case 6:
                        _context19.prev = 6;
                        _context19.t0 = _context19["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleAgentAction: ").concat(_context19.t0));
                        if (!handler.raiseError) {
                          _context19.next = 12;
                          break;
                        }
                        throw _context19.t0;
                      case 12:
                      case "end":
                        return _context19.stop();
                    }
                  }, _callee19, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function handleAgentAction(_x27) {
        return _handleAgentAction.apply(this, arguments);
      }
      return handleAgentAction;
    }()
  }, {
    key: "handleAgentEnd",
    value: function () {
      var _handleAgentEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(action) {
        var _this11 = this;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
                  var _handler$handleAgentE, logFunction;
                  return _regeneratorRuntime().wrap(function _callee21$(_context21) {
                    while (1) switch (_context21.prev = _context21.next) {
                      case 0:
                        if (handler.ignoreAgent) {
                          _context21.next = 12;
                          break;
                        }
                        _context21.prev = 1;
                        _context21.next = 4;
                        return (_handler$handleAgentE = handler.handleAgentEnd) === null || _handler$handleAgentE === void 0 ? void 0 : _handler$handleAgentE.call(handler, action, _this11.runId, _this11._parentRunId, _this11.tags);
                      case 4:
                        _context21.next = 12;
                        break;
                      case 6:
                        _context21.prev = 6;
                        _context21.t0 = _context21["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleAgentEnd: ").concat(_context21.t0));
                        if (!handler.raiseError) {
                          _context21.next = 12;
                          break;
                        }
                        throw _context21.t0;
                      case 12:
                      case "end":
                        return _context21.stop();
                    }
                  }, _callee21, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function handleAgentEnd(_x28) {
        return _handleAgentEnd.apply(this, arguments);
      }
      return handleAgentEnd;
    }()
  }]);
}(BaseRunManager);
var CallbackManagerForToolRun = /*#__PURE__*/function (_BaseRunManager4) {
  function CallbackManagerForToolRun() {
    _classCallCheck(this, CallbackManagerForToolRun);
    return _callSuper(this, CallbackManagerForToolRun, arguments);
  }
  _inherits(CallbackManagerForToolRun, _BaseRunManager4);
  return _createClass(CallbackManagerForToolRun, [{
    key: "getChild",
    value: function getChild(tag) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      var manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([tag], false);
      }
      return manager;
    }
  }, {
    key: "handleToolError",
    value: function () {
      var _handleToolError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(err) {
        var _this12 = this;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
                  var _handler$handleToolEr, logFunction;
                  return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                    while (1) switch (_context23.prev = _context23.next) {
                      case 0:
                        if (handler.ignoreAgent) {
                          _context23.next = 12;
                          break;
                        }
                        _context23.prev = 1;
                        _context23.next = 4;
                        return (_handler$handleToolEr = handler.handleToolError) === null || _handler$handleToolEr === void 0 ? void 0 : _handler$handleToolEr.call(handler, err, _this12.runId, _this12._parentRunId, _this12.tags);
                      case 4:
                        _context23.next = 12;
                        break;
                      case 6:
                        _context23.prev = 6;
                        _context23.t0 = _context23["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleToolError: ").concat(_context23.t0));
                        if (!handler.raiseError) {
                          _context23.next = 12;
                          break;
                        }
                        throw _context23.t0;
                      case 12:
                      case "end":
                        return _context23.stop();
                    }
                  }, _callee23, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function handleToolError(_x29) {
        return _handleToolError.apply(this, arguments);
      }
      return handleToolError;
    }() // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "handleToolEnd",
    value: function () {
      var _handleToolEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(output) {
        var _this13 = this;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
                  var _handler$handleToolEn, logFunction;
                  return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                    while (1) switch (_context25.prev = _context25.next) {
                      case 0:
                        if (handler.ignoreAgent) {
                          _context25.next = 12;
                          break;
                        }
                        _context25.prev = 1;
                        _context25.next = 4;
                        return (_handler$handleToolEn = handler.handleToolEnd) === null || _handler$handleToolEn === void 0 ? void 0 : _handler$handleToolEn.call(handler, output, _this13.runId, _this13._parentRunId, _this13.tags);
                      case 4:
                        _context25.next = 12;
                        break;
                      case 6:
                        _context25.prev = 6;
                        _context25.t0 = _context25["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleToolEnd: ").concat(_context25.t0));
                        if (!handler.raiseError) {
                          _context25.next = 12;
                          break;
                        }
                        throw _context25.t0;
                      case 12:
                      case "end":
                        return _context25.stop();
                    }
                  }, _callee25, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function handleToolEnd(_x30) {
        return _handleToolEnd.apply(this, arguments);
      }
      return handleToolEnd;
    }()
  }]);
}(BaseRunManager);
/**
 * @example
 * ```typescript
 * const prompt = PromptTemplate.fromTemplate("What is the answer to {question}?");
 *
 * // Example of using LLMChain with OpenAI and a simple prompt
 * const chain = new LLMChain({
 *   llm: new ChatOpenAI({ temperature: 0.9 }),
 *   prompt,
 * });
 *
 * // Running the chain with a single question
 * const result = await chain.call({
 *   question: "What is the airspeed velocity of an unladen swallow?",
 * });
 * console.log("The answer is:", result);
 * ```
 */
var CallbackManager = /*#__PURE__*/function (_BaseCallbackManager) {
  function CallbackManager(parentRunId, options) {
    var _options$handlers, _options$inheritableH, _options$tags, _options$inheritableT, _options$metadata, _options$inheritableM;
    var _this14;
    _classCallCheck(this, CallbackManager);
    _this14 = _callSuper(this, CallbackManager);
    Object.defineProperty(_this14, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this14, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this14, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this14, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this14, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(_this14, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(_this14, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "callback_manager"
    });
    Object.defineProperty(_this14, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this14.handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : _this14.handlers;
    _this14.inheritableHandlers = (_options$inheritableH = options === null || options === void 0 ? void 0 : options.inheritableHandlers) !== null && _options$inheritableH !== void 0 ? _options$inheritableH : _this14.inheritableHandlers;
    _this14.tags = (_options$tags = options === null || options === void 0 ? void 0 : options.tags) !== null && _options$tags !== void 0 ? _options$tags : _this14.tags;
    _this14.inheritableTags = (_options$inheritableT = options === null || options === void 0 ? void 0 : options.inheritableTags) !== null && _options$inheritableT !== void 0 ? _options$inheritableT : _this14.inheritableTags;
    _this14.metadata = (_options$metadata = options === null || options === void 0 ? void 0 : options.metadata) !== null && _options$metadata !== void 0 ? _options$metadata : _this14.metadata;
    _this14.inheritableMetadata = (_options$inheritableM = options === null || options === void 0 ? void 0 : options.inheritableMetadata) !== null && _options$inheritableM !== void 0 ? _options$inheritableM : _this14.inheritableMetadata;
    _this14._parentRunId = parentRunId;
    return _this14;
  }
  /**
   * Gets the parent run ID, if any.
   *
   * @returns The parent run ID.
   */
  _inherits(CallbackManager, _BaseCallbackManager);
  return _createClass(CallbackManager, [{
    key: "getParentRunId",
    value: function getParentRunId() {
      return this._parentRunId;
    }
  }, {
    key: "handleLLMStart",
    value: function () {
      var _handleLLMStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(llm, prompts) {
        var _this15 = this;
        var runId,
          _parentRunId,
          extraParams,
          _tags,
          _metadata,
          runName,
          _args29 = arguments;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              runId = _args29.length > 2 && _args29[2] !== undefined ? _args29[2] : undefined;
              _parentRunId = _args29.length > 3 && _args29[3] !== undefined ? _args29[3] : undefined;
              extraParams = _args29.length > 4 && _args29[4] !== undefined ? _args29[4] : undefined;
              _tags = _args29.length > 5 && _args29[5] !== undefined ? _args29[5] : undefined;
              _metadata = _args29.length > 6 && _args29[6] !== undefined ? _args29[6] : undefined;
              runName = _args29.length > 7 && _args29[7] !== undefined ? _args29[7] : undefined;
              return _context29.abrupt("return", Promise.all(prompts.map(/*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(prompt, idx) {
                  var runId_;
                  return _regeneratorRuntime().wrap(function _callee28$(_context28) {
                    while (1) switch (_context28.prev = _context28.next) {
                      case 0:
                        // Can't have duplicate runs with the same run ID (if provided)
                        runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
                        _context28.next = 3;
                        return Promise.all(_this15.handlers.map(function (handler) {
                          if (handler.ignoreLLM) {
                            return;
                          }
                          if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {
                            // Create and add run to the run map.
                            // We do this synchronously to avoid race conditions
                            // when callbacks are backgrounded.
                            handler._createRunForLLMStart(llm, [prompt], runId_, _this15._parentRunId, extraParams, _this15.tags, _this15.metadata, runName);
                          }
                          return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
                            var _handler$handleLLMSta, logFunction;
                            return _regeneratorRuntime().wrap(function _callee27$(_context27) {
                              while (1) switch (_context27.prev = _context27.next) {
                                case 0:
                                  _context27.prev = 0;
                                  _context27.next = 3;
                                  return (_handler$handleLLMSta = handler.handleLLMStart) === null || _handler$handleLLMSta === void 0 ? void 0 : _handler$handleLLMSta.call(handler, llm, [prompt], runId_, _this15._parentRunId, extraParams, _this15.tags, _this15.metadata, runName);
                                case 3:
                                  _context27.next = 11;
                                  break;
                                case 5:
                                  _context27.prev = 5;
                                  _context27.t0 = _context27["catch"](0);
                                  logFunction = handler.raiseError ? console.error : console.warn;
                                  logFunction("Error in handler ".concat(handler.constructor.name, ", handleLLMStart: ").concat(_context27.t0));
                                  if (!handler.raiseError) {
                                    _context27.next = 11;
                                    break;
                                  }
                                  throw _context27.t0;
                                case 11:
                                case "end":
                                  return _context27.stop();
                              }
                            }, _callee27, null, [[0, 5]]);
                          })), handler.awaitHandlers);
                        }));
                      case 3:
                        return _context28.abrupt("return", new CallbackManagerForLLMRun(runId_, _this15.handlers, _this15.inheritableHandlers, _this15.tags, _this15.inheritableTags, _this15.metadata, _this15.inheritableMetadata, _this15._parentRunId));
                      case 4:
                      case "end":
                        return _context28.stop();
                    }
                  }, _callee28);
                }));
                return function (_x33, _x34) {
                  return _ref14.apply(this, arguments);
                };
              }())));
            case 7:
            case "end":
              return _context29.stop();
          }
        }, _callee29);
      }));
      function handleLLMStart(_x31, _x32) {
        return _handleLLMStart.apply(this, arguments);
      }
      return handleLLMStart;
    }()
  }, {
    key: "handleChatModelStart",
    value: function () {
      var _handleChatModelStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(llm, messages) {
        var _this16 = this;
        var runId,
          _parentRunId,
          extraParams,
          _tags,
          _metadata,
          runName,
          _args32 = arguments;
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              runId = _args32.length > 2 && _args32[2] !== undefined ? _args32[2] : undefined;
              _parentRunId = _args32.length > 3 && _args32[3] !== undefined ? _args32[3] : undefined;
              extraParams = _args32.length > 4 && _args32[4] !== undefined ? _args32[4] : undefined;
              _tags = _args32.length > 5 && _args32[5] !== undefined ? _args32[5] : undefined;
              _metadata = _args32.length > 6 && _args32[6] !== undefined ? _args32[6] : undefined;
              runName = _args32.length > 7 && _args32[7] !== undefined ? _args32[7] : undefined;
              return _context32.abrupt("return", Promise.all(messages.map(/*#__PURE__*/function () {
                var _ref16 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(messageGroup, idx) {
                  var runId_;
                  return _regeneratorRuntime().wrap(function _callee31$(_context31) {
                    while (1) switch (_context31.prev = _context31.next) {
                      case 0:
                        // Can't have duplicate runs with the same run ID (if provided)
                        runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
                        _context31.next = 3;
                        return Promise.all(_this16.handlers.map(function (handler) {
                          if (handler.ignoreLLM) {
                            return;
                          }
                          if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {
                            // Create and add run to the run map.
                            // We do this synchronously to avoid race conditions
                            // when callbacks are backgrounded.
                            handler._createRunForChatModelStart(llm, [messageGroup], runId_, _this16._parentRunId, extraParams, _this16.tags, _this16.metadata, runName);
                          }
                          return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
                            var _handler$handleChatMo, _handler$handleLLMSta2, messageString, logFunction;
                            return _regeneratorRuntime().wrap(function _callee30$(_context30) {
                              while (1) switch (_context30.prev = _context30.next) {
                                case 0:
                                  _context30.prev = 0;
                                  if (!handler.handleChatModelStart) {
                                    _context30.next = 6;
                                    break;
                                  }
                                  _context30.next = 4;
                                  return (_handler$handleChatMo = handler.handleChatModelStart) === null || _handler$handleChatMo === void 0 ? void 0 : _handler$handleChatMo.call(handler, llm, [messageGroup], runId_, _this16._parentRunId, extraParams, _this16.tags, _this16.metadata, runName);
                                case 4:
                                  _context30.next = 10;
                                  break;
                                case 6:
                                  if (!handler.handleLLMStart) {
                                    _context30.next = 10;
                                    break;
                                  }
                                  messageString = (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_2__.getBufferString)(messageGroup);
                                  _context30.next = 10;
                                  return (_handler$handleLLMSta2 = handler.handleLLMStart) === null || _handler$handleLLMSta2 === void 0 ? void 0 : _handler$handleLLMSta2.call(handler, llm, [messageString], runId_, _this16._parentRunId, extraParams, _this16.tags, _this16.metadata, runName);
                                case 10:
                                  _context30.next = 18;
                                  break;
                                case 12:
                                  _context30.prev = 12;
                                  _context30.t0 = _context30["catch"](0);
                                  logFunction = handler.raiseError ? console.error : console.warn;
                                  logFunction("Error in handler ".concat(handler.constructor.name, ", handleLLMStart: ").concat(_context30.t0));
                                  if (!handler.raiseError) {
                                    _context30.next = 18;
                                    break;
                                  }
                                  throw _context30.t0;
                                case 18:
                                case "end":
                                  return _context30.stop();
                              }
                            }, _callee30, null, [[0, 12]]);
                          })), handler.awaitHandlers);
                        }));
                      case 3:
                        return _context31.abrupt("return", new CallbackManagerForLLMRun(runId_, _this16.handlers, _this16.inheritableHandlers, _this16.tags, _this16.inheritableTags, _this16.metadata, _this16.inheritableMetadata, _this16._parentRunId));
                      case 4:
                      case "end":
                        return _context31.stop();
                    }
                  }, _callee31);
                }));
                return function (_x37, _x38) {
                  return _ref16.apply(this, arguments);
                };
              }())));
            case 7:
            case "end":
              return _context32.stop();
          }
        }, _callee32);
      }));
      function handleChatModelStart(_x35, _x36) {
        return _handleChatModelStart.apply(this, arguments);
      }
      return handleChatModelStart;
    }()
  }, {
    key: "handleChainStart",
    value: function () {
      var _handleChainStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(chain, inputs) {
        var _this17 = this;
        var runId,
          runType,
          _tags,
          _metadata,
          runName,
          _args34 = arguments;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              runId = _args34.length > 2 && _args34[2] !== undefined ? _args34[2] : (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
              runType = _args34.length > 3 && _args34[3] !== undefined ? _args34[3] : undefined;
              _tags = _args34.length > 4 && _args34[4] !== undefined ? _args34[4] : undefined;
              _metadata = _args34.length > 5 && _args34[5] !== undefined ? _args34[5] : undefined;
              runName = _args34.length > 6 && _args34[6] !== undefined ? _args34[6] : undefined;
              _context34.next = 7;
              return Promise.all(this.handlers.map(function (handler) {
                if (handler.ignoreChain) {
                  return;
                }
                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {
                  // Create and add run to the run map.
                  // We do this synchronously to avoid race conditions
                  // when callbacks are backgrounded.
                  handler._createRunForChainStart(chain, inputs, runId, _this17._parentRunId, _this17.tags, _this17.metadata, runType, runName);
                }
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
                  var _handler$handleChainS, logFunction;
                  return _regeneratorRuntime().wrap(function _callee33$(_context33) {
                    while (1) switch (_context33.prev = _context33.next) {
                      case 0:
                        _context33.prev = 0;
                        _context33.next = 3;
                        return (_handler$handleChainS = handler.handleChainStart) === null || _handler$handleChainS === void 0 ? void 0 : _handler$handleChainS.call(handler, chain, inputs, runId, _this17._parentRunId, _this17.tags, _this17.metadata, runType, runName);
                      case 3:
                        _context33.next = 11;
                        break;
                      case 5:
                        _context33.prev = 5;
                        _context33.t0 = _context33["catch"](0);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleChainStart: ").concat(_context33.t0));
                        if (!handler.raiseError) {
                          _context33.next = 11;
                          break;
                        }
                        throw _context33.t0;
                      case 11:
                      case "end":
                        return _context33.stop();
                    }
                  }, _callee33, null, [[0, 5]]);
                })), handler.awaitHandlers);
              }));
            case 7:
              return _context34.abrupt("return", new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId));
            case 8:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
      function handleChainStart(_x39, _x40) {
        return _handleChainStart.apply(this, arguments);
      }
      return handleChainStart;
    }()
  }, {
    key: "handleToolStart",
    value: function () {
      var _handleToolStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(tool, input) {
        var _this18 = this;
        var runId,
          _parentRunId,
          _tags,
          _metadata,
          runName,
          _args36 = arguments;
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              runId = _args36.length > 2 && _args36[2] !== undefined ? _args36[2] : (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
              _parentRunId = _args36.length > 3 && _args36[3] !== undefined ? _args36[3] : undefined;
              _tags = _args36.length > 4 && _args36[4] !== undefined ? _args36[4] : undefined;
              _metadata = _args36.length > 5 && _args36[5] !== undefined ? _args36[5] : undefined;
              runName = _args36.length > 6 && _args36[6] !== undefined ? _args36[6] : undefined;
              _context36.next = 7;
              return Promise.all(this.handlers.map(function (handler) {
                if (handler.ignoreAgent) {
                  return;
                }
                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {
                  // Create and add run to the run map.
                  // We do this synchronously to avoid race conditions
                  // when callbacks are backgrounded.
                  handler._createRunForToolStart(tool, input, runId, _this18._parentRunId, _this18.tags, _this18.metadata, runName);
                }
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
                  var _handler$handleToolSt, logFunction;
                  return _regeneratorRuntime().wrap(function _callee35$(_context35) {
                    while (1) switch (_context35.prev = _context35.next) {
                      case 0:
                        _context35.prev = 0;
                        _context35.next = 3;
                        return (_handler$handleToolSt = handler.handleToolStart) === null || _handler$handleToolSt === void 0 ? void 0 : _handler$handleToolSt.call(handler, tool, input, runId, _this18._parentRunId, _this18.tags, _this18.metadata, runName);
                      case 3:
                        _context35.next = 11;
                        break;
                      case 5:
                        _context35.prev = 5;
                        _context35.t0 = _context35["catch"](0);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleToolStart: ").concat(_context35.t0));
                        if (!handler.raiseError) {
                          _context35.next = 11;
                          break;
                        }
                        throw _context35.t0;
                      case 11:
                      case "end":
                        return _context35.stop();
                    }
                  }, _callee35, null, [[0, 5]]);
                })), handler.awaitHandlers);
              }));
            case 7:
              return _context36.abrupt("return", new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId));
            case 8:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
      function handleToolStart(_x41, _x42) {
        return _handleToolStart.apply(this, arguments);
      }
      return handleToolStart;
    }()
  }, {
    key: "handleRetrieverStart",
    value: function () {
      var _handleRetrieverStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(retriever, query) {
        var _this19 = this;
        var runId,
          _parentRunId,
          _tags,
          _metadata,
          runName,
          _args38 = arguments;
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              runId = _args38.length > 2 && _args38[2] !== undefined ? _args38[2] : (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
              _parentRunId = _args38.length > 3 && _args38[3] !== undefined ? _args38[3] : undefined;
              _tags = _args38.length > 4 && _args38[4] !== undefined ? _args38[4] : undefined;
              _metadata = _args38.length > 5 && _args38[5] !== undefined ? _args38[5] : undefined;
              runName = _args38.length > 6 && _args38[6] !== undefined ? _args38[6] : undefined;
              _context38.next = 7;
              return Promise.all(this.handlers.map(function (handler) {
                if (handler.ignoreRetriever) {
                  return;
                }
                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {
                  // Create and add run to the run map.
                  // We do this synchronously to avoid race conditions
                  // when callbacks are backgrounded.
                  handler._createRunForRetrieverStart(retriever, query, runId, _this19._parentRunId, _this19.tags, _this19.metadata, runName);
                }
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
                  var _handler$handleRetrie3, logFunction;
                  return _regeneratorRuntime().wrap(function _callee37$(_context37) {
                    while (1) switch (_context37.prev = _context37.next) {
                      case 0:
                        _context37.prev = 0;
                        _context37.next = 3;
                        return (_handler$handleRetrie3 = handler.handleRetrieverStart) === null || _handler$handleRetrie3 === void 0 ? void 0 : _handler$handleRetrie3.call(handler, retriever, query, runId, _this19._parentRunId, _this19.tags, _this19.metadata, runName);
                      case 3:
                        _context37.next = 11;
                        break;
                      case 5:
                        _context37.prev = 5;
                        _context37.t0 = _context37["catch"](0);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleRetrieverStart: ").concat(_context37.t0));
                        if (!handler.raiseError) {
                          _context37.next = 11;
                          break;
                        }
                        throw _context37.t0;
                      case 11:
                      case "end":
                        return _context37.stop();
                    }
                  }, _callee37, null, [[0, 5]]);
                })), handler.awaitHandlers);
              }));
            case 7:
              return _context38.abrupt("return", new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId));
            case 8:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this);
      }));
      function handleRetrieverStart(_x43, _x44) {
        return _handleRetrieverStart.apply(this, arguments);
      }
      return handleRetrieverStart;
    }()
  }, {
    key: "handleCustomEvent",
    value: function () {
      var _handleCustomEvent2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40(eventName,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      data, runId, _tags,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _metadata) {
        var _this20 = this;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              _context40.next = 2;
              return Promise.all(this.handlers.map(function (handler) {
                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
                  var _handler$handleCustom2, logFunction;
                  return _regeneratorRuntime().wrap(function _callee39$(_context39) {
                    while (1) switch (_context39.prev = _context39.next) {
                      case 0:
                        if (handler.ignoreCustomEvent) {
                          _context39.next = 12;
                          break;
                        }
                        _context39.prev = 1;
                        _context39.next = 4;
                        return (_handler$handleCustom2 = handler.handleCustomEvent) === null || _handler$handleCustom2 === void 0 ? void 0 : _handler$handleCustom2.call(handler, eventName, data, runId, _this20.tags, _this20.metadata);
                      case 4:
                        _context39.next = 12;
                        break;
                      case 6:
                        _context39.prev = 6;
                        _context39.t0 = _context39["catch"](1);
                        logFunction = handler.raiseError ? console.error : console.warn;
                        logFunction("Error in handler ".concat(handler.constructor.name, ", handleCustomEvent: ").concat(_context39.t0));
                        if (!handler.raiseError) {
                          _context39.next = 12;
                          break;
                        }
                        throw _context39.t0;
                      case 12:
                      case "end":
                        return _context39.stop();
                    }
                  }, _callee39, null, [[1, 6]]);
                })), handler.awaitHandlers);
              }));
            case 2:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this);
      }));
      function handleCustomEvent(_x45, _x46, _x47, _x48, _x49) {
        return _handleCustomEvent2.apply(this, arguments);
      }
      return handleCustomEvent;
    }()
  }, {
    key: "addHandler",
    value: function addHandler(handler) {
      var inherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.handlers.push(handler);
      if (inherit) {
        this.inheritableHandlers.push(handler);
      }
    }
  }, {
    key: "removeHandler",
    value: function removeHandler(handler) {
      this.handlers = this.handlers.filter(function (_handler) {
        return _handler !== handler;
      });
      this.inheritableHandlers = this.inheritableHandlers.filter(function (_handler) {
        return _handler !== handler;
      });
    }
  }, {
    key: "setHandlers",
    value: function setHandlers(handlers) {
      var inherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.handlers = [];
      this.inheritableHandlers = [];
      var _iterator = _createForOfIteratorHelper(handlers),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var handler = _step.value;
          this.addHandler(handler, inherit);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "addTags",
    value: function addTags(tags) {
      var _this$tags;
      var inherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.removeTags(tags); // Remove duplicates
      (_this$tags = this.tags).push.apply(_this$tags, _toConsumableArray(tags));
      if (inherit) {
        var _this$inheritableTags;
        (_this$inheritableTags = this.inheritableTags).push.apply(_this$inheritableTags, _toConsumableArray(tags));
      }
    }
  }, {
    key: "removeTags",
    value: function removeTags(tags) {
      this.tags = this.tags.filter(function (tag) {
        return !tags.includes(tag);
      });
      this.inheritableTags = this.inheritableTags.filter(function (tag) {
        return !tags.includes(tag);
      });
    }
  }, {
    key: "addMetadata",
    value: function addMetadata(metadata) {
      var inherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.metadata = _objectSpread(_objectSpread({}, this.metadata), metadata);
      if (inherit) {
        this.inheritableMetadata = _objectSpread(_objectSpread({}, this.inheritableMetadata), metadata);
      }
    }
  }, {
    key: "removeMetadata",
    value: function removeMetadata(metadata) {
      for (var _i = 0, _Object$keys = Object.keys(metadata); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        delete this.metadata[key];
        delete this.inheritableMetadata[key];
      }
    }
  }, {
    key: "copy",
    value: function copy() {
      var additionalHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var inherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var manager = new CallbackManager(this._parentRunId);
      var _iterator2 = _createForOfIteratorHelper(this.handlers),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var handler = _step2.value;
          var _inheritable = this.inheritableHandlers.includes(handler);
          manager.addHandler(handler, _inheritable);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(this.tags),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tag = _step3.value;
          var _inheritable2 = this.inheritableTags.includes(tag);
          manager.addTags([tag], _inheritable2);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      for (var _i2 = 0, _Object$keys2 = Object.keys(this.metadata); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];
        var inheritable = Object.keys(this.inheritableMetadata).includes(key);
        manager.addMetadata(_defineProperty({}, key, this.metadata[key]), inheritable);
      }
      var _iterator4 = _createForOfIteratorHelper(additionalHandlers),
        _step4;
      try {
        var _loop = function _loop() {
          var handler = _step4.value;
          if (
          // Prevent multiple copies of console_callback_handler
          manager.handlers.filter(function (h) {
            return h.name === "console_callback_handler";
          }).some(function (h) {
            return h.name === handler.name;
          })) {
            return 1; // continue
          }
          manager.addHandler(handler, inherit);
        };
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          if (_loop()) continue;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return manager;
    }
  }], [{
    key: "fromHandlers",
    value: function fromHandlers(handlers) {
      var Handler = /*#__PURE__*/function (_BaseCallbackHandler) {
        function Handler() {
          var _this21;
          _classCallCheck(this, Handler);
          _this21 = _callSuper(this, Handler);
          Object.defineProperty(_this21, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])()
          });
          Object.assign(_this21, handlers);
          return _this21;
        }
        _inherits(Handler, _BaseCallbackHandler);
        return _createClass(Handler);
      }(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler);
      var manager = new this();
      manager.addHandler(new Handler());
      return manager;
    }
  }, {
    key: "configure",
    value: function configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
      return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
    }
    // TODO: Deprecate async method in favor of this one.
  }, {
    key: "_configureSync",
    value: function _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
      var _LangChainTracer$getT, _getEnvironmentVariab;
      var callbackManager;
      if (inheritableHandlers || localHandlers) {
        if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
          var _inheritableHandlers$;
          callbackManager = new CallbackManager();
          callbackManager.setHandlers((_inheritableHandlers$ = inheritableHandlers === null || inheritableHandlers === void 0 ? void 0 : inheritableHandlers.map(ensureHandler)) !== null && _inheritableHandlers$ !== void 0 ? _inheritableHandlers$ : [], true);
        } else {
          callbackManager = inheritableHandlers;
        }
        callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers === null || localHandlers === void 0 ? void 0 : localHandlers.handlers, false);
      }
      var verboseEnabled = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)("LANGCHAIN_VERBOSE") === "true" || (options === null || options === void 0 ? void 0 : options.verbose);
      var tracingV2Enabled = ((_LangChainTracer$getT = _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer.getTraceableRunTree()) === null || _LangChainTracer$getT === void 0 ? void 0 : _LangChainTracer$getT.tracingEnabled) || (0,_utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__.isTracingEnabled)();
      var tracingEnabled = tracingV2Enabled || ((_getEnvironmentVariab = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)("LANGCHAIN_TRACING")) !== null && _getEnvironmentVariab !== void 0 ? _getEnvironmentVariab : false);
      if (verboseEnabled || tracingEnabled) {
        if (!callbackManager) {
          callbackManager = new CallbackManager();
        }
        if (verboseEnabled && !callbackManager.handlers.some(function (handler) {
          return handler.name === _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler.prototype.name;
        })) {
          var consoleHandler = new _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler();
          callbackManager.addHandler(consoleHandler, true);
        }
        if (tracingEnabled && !callbackManager.handlers.some(function (handler) {
          return handler.name === "langchain_tracer";
        })) {
          if (tracingV2Enabled) {
            var _LangChainTracer$getT2, _LangChainTracer$getT3;
            var tracerV2 = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer();
            callbackManager.addHandler(tracerV2, true);
            // handoff between langchain and langsmith/traceable
            // override the parent run ID
            callbackManager._parentRunId = (_LangChainTracer$getT2 = (_LangChainTracer$getT3 = _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer.getTraceableRunTree()) === null || _LangChainTracer$getT3 === void 0 ? void 0 : _LangChainTracer$getT3.id) !== null && _LangChainTracer$getT2 !== void 0 ? _LangChainTracer$getT2 : callbackManager._parentRunId;
          }
        }
      }
      if (inheritableTags || localTags) {
        if (callbackManager) {
          callbackManager.addTags(inheritableTags !== null && inheritableTags !== void 0 ? inheritableTags : []);
          callbackManager.addTags(localTags !== null && localTags !== void 0 ? localTags : [], false);
        }
      }
      if (inheritableMetadata || localMetadata) {
        if (callbackManager) {
          callbackManager.addMetadata(inheritableMetadata !== null && inheritableMetadata !== void 0 ? inheritableMetadata : {});
          callbackManager.addMetadata(localMetadata !== null && localMetadata !== void 0 ? localMetadata : {}, false);
        }
      }
      return callbackManager;
    }
  }]);
}(BaseCallbackManager);
function ensureHandler(handler) {
  if ("name" in handler) {
    return handler;
  }
  return _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler.fromMethods(handler);
}
/**
 * @deprecated Use [`traceable`](https://docs.smith.langchain.com/observability/how_to_guides/tracing/annotate_code)
 * from "langsmith" instead.
 */
var TraceGroup = /*#__PURE__*/function () {
  function TraceGroup(groupName, options) {
    _classCallCheck(this, TraceGroup);
    Object.defineProperty(this, "groupName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: groupName
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: options
    });
    Object.defineProperty(this, "runManager", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  return _createClass(TraceGroup, [{
    key: "getTraceGroupCallbackManager",
    value: function () {
      var _getTraceGroupCallbackManager = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41(group_name, inputs, options) {
        var cb, cm, runManager;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              cb = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer(options);
              _context41.next = 3;
              return CallbackManager.configure([cb]);
            case 3:
              cm = _context41.sent;
              _context41.next = 6;
              return cm === null || cm === void 0 ? void 0 : cm.handleChainStart({
                lc: 1,
                type: "not_implemented",
                id: ["langchain", "callbacks", "groups", group_name]
              }, inputs !== null && inputs !== void 0 ? inputs : {});
            case 6:
              runManager = _context41.sent;
              if (runManager) {
                _context41.next = 9;
                break;
              }
              throw new Error("Failed to create run group callback manager.");
            case 9:
              return _context41.abrupt("return", runManager);
            case 10:
            case "end":
              return _context41.stop();
          }
        }, _callee41);
      }));
      function getTraceGroupCallbackManager(_x50, _x51, _x52) {
        return _getTraceGroupCallbackManager.apply(this, arguments);
      }
      return getTraceGroupCallbackManager;
    }()
  }, {
    key: "start",
    value: function () {
      var _start = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42(inputs) {
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              if (this.runManager) {
                _context42.next = 4;
                break;
              }
              _context42.next = 3;
              return this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);
            case 3:
              this.runManager = _context42.sent;
            case 4:
              return _context42.abrupt("return", this.runManager.getChild());
            case 5:
            case "end":
              return _context42.stop();
          }
        }, _callee42, this);
      }));
      function start(_x53) {
        return _start.apply(this, arguments);
      }
      return start;
    }()
  }, {
    key: "error",
    value: function () {
      var _error = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43(err) {
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              if (!this.runManager) {
                _context43.next = 4;
                break;
              }
              _context43.next = 3;
              return this.runManager.handleChainError(err);
            case 3:
              this.runManager = undefined;
            case 4:
            case "end":
              return _context43.stop();
          }
        }, _callee43, this);
      }));
      function error(_x54) {
        return _error.apply(this, arguments);
      }
      return error;
    }()
  }, {
    key: "end",
    value: function () {
      var _end = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(output) {
        return _regeneratorRuntime().wrap(function _callee44$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              if (!this.runManager) {
                _context44.next = 4;
                break;
              }
              _context44.next = 3;
              return this.runManager.handleChainEnd(output !== null && output !== void 0 ? output : {});
            case 3:
              this.runManager = undefined;
            case 4:
            case "end":
              return _context44.stop();
          }
        }, _callee44, this);
      }));
      function end(_x55) {
        return _end.apply(this, arguments);
      }
      return end;
    }()
  }]);
}();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && _typeof(value) === "object" ? value : _defineProperty({}, defaultKey, value);
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function traceAsGroup(_x56, _x57) {
  return _traceAsGroup.apply(this, arguments);
}
function _traceAsGroup() {
  _traceAsGroup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(groupOptions, enclosedCode) {
    var traceGroup,
      _len,
      args,
      _key,
      callbackManager,
      result,
      _args45 = arguments;
    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
      while (1) switch (_context45.prev = _context45.next) {
        case 0:
          traceGroup = new TraceGroup(groupOptions.name, groupOptions);
          for (_len = _args45.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = _args45[_key];
          }
          _context45.next = 4;
          return traceGroup.start(_objectSpread({}, args));
        case 4:
          callbackManager = _context45.sent;
          _context45.prev = 5;
          _context45.next = 8;
          return enclosedCode.apply(void 0, [callbackManager].concat(args));
        case 8:
          result = _context45.sent;
          _context45.next = 11;
          return traceGroup.end(_coerceToDict(result, "output"));
        case 11:
          return _context45.abrupt("return", result);
        case 14:
          _context45.prev = 14;
          _context45.t0 = _context45["catch"](5);
          _context45.next = 18;
          return traceGroup.error(_context45.t0);
        case 18:
          throw _context45.t0;
        case 19:
        case "end":
          return _context45.stop();
      }
    }, _callee45, null, [[5, 14]]);
  }));
  return _traceAsGroup.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/callbacks/promises.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/promises.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   awaitAllCallbacks: () => (/* reexport safe */ _singletons_callbacks_js__WEBPACK_IMPORTED_MODULE_0__.awaitAllCallbacks),
/* harmony export */   consumeCallback: () => (/* reexport safe */ _singletons_callbacks_js__WEBPACK_IMPORTED_MODULE_0__.consumeCallback)
/* harmony export */ });
/* harmony import */ var _singletons_callbacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/callbacks.js */ "./node_modules/@langchain/core/dist/singletons/callbacks.js");



/***/ }),

/***/ "./node_modules/@langchain/core/dist/documents/document.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/document.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Document: () => (/* binding */ Document)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
/**
 * Interface for interacting with a document.
 */
var Document = /*#__PURE__*/_createClass(function Document(fields) {
  var _fields$metadata;
  _classCallCheck(this, Document);
  Object.defineProperty(this, "pageContent", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  Object.defineProperty(this, "metadata", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  // The ID field is optional at the moment.
  // It will likely become required in a future major release after
  // it has been adopted by enough vectorstore implementations.
  /**
   * An optional identifier for the document.
   *
   * Ideally this should be unique across the document collection and formatted
   * as a UUID, but this will not be enforced.
   */
  Object.defineProperty(this, "id", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  this.pageContent = fields.pageContent !== undefined ? fields.pageContent.toString() : "";
  this.metadata = (_fields$metadata = fields.metadata) !== null && _fields$metadata !== void 0 ? _fields$metadata : {};
  this.id = fields.id;
});

/***/ }),

/***/ "./node_modules/@langchain/core/dist/documents/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.BaseDocumentTransformer),
/* harmony export */   Document: () => (/* reexport safe */ _document_js__WEBPACK_IMPORTED_MODULE_0__.Document),
/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.MappingDocumentTransformer)
/* harmony export */ });
/* harmony import */ var _document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./document.js */ "./node_modules/@langchain/core/dist/documents/document.js");
/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transformers.js */ "./node_modules/@langchain/core/dist/documents/transformers.js");



/***/ }),

/***/ "./node_modules/@langchain/core/dist/documents/transformers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/transformers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseDocumentTransformer: () => (/* binding */ BaseDocumentTransformer),
/* harmony export */   MappingDocumentTransformer: () => (/* binding */ MappingDocumentTransformer)
/* harmony export */ });
/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ "./node_modules/@langchain/core/dist/runnables/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

/**
 * Abstract base class for document transformation systems.
 *
 * A document transformation system takes an array of Documents and returns an
 * array of transformed Documents. These arrays do not necessarily have to have
 * the same length.
 *
 * One example of this is a text splitter that splits a large document into
 * many smaller documents.
 */
var BaseDocumentTransformer = /*#__PURE__*/function (_Runnable) {
  function BaseDocumentTransformer() {
    var _this;
    _classCallCheck(this, BaseDocumentTransformer);
    _this = _callSuper(this, BaseDocumentTransformer, arguments);
    Object.defineProperty(_this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "documents", "transformers"]
    });
    return _this;
  }
  /**
   * Method to invoke the document transformation. This method calls the
   * transformDocuments method with the provided input.
   * @param input The input documents to be transformed.
   * @param _options Optional configuration object to customize the behavior of callbacks.
   * @returns A Promise that resolves to the transformed documents.
   */
  _inherits(BaseDocumentTransformer, _Runnable);
  return _createClass(BaseDocumentTransformer, [{
    key: "invoke",
    value: function invoke(input, _options) {
      return this.transformDocuments(input);
    }
  }]);
}(_runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable);
/**
 * Class for document transformers that return exactly one transformed document
 * for each input document.
 */
var MappingDocumentTransformer = /*#__PURE__*/function (_BaseDocumentTransfor) {
  function MappingDocumentTransformer() {
    _classCallCheck(this, MappingDocumentTransformer);
    return _callSuper(this, MappingDocumentTransformer, arguments);
  }
  _inherits(MappingDocumentTransformer, _BaseDocumentTransfor);
  return _createClass(MappingDocumentTransformer, [{
    key: "transformDocuments",
    value: function () {
      var _transformDocuments = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(documents) {
        var newDocuments, _iterator, _step, document, transformedDocument;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              newDocuments = [];
              _iterator = _createForOfIteratorHelper(documents);
              _context.prev = 2;
              _iterator.s();
            case 4:
              if ((_step = _iterator.n()).done) {
                _context.next = 12;
                break;
              }
              document = _step.value;
              _context.next = 8;
              return this._transformDocument(document);
            case 8:
              transformedDocument = _context.sent;
              newDocuments.push(transformedDocument);
            case 10:
              _context.next = 4;
              break;
            case 12:
              _context.next = 17;
              break;
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](2);
              _iterator.e(_context.t0);
            case 17:
              _context.prev = 17;
              _iterator.f();
              return _context.finish(17);
            case 20:
              return _context.abrupt("return", newDocuments);
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2, 14, 17, 20]]);
      }));
      function transformDocuments(_x) {
        return _transformDocuments.apply(this, arguments);
      }
      return transformDocuments;
    }()
  }]);
}(BaseDocumentTransformer);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/errors/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/errors/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addLangChainErrorFields: () => (/* binding */ addLangChainErrorFields)
/* harmony export */ });
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-param-reassign */
function addLangChainErrorFields(error, lc_error_code) {
  error.lc_error_code = lc_error_code;
  error.message = "".concat(error.message, "\n\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/").concat(lc_error_code, "/\n");
  return error;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/load/map_keys.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/map_keys.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keyFromJson: () => (/* binding */ keyFromJson),
/* harmony export */   keyToJson: () => (/* binding */ keyToJson),
/* harmony export */   mapKeys: () => (/* binding */ mapKeys)
/* harmony export */ });
/* harmony import */ var decamelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decamelize */ "./node_modules/decamelize/index.js");
/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! camelcase */ "./node_modules/@langchain/core/node_modules/camelcase/index.js");


function keyToJson(key, map) {
  return (map === null || map === void 0 ? void 0 : map[key]) || decamelize__WEBPACK_IMPORTED_MODULE_0__(key);
}
function keyFromJson(key, map) {
  return (map === null || map === void 0 ? void 0 : map[key]) || camelcase__WEBPACK_IMPORTED_MODULE_1__(key);
}
function mapKeys(fields, mapper, map) {
  var mapped = {};
  for (var key in fields) {
    if (Object.hasOwn(fields, key)) {
      mapped[mapper(key, map)] = fields[key];
    }
  }
  return mapped;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/load/serializable.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/serializable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Serializable: () => (/* binding */ Serializable),
/* harmony export */   get_lc_unique_name: () => (/* binding */ get_lc_unique_name)
/* harmony export */ });
/* harmony import */ var _map_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map_keys.js */ "./node_modules/@langchain/core/dist/load/map_keys.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function shallowCopy(obj) {
  return Array.isArray(obj) ? _toConsumableArray(obj) : _objectSpread({}, obj);
}
function replaceSecrets(root, secretsMap) {
  var result = shallowCopy(root);
  for (var _i = 0, _Object$entries = Object.entries(secretsMap); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      path = _Object$entries$_i[0],
      secretId = _Object$entries$_i[1];
    var _path$split$reverse = path.split(".").reverse(),
      _path$split$reverse2 = _toArray(_path$split$reverse),
      last = _path$split$reverse2[0],
      partsReverse = _path$split$reverse2.slice(1);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var current = result;
    var _iterator = _createForOfIteratorHelper(partsReverse.reverse()),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var part = _step.value;
        if (current[part] === undefined) {
          break;
        }
        current[part] = shallowCopy(current[part]);
        current = current[part];
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (current[last] !== undefined) {
      current[last] = {
        lc: 1,
        type: "secret",
        id: [secretId]
      };
    }
  }
  return result;
}
/**
 * Get a unique name for the module, rather than parent class implementations.
 * Should not be subclassed, subclass lc_name above instead.
 */
function get_lc_unique_name(
// eslint-disable-next-line @typescript-eslint/no-use-before-define
serializableClass) {
  // "super" here would refer to the parent class of Serializable,
  // when we want the parent class of the module actually calling this method.
  var parentClass = Object.getPrototypeOf(serializableClass);
  var lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) {
    return serializableClass.lc_name();
  } else {
    return serializableClass.name;
  }
}
var Serializable = /*#__PURE__*/function () {
  function Serializable(kwargs) {
    _classCallCheck(this, Serializable);
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.lc_kwargs = kwargs || {};
  }
  return _createClass(Serializable, [{
    key: "lc_id",
    get:
    /**
     * The final serialized identifier for the module.
     */
    function get() {
      return [].concat(_toConsumableArray(this.lc_namespace), [get_lc_unique_name(this.constructor)]);
    }
    /**
     * A map of secrets, which will be omitted from serialization.
     * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
     * Values are the secret ids, which will be used when deserializing.
     */
  }, {
    key: "lc_secrets",
    get: function get() {
      return undefined;
    }
    /**
     * A map of additional attributes to merge with constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the attribute values, which will be serialized.
     * These attributes need to be accepted by the constructor as arguments.
     */
  }, {
    key: "lc_attributes",
    get: function get() {
      return undefined;
    }
    /**
     * A map of aliases for constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the alias that will replace the key in serialization.
     * This is used to eg. make argument names match Python.
     */
  }, {
    key: "lc_aliases",
    get: function get() {
      return undefined;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this = this;
      if (!this.lc_serializable) {
        return this.toJSONNotImplemented();
      }
      if (
      // eslint-disable-next-line no-instanceof/no-instanceof
      this.lc_kwargs instanceof Serializable || _typeof(this.lc_kwargs) !== "object" || Array.isArray(this.lc_kwargs)) {
        // We do not support serialization of classes with arg not a POJO
        // I'm aware the check above isn't as strict as it could be
        return this.toJSONNotImplemented();
      }
      var aliases = {};
      var secrets = {};
      var kwargs = Object.keys(this.lc_kwargs).reduce(function (acc, key) {
        acc[key] = key in _this ? _this[key] : _this.lc_kwargs[key];
        return acc;
      }, {});
      // get secrets, attributes and aliases from all superclasses
      for (
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
        Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
        Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
        Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
      }
      // include all secrets used, even if not in kwargs,
      // will be replaced with sentinel value in replaceSecrets
      Object.keys(secrets).forEach(function (keyPath) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any
        var read = _this;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var write = kwargs;
        var _keyPath$split$revers = keyPath.split(".").reverse(),
          _keyPath$split$revers2 = _toArray(_keyPath$split$revers),
          last = _keyPath$split$revers2[0],
          partsReverse = _keyPath$split$revers2.slice(1);
        var _iterator2 = _createForOfIteratorHelper(partsReverse.reverse()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var key = _step2.value;
            if (!(key in read) || read[key] === undefined) return;
            if (!(key in write) || write[key] === undefined) {
              if (_typeof(read[key]) === "object" && read[key] != null) {
                write[key] = {};
              } else if (Array.isArray(read[key])) {
                write[key] = [];
              }
            }
            read = read[key];
            write = write[key];
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (last in read && read[last] !== undefined) {
          write[last] = write[last] || read[last];
        }
      });
      return {
        lc: 1,
        type: "constructor",
        id: this.lc_id,
        kwargs: (0,_map_keys_js__WEBPACK_IMPORTED_MODULE_0__.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, _map_keys_js__WEBPACK_IMPORTED_MODULE_0__.keyToJson, aliases)
      };
    }
  }, {
    key: "toJSONNotImplemented",
    value: function toJSONNotImplemented() {
      return {
        lc: 1,
        type: "not_implemented",
        id: this.lc_id
      };
    }
  }], [{
    key: "lc_name",
    value:
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
    function lc_name() {
      return this.name;
    }
  }]);
}();

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/ai.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/ai.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIMessage: () => (/* binding */ AIMessage),
/* harmony export */   AIMessageChunk: () => (/* binding */ AIMessageChunk),
/* harmony export */   isAIMessage: () => (/* binding */ isAIMessage),
/* harmony export */   isAIMessageChunk: () => (/* binding */ isAIMessageChunk)
/* harmony export */ });
/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/json.js */ "./node_modules/@langchain/core/dist/utils/json.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ "./node_modules/@langchain/core/dist/messages/tool.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }



/**
 * Represents an AI message in a conversation.
 */
var AIMessage = /*#__PURE__*/function (_BaseMessage) {
  function AIMessage(fields, /** @deprecated */
  kwargs) {
    var _this;
    _classCallCheck(this, AIMessage);
    var initParams;
    if (typeof fields === "string") {
      initParams = {
        content: fields,
        tool_calls: [],
        invalid_tool_calls: [],
        additional_kwargs: kwargs !== null && kwargs !== void 0 ? kwargs : {}
      };
    } else {
      var _initParams$additiona;
      initParams = fields;
      var rawToolCalls = (_initParams$additiona = initParams.additional_kwargs) === null || _initParams$additiona === void 0 ? void 0 : _initParams$additiona.tool_calls;
      var toolCalls = initParams.tool_calls;
      if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === undefined || toolCalls.length === 0)) {
        console.warn(["New LangChain packages are available that more efficiently handle", "tool calling.\n\nPlease upgrade your packages to versions that set", "message tool calls. e.g., `yarn add @langchain/anthropic`,", "yarn add @langchain/openai`, etc."].join(" "));
      }
      try {
        if (!(rawToolCalls == null) && toolCalls === undefined) {
          var _defaultToolCallParse = (0,_tool_js__WEBPACK_IMPORTED_MODULE_2__.defaultToolCallParser)(rawToolCalls),
            _defaultToolCallParse2 = _slicedToArray(_defaultToolCallParse, 2),
            _toolCalls = _defaultToolCallParse2[0],
            invalidToolCalls = _defaultToolCallParse2[1];
          initParams.tool_calls = _toolCalls !== null && _toolCalls !== void 0 ? _toolCalls : [];
          initParams.invalid_tool_calls = invalidToolCalls !== null && invalidToolCalls !== void 0 ? invalidToolCalls : [];
        } else {
          var _initParams$tool_call, _initParams$invalid_t;
          initParams.tool_calls = (_initParams$tool_call = initParams.tool_calls) !== null && _initParams$tool_call !== void 0 ? _initParams$tool_call : [];
          initParams.invalid_tool_calls = (_initParams$invalid_t = initParams.invalid_tool_calls) !== null && _initParams$invalid_t !== void 0 ? _initParams$invalid_t : [];
        }
      } catch (e) {
        // Do nothing if parsing fails
        initParams.tool_calls = [];
        initParams.invalid_tool_calls = [];
      }
    }
    // Sadly, TypeScript only allows super() calls at root if the class has
    // properties with initializers, so we have to check types twice.
    _this = _callSuper(this, AIMessage, [initParams]);
    // These are typed as optional to avoid breaking changes and allow for casting
    // from BaseMessage.
    Object.defineProperty(_this, "tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this, "invalid_tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    /**
     * If provided, token usage information associated with the message.
     */
    Object.defineProperty(_this, "usage_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (typeof initParams !== "string") {
      var _initParams$tool_call2, _initParams$invalid_t2;
      _this.tool_calls = (_initParams$tool_call2 = initParams.tool_calls) !== null && _initParams$tool_call2 !== void 0 ? _initParams$tool_call2 : _this.tool_calls;
      _this.invalid_tool_calls = (_initParams$invalid_t2 = initParams.invalid_tool_calls) !== null && _initParams$invalid_t2 !== void 0 ? _initParams$invalid_t2 : _this.invalid_tool_calls;
    }
    _this.usage_metadata = initParams.usage_metadata;
    return _this;
  }
  _inherits(AIMessage, _BaseMessage);
  return _createClass(AIMessage, [{
    key: "lc_aliases",
    get: function get() {
      // exclude snake case conversion to pascal case
      return _objectSpread(_objectSpread({}, _superPropGet(AIMessage, "lc_aliases", this, 1)), {}, {
        tool_calls: "tool_calls",
        invalid_tool_calls: "invalid_tool_calls"
      });
    }
  }, {
    key: "_getType",
    value: function _getType() {
      return "ai";
    }
  }, {
    key: "_printableFields",
    get: function get() {
      return _objectSpread(_objectSpread({}, _superPropGet(AIMessage, "_printableFields", this, 1)), {}, {
        tool_calls: this.tool_calls,
        invalid_tool_calls: this.invalid_tool_calls,
        usage_metadata: this.usage_metadata
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "AIMessage";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessage);
function isAIMessage(x) {
  return x._getType() === "ai";
}
function isAIMessageChunk(x) {
  return x._getType() === "ai";
}
/**
 * Represents a chunk of an AI message, which can be concatenated with
 * other AI message chunks.
 */
var AIMessageChunk = /*#__PURE__*/function (_BaseMessageChunk) {
  function AIMessageChunk(fields) {
    var _initParams$tool_call3, _initParams$tool_call4, _initParams$invalid_t3;
    var _this2;
    _classCallCheck(this, AIMessageChunk);
    var initParams;
    if (typeof fields === "string") {
      initParams = {
        content: fields,
        tool_calls: [],
        invalid_tool_calls: [],
        tool_call_chunks: []
      };
    } else if (fields.tool_call_chunks === undefined) {
      var _fields$tool_calls;
      initParams = _objectSpread(_objectSpread({}, fields), {}, {
        tool_calls: (_fields$tool_calls = fields.tool_calls) !== null && _fields$tool_calls !== void 0 ? _fields$tool_calls : [],
        invalid_tool_calls: [],
        tool_call_chunks: [],
        usage_metadata: fields.usage_metadata !== undefined ? fields.usage_metadata : undefined
      });
    } else {
      var toolCalls = [];
      var invalidToolCalls = [];
      var _iterator = _createForOfIteratorHelper(fields.tool_call_chunks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var toolCallChunk = _step.value;
          var parsedArgs = {};
          try {
            var _toolCallChunk$name;
            parsedArgs = (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(toolCallChunk.args || "{}");
            if (parsedArgs === null || _typeof(parsedArgs) !== "object" || Array.isArray(parsedArgs)) {
              throw new Error("Malformed tool call chunk args.");
            }
            toolCalls.push({
              name: (_toolCallChunk$name = toolCallChunk.name) !== null && _toolCallChunk$name !== void 0 ? _toolCallChunk$name : "",
              args: parsedArgs,
              id: toolCallChunk.id,
              type: "tool_call"
            });
          } catch (e) {
            invalidToolCalls.push({
              name: toolCallChunk.name,
              args: toolCallChunk.args,
              id: toolCallChunk.id,
              error: "Malformed args.",
              type: "invalid_tool_call"
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      initParams = _objectSpread(_objectSpread({}, fields), {}, {
        tool_calls: toolCalls,
        invalid_tool_calls: invalidToolCalls,
        usage_metadata: fields.usage_metadata !== undefined ? fields.usage_metadata : undefined
      });
    }
    // Sadly, TypeScript only allows super() calls at root if the class has
    // properties with initializers, so we have to check types twice.
    _this2 = _callSuper(this, AIMessageChunk, [initParams]);
    // Must redeclare tool call fields since there is no multiple inheritance in JS.
    // These are typed as optional to avoid breaking changes and allow for casting
    // from BaseMessage.
    Object.defineProperty(_this2, "tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this2, "invalid_tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this2, "tool_call_chunks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    /**
     * If provided, token usage information associated with the message.
     */
    Object.defineProperty(_this2, "usage_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this2.tool_call_chunks = (_initParams$tool_call3 = initParams.tool_call_chunks) !== null && _initParams$tool_call3 !== void 0 ? _initParams$tool_call3 : _this2.tool_call_chunks;
    _this2.tool_calls = (_initParams$tool_call4 = initParams.tool_calls) !== null && _initParams$tool_call4 !== void 0 ? _initParams$tool_call4 : _this2.tool_calls;
    _this2.invalid_tool_calls = (_initParams$invalid_t3 = initParams.invalid_tool_calls) !== null && _initParams$invalid_t3 !== void 0 ? _initParams$invalid_t3 : _this2.invalid_tool_calls;
    _this2.usage_metadata = initParams.usage_metadata;
    return _this2;
  }
  _inherits(AIMessageChunk, _BaseMessageChunk);
  return _createClass(AIMessageChunk, [{
    key: "lc_aliases",
    get: function get() {
      // exclude snake case conversion to pascal case
      return _objectSpread(_objectSpread({}, _superPropGet(AIMessageChunk, "lc_aliases", this, 1)), {}, {
        tool_calls: "tool_calls",
        invalid_tool_calls: "invalid_tool_calls",
        tool_call_chunks: "tool_call_chunks"
      });
    }
  }, {
    key: "_getType",
    value: function _getType() {
      return "ai";
    }
  }, {
    key: "_printableFields",
    get: function get() {
      return _objectSpread(_objectSpread({}, _superPropGet(AIMessageChunk, "_printableFields", this, 1)), {}, {
        tool_calls: this.tool_calls,
        tool_call_chunks: this.tool_call_chunks,
        invalid_tool_calls: this.invalid_tool_calls,
        usage_metadata: this.usage_metadata
      });
    }
  }, {
    key: "concat",
    value: function concat(chunk) {
      var _this$id;
      var combinedFields = {
        content: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.mergeContent)(this.content, chunk.content),
        additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.response_metadata, chunk.response_metadata),
        tool_call_chunks: [],
        id: (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : chunk.id
      };
      if (this.tool_call_chunks !== undefined || chunk.tool_call_chunks !== undefined) {
        var rawToolCalls = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);
        if (rawToolCalls !== undefined && rawToolCalls.length > 0) {
          combinedFields.tool_call_chunks = rawToolCalls;
        }
      }
      if (this.usage_metadata !== undefined || chunk.usage_metadata !== undefined) {
        var _this$usage_metadata, _chunk$usage_metadata, _this$usage_metadata$, _this$usage_metadata2, _chunk$usage_metadata2, _chunk$usage_metadata3, _this$usage_metadata3, _chunk$usage_metadata4, _this$usage_metadata$2, _this$usage_metadata4, _chunk$usage_metadata5, _chunk$usage_metadata6, _this$usage_metadata5, _chunk$usage_metadata7, _this$usage_metadata$3, _this$usage_metadata6, _chunk$usage_metadata8, _chunk$usage_metadata9, _this$usage_metadata7, _chunk$usage_metadata10, _this$usage_metadata$4, _this$usage_metadata8, _chunk$usage_metadata11, _chunk$usage_metadata12, _this$usage_metadata9, _chunk$usage_metadata13, _this$usage_metadata$5, _this$usage_metadata10, _chunk$usage_metadata14, _chunk$usage_metadata15, _this$usage_metadata11, _chunk$usage_metadata16;
        var inputTokenDetails = _objectSpread(_objectSpread(_objectSpread({}, (((_this$usage_metadata = this.usage_metadata) === null || _this$usage_metadata === void 0 || (_this$usage_metadata = _this$usage_metadata.input_token_details) === null || _this$usage_metadata === void 0 ? void 0 : _this$usage_metadata.audio) !== undefined || ((_chunk$usage_metadata = chunk.usage_metadata) === null || _chunk$usage_metadata === void 0 || (_chunk$usage_metadata = _chunk$usage_metadata.input_token_details) === null || _chunk$usage_metadata === void 0 ? void 0 : _chunk$usage_metadata.audio) !== undefined) && {
          audio: ((_this$usage_metadata$ = (_this$usage_metadata2 = this.usage_metadata) === null || _this$usage_metadata2 === void 0 || (_this$usage_metadata2 = _this$usage_metadata2.input_token_details) === null || _this$usage_metadata2 === void 0 ? void 0 : _this$usage_metadata2.audio) !== null && _this$usage_metadata$ !== void 0 ? _this$usage_metadata$ : 0) + ((_chunk$usage_metadata2 = (_chunk$usage_metadata3 = chunk.usage_metadata) === null || _chunk$usage_metadata3 === void 0 || (_chunk$usage_metadata3 = _chunk$usage_metadata3.input_token_details) === null || _chunk$usage_metadata3 === void 0 ? void 0 : _chunk$usage_metadata3.audio) !== null && _chunk$usage_metadata2 !== void 0 ? _chunk$usage_metadata2 : 0)
        }), (((_this$usage_metadata3 = this.usage_metadata) === null || _this$usage_metadata3 === void 0 || (_this$usage_metadata3 = _this$usage_metadata3.input_token_details) === null || _this$usage_metadata3 === void 0 ? void 0 : _this$usage_metadata3.cache_read) !== undefined || ((_chunk$usage_metadata4 = chunk.usage_metadata) === null || _chunk$usage_metadata4 === void 0 || (_chunk$usage_metadata4 = _chunk$usage_metadata4.input_token_details) === null || _chunk$usage_metadata4 === void 0 ? void 0 : _chunk$usage_metadata4.cache_read) !== undefined) && {
          cache_read: ((_this$usage_metadata$2 = (_this$usage_metadata4 = this.usage_metadata) === null || _this$usage_metadata4 === void 0 || (_this$usage_metadata4 = _this$usage_metadata4.input_token_details) === null || _this$usage_metadata4 === void 0 ? void 0 : _this$usage_metadata4.cache_read) !== null && _this$usage_metadata$2 !== void 0 ? _this$usage_metadata$2 : 0) + ((_chunk$usage_metadata5 = (_chunk$usage_metadata6 = chunk.usage_metadata) === null || _chunk$usage_metadata6 === void 0 || (_chunk$usage_metadata6 = _chunk$usage_metadata6.input_token_details) === null || _chunk$usage_metadata6 === void 0 ? void 0 : _chunk$usage_metadata6.cache_read) !== null && _chunk$usage_metadata5 !== void 0 ? _chunk$usage_metadata5 : 0)
        }), (((_this$usage_metadata5 = this.usage_metadata) === null || _this$usage_metadata5 === void 0 || (_this$usage_metadata5 = _this$usage_metadata5.input_token_details) === null || _this$usage_metadata5 === void 0 ? void 0 : _this$usage_metadata5.cache_creation) !== undefined || ((_chunk$usage_metadata7 = chunk.usage_metadata) === null || _chunk$usage_metadata7 === void 0 || (_chunk$usage_metadata7 = _chunk$usage_metadata7.input_token_details) === null || _chunk$usage_metadata7 === void 0 ? void 0 : _chunk$usage_metadata7.cache_creation) !== undefined) && {
          cache_creation: ((_this$usage_metadata$3 = (_this$usage_metadata6 = this.usage_metadata) === null || _this$usage_metadata6 === void 0 || (_this$usage_metadata6 = _this$usage_metadata6.input_token_details) === null || _this$usage_metadata6 === void 0 ? void 0 : _this$usage_metadata6.cache_creation) !== null && _this$usage_metadata$3 !== void 0 ? _this$usage_metadata$3 : 0) + ((_chunk$usage_metadata8 = (_chunk$usage_metadata9 = chunk.usage_metadata) === null || _chunk$usage_metadata9 === void 0 || (_chunk$usage_metadata9 = _chunk$usage_metadata9.input_token_details) === null || _chunk$usage_metadata9 === void 0 ? void 0 : _chunk$usage_metadata9.cache_creation) !== null && _chunk$usage_metadata8 !== void 0 ? _chunk$usage_metadata8 : 0)
        });
        var outputTokenDetails = _objectSpread(_objectSpread({}, (((_this$usage_metadata7 = this.usage_metadata) === null || _this$usage_metadata7 === void 0 || (_this$usage_metadata7 = _this$usage_metadata7.output_token_details) === null || _this$usage_metadata7 === void 0 ? void 0 : _this$usage_metadata7.audio) !== undefined || ((_chunk$usage_metadata10 = chunk.usage_metadata) === null || _chunk$usage_metadata10 === void 0 || (_chunk$usage_metadata10 = _chunk$usage_metadata10.output_token_details) === null || _chunk$usage_metadata10 === void 0 ? void 0 : _chunk$usage_metadata10.audio) !== undefined) && {
          audio: ((_this$usage_metadata$4 = (_this$usage_metadata8 = this.usage_metadata) === null || _this$usage_metadata8 === void 0 || (_this$usage_metadata8 = _this$usage_metadata8.output_token_details) === null || _this$usage_metadata8 === void 0 ? void 0 : _this$usage_metadata8.audio) !== null && _this$usage_metadata$4 !== void 0 ? _this$usage_metadata$4 : 0) + ((_chunk$usage_metadata11 = (_chunk$usage_metadata12 = chunk.usage_metadata) === null || _chunk$usage_metadata12 === void 0 || (_chunk$usage_metadata12 = _chunk$usage_metadata12.output_token_details) === null || _chunk$usage_metadata12 === void 0 ? void 0 : _chunk$usage_metadata12.audio) !== null && _chunk$usage_metadata11 !== void 0 ? _chunk$usage_metadata11 : 0)
        }), (((_this$usage_metadata9 = this.usage_metadata) === null || _this$usage_metadata9 === void 0 || (_this$usage_metadata9 = _this$usage_metadata9.output_token_details) === null || _this$usage_metadata9 === void 0 ? void 0 : _this$usage_metadata9.reasoning) !== undefined || ((_chunk$usage_metadata13 = chunk.usage_metadata) === null || _chunk$usage_metadata13 === void 0 || (_chunk$usage_metadata13 = _chunk$usage_metadata13.output_token_details) === null || _chunk$usage_metadata13 === void 0 ? void 0 : _chunk$usage_metadata13.reasoning) !== undefined) && {
          reasoning: ((_this$usage_metadata$5 = (_this$usage_metadata10 = this.usage_metadata) === null || _this$usage_metadata10 === void 0 || (_this$usage_metadata10 = _this$usage_metadata10.output_token_details) === null || _this$usage_metadata10 === void 0 ? void 0 : _this$usage_metadata10.reasoning) !== null && _this$usage_metadata$5 !== void 0 ? _this$usage_metadata$5 : 0) + ((_chunk$usage_metadata14 = (_chunk$usage_metadata15 = chunk.usage_metadata) === null || _chunk$usage_metadata15 === void 0 || (_chunk$usage_metadata15 = _chunk$usage_metadata15.output_token_details) === null || _chunk$usage_metadata15 === void 0 ? void 0 : _chunk$usage_metadata15.reasoning) !== null && _chunk$usage_metadata14 !== void 0 ? _chunk$usage_metadata14 : 0)
        });
        var left = (_this$usage_metadata11 = this.usage_metadata) !== null && _this$usage_metadata11 !== void 0 ? _this$usage_metadata11 : {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        };
        var right = (_chunk$usage_metadata16 = chunk.usage_metadata) !== null && _chunk$usage_metadata16 !== void 0 ? _chunk$usage_metadata16 : {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        };
        var usage_metadata = _objectSpread(_objectSpread({
          input_tokens: left.input_tokens + right.input_tokens,
          output_tokens: left.output_tokens + right.output_tokens,
          total_tokens: left.total_tokens + right.total_tokens
        }, Object.keys(inputTokenDetails).length > 0 && {
          input_token_details: inputTokenDetails
        }), Object.keys(outputTokenDetails).length > 0 && {
          output_token_details: outputTokenDetails
        });
        combinedFields.usage_metadata = usage_metadata;
      }
      return new AIMessageChunk(combinedFields);
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "AIMessageChunk";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageChunk);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/base.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/base.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseMessage: () => (/* binding */ BaseMessage),
/* harmony export */   BaseMessageChunk: () => (/* binding */ BaseMessageChunk),
/* harmony export */   _isMessageFieldWithRole: () => (/* binding */ _isMessageFieldWithRole),
/* harmony export */   _mergeDicts: () => (/* binding */ _mergeDicts),
/* harmony export */   _mergeLists: () => (/* binding */ _mergeLists),
/* harmony export */   _mergeObj: () => (/* binding */ _mergeObj),
/* harmony export */   _mergeStatus: () => (/* binding */ _mergeStatus),
/* harmony export */   isBaseMessage: () => (/* binding */ isBaseMessage),
/* harmony export */   isBaseMessageChunk: () => (/* binding */ isBaseMessageChunk),
/* harmony export */   isOpenAIToolCallArray: () => (/* binding */ isOpenAIToolCallArray),
/* harmony export */   mergeContent: () => (/* binding */ mergeContent)
/* harmony export */ });
/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ "./node_modules/@langchain/core/dist/load/serializable.js");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function mergeContent(firstContent, secondContent) {
  // If first content is a string
  if (typeof firstContent === "string") {
    if (typeof secondContent === "string") {
      return firstContent + secondContent;
    } else {
      return [{
        type: "text",
        text: firstContent
      }].concat(_toConsumableArray(secondContent));
    }
    // If both are arrays
  } else if (Array.isArray(secondContent)) {
    var _mergeLists2;
    return (_mergeLists2 = _mergeLists(firstContent, secondContent)) !== null && _mergeLists2 !== void 0 ? _mergeLists2 : [].concat(_toConsumableArray(firstContent), _toConsumableArray(secondContent));
  } else {
    // Otherwise, add the second content as a new element of the list
    return [].concat(_toConsumableArray(firstContent), [{
      type: "text",
      text: secondContent
    }]);
  }
}
/**
 * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else
 * it will return 'success'.
 *
 * @param {"success" | "error" | undefined} left The existing value to 'merge' with the new value.
 * @param {"success" | "error" | undefined} right The new value to 'merge' with the existing value
 * @returns {"success" | "error"} The 'merged' value.
 */
function _mergeStatus(left, right) {
  if (left === "error" || right === "error") {
    return "error";
  }
  return "success";
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function stringifyWithDepthLimit(obj, depthLimit) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function helper(obj, currentDepth) {
    if (_typeof(obj) !== "object" || obj === null || obj === undefined) {
      return obj;
    }
    if (currentDepth >= depthLimit) {
      if (Array.isArray(obj)) {
        return "[Array]";
      }
      return "[Object]";
    }
    if (Array.isArray(obj)) {
      return obj.map(function (item) {
        return helper(item, currentDepth + 1);
      });
    }
    var result = {};
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      result[key] = helper(obj[key], currentDepth + 1);
    }
    return result;
  }
  return JSON.stringify(helper(obj, 0), null, 2);
}
/**
 * Base class for all types of messages in a conversation. It includes
 * properties like `content`, `name`, and `additional_kwargs`. It also
 * includes methods like `toDict()` and `_getType()`.
 */
var BaseMessage = /*#__PURE__*/function (_Serializable) {
  function BaseMessage(fields, /** @deprecated */
  kwargs) {
    var _this;
    _classCallCheck(this, BaseMessage);
    if (typeof fields === "string") {
      // eslint-disable-next-line no-param-reassign
      fields = {
        content: fields,
        additional_kwargs: kwargs,
        response_metadata: {}
      };
    }
    // Make sure the default value for additional_kwargs is passed into super() for serialization
    if (!fields.additional_kwargs) {
      // eslint-disable-next-line no-param-reassign
      fields.additional_kwargs = {};
    }
    if (!fields.response_metadata) {
      // eslint-disable-next-line no-param-reassign
      fields.response_metadata = {};
    }
    _this = _callSuper(this, BaseMessage, [fields]);
    Object.defineProperty(_this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "messages"]
    });
    Object.defineProperty(_this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    /** The content of the message. */
    Object.defineProperty(_this, "content", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /** The name of the message sender in a multi-user chat. */
    Object.defineProperty(_this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /** Additional keyword arguments */
    Object.defineProperty(_this, "additional_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /** Response metadata. For example: response headers, logprobs, token counts. */
    Object.defineProperty(_this, "response_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * An optional unique identifier for the message. This should ideally be
     * provided by the provider/model which created the message.
     */
    Object.defineProperty(_this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.name = fields.name;
    _this.content = fields.content;
    _this.additional_kwargs = fields.additional_kwargs;
    _this.response_metadata = fields.response_metadata;
    _this.id = fields.id;
    return _this;
  }
  _inherits(BaseMessage, _Serializable);
  return _createClass(BaseMessage, [{
    key: "lc_aliases",
    get: function get() {
      // exclude snake case conversion to pascal case
      return {
        additional_kwargs: "additional_kwargs",
        response_metadata: "response_metadata"
      };
    }
    /**
     * @deprecated
     * Use {@link BaseMessage.content} instead.
     */
  }, {
    key: "text",
    get: function get() {
      return typeof this.content === "string" ? this.content : "";
    }
    /** The type of the message. */
  }, {
    key: "getType",
    value: function getType() {
      return this._getType();
    }
  }, {
    key: "toDict",
    value: function toDict() {
      return {
        type: this._getType(),
        data: this.toJSON().kwargs
      };
    }
  }, {
    key: "_printableFields",
    get:
    // Can't be protected for silly reasons
    function get() {
      return {
        id: this.id,
        content: this.content,
        name: this.name,
        additional_kwargs: this.additional_kwargs,
        response_metadata: this.response_metadata
      };
    }
    // this private method is used to update the ID for the runtime
    // value as well as in lc_kwargs for serialisation
  }, {
    key: "_updateId",
    value: function _updateId(value) {
      this.id = value;
      // lc_attributes wouldn't work here, because jest compares the
      // whole object
      this.lc_kwargs.id = value;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return this.constructor.lc_name();
    }
    // Override the default behavior of console.log
  }, {
    key: Symbol["for"]("nodejs.util.inspect.custom"),
    value: function value(depth) {
      if (depth === null) {
        return this;
      }
      var printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return "".concat(this.constructor.lc_name(), " ").concat(printable);
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "BaseMessage";
    }
  }]);
}(_load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable);
function isOpenAIToolCallArray(value) {
  return Array.isArray(value) && value.every(function (v) {
    return typeof v.index === "number";
  });
}
function _mergeDicts(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
left,
// eslint-disable-next-line @typescript-eslint/no-explicit-any
right
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  var merged = _objectSpread({}, left);
  for (var _i2 = 0, _Object$entries = Object.entries(right); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
      key = _Object$entries$_i[0],
      value = _Object$entries$_i[1];
    if (merged[key] == null) {
      merged[key] = value;
    } else if (value == null) {
      continue;
    } else if (_typeof(merged[key]) !== _typeof(value) || Array.isArray(merged[key]) !== Array.isArray(value)) {
      throw new Error("field[".concat(key, "] already exists in the message chunk, but with a different type."));
    } else if (typeof merged[key] === "string") {
      if (key === "type") {
        // Do not merge 'type' fields
        continue;
      }
      merged[key] += value;
    } else if (_typeof(merged[key]) === "object" && !Array.isArray(merged[key])) {
      merged[key] = _mergeDicts(merged[key], value);
    } else if (Array.isArray(merged[key])) {
      merged[key] = _mergeLists(merged[key], value);
    } else if (merged[key] === value) {
      continue;
    } else {
      console.warn("field[".concat(key, "] already exists in this message chunk and value has unsupported type."));
    }
  }
  return merged;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _mergeLists(left, right) {
  if (left === undefined && right === undefined) {
    return undefined;
  } else if (left === undefined || right === undefined) {
    return left || right;
  } else {
    var merged = _toConsumableArray(left);
    var _iterator = _createForOfIteratorHelper(right),
      _step;
    try {
      var _loop = function _loop() {
        var item = _step.value;
        if (_typeof(item) === "object" && "index" in item && typeof item.index === "number") {
          var toMerge = merged.findIndex(function (leftItem) {
            return leftItem.index === item.index;
          });
          if (toMerge !== -1) {
            merged[toMerge] = _mergeDicts(merged[toMerge], item);
          } else {
            merged.push(item);
          }
        } else if (_typeof(item) === "object" && "text" in item && item.text === "") {
          // No-op - skip empty text blocks
          return 1; // continue
        } else {
          merged.push(item);
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        if (_loop()) continue;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return merged;
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _mergeObj(left, right) {
  if (!left && !right) {
    throw new Error("Cannot merge two undefined objects.");
  }
  if (!left || !right) {
    return left || right;
  } else if (_typeof(left) !== _typeof(right)) {
    throw new Error("Cannot merge objects of different types.\nLeft ".concat(_typeof(left), "\nRight ").concat(_typeof(right)));
  } else if (typeof left === "string" && typeof right === "string") {
    return left + right;
  } else if (Array.isArray(left) && Array.isArray(right)) {
    return _mergeLists(left, right);
  } else if (_typeof(left) === "object" && _typeof(right) === "object") {
    return _mergeDicts(left, right);
  } else if (left === right) {
    return left;
  } else {
    throw new Error("Can not merge objects of different types.\nLeft ".concat(left, "\nRight ").concat(right));
  }
}
/**
 * Represents a chunk of a message, which can be concatenated with other
 * message chunks. It includes a method `_merge_kwargs_dict()` for merging
 * additional keyword arguments from another `BaseMessageChunk` into this
 * one. It also overrides the `__add__()` method to support concatenation
 * of `BaseMessageChunk` instances.
 */
var BaseMessageChunk = /*#__PURE__*/function (_BaseMessage) {
  function BaseMessageChunk() {
    _classCallCheck(this, BaseMessageChunk);
    return _callSuper(this, BaseMessageChunk, arguments);
  }
  _inherits(BaseMessageChunk, _BaseMessage);
  return _createClass(BaseMessageChunk);
}(BaseMessage);
function _isMessageFieldWithRole(x) {
  return typeof x.role === "string";
}
function isBaseMessage(messageLike) {
  return typeof (messageLike === null || messageLike === void 0 ? void 0 : messageLike._getType) === "function";
}
function isBaseMessageChunk(messageLike) {
  return isBaseMessage(messageLike) && typeof messageLike.concat === "function";
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/chat.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/chat.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChatMessage: () => (/* binding */ ChatMessage),
/* harmony export */   ChatMessageChunk: () => (/* binding */ ChatMessageChunk),
/* harmony export */   isChatMessage: () => (/* binding */ isChatMessage),
/* harmony export */   isChatMessageChunk: () => (/* binding */ isChatMessageChunk)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

/**
 * Represents a chat message in a conversation.
 */
var ChatMessage = /*#__PURE__*/function (_BaseMessage) {
  function ChatMessage(fields, role) {
    var _this;
    _classCallCheck(this, ChatMessage);
    if (typeof fields === "string") {
      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion
      fields = {
        content: fields,
        role: role
      };
    }
    _this = _callSuper(this, ChatMessage, [fields]);
    Object.defineProperty(_this, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.role = fields.role;
    return _this;
  }
  _inherits(ChatMessage, _BaseMessage);
  return _createClass(ChatMessage, [{
    key: "_getType",
    value: function _getType() {
      return "generic";
    }
  }, {
    key: "_printableFields",
    get: function get() {
      return _objectSpread(_objectSpread({}, _superPropGet(ChatMessage, "_printableFields", this, 1)), {}, {
        role: this.role
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "ChatMessage";
    }
  }, {
    key: "_chatMessageClass",
    value: function _chatMessageClass() {
      return ChatMessage;
    }
  }, {
    key: "isInstance",
    value: function isInstance(message) {
      return message._getType() === "generic";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage);
/**
 * Represents a chunk of a chat message, which can be concatenated with
 * other chat message chunks.
 */
var ChatMessageChunk = /*#__PURE__*/function (_BaseMessageChunk) {
  function ChatMessageChunk(fields, role) {
    var _this2;
    _classCallCheck(this, ChatMessageChunk);
    if (typeof fields === "string") {
      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion
      fields = {
        content: fields,
        role: role
      };
    }
    _this2 = _callSuper(this, ChatMessageChunk, [fields]);
    Object.defineProperty(_this2, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this2.role = fields.role;
    return _this2;
  }
  _inherits(ChatMessageChunk, _BaseMessageChunk);
  return _createClass(ChatMessageChunk, [{
    key: "_getType",
    value: function _getType() {
      return "generic";
    }
  }, {
    key: "concat",
    value: function concat(chunk) {
      var _this$id;
      return new ChatMessageChunk({
        content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),
        additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),
        role: this.role,
        id: (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : chunk.id
      });
    }
  }, {
    key: "_printableFields",
    get: function get() {
      return _objectSpread(_objectSpread({}, _superPropGet(ChatMessageChunk, "_printableFields", this, 1)), {}, {
        role: this.role
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "ChatMessageChunk";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk);
function isChatMessage(x) {
  return x._getType() === "generic";
}
function isChatMessageChunk(x) {
  return x._getType() === "generic";
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/function.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/function.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FunctionMessage: () => (/* binding */ FunctionMessage),
/* harmony export */   FunctionMessageChunk: () => (/* binding */ FunctionMessageChunk),
/* harmony export */   isFunctionMessage: () => (/* binding */ isFunctionMessage),
/* harmony export */   isFunctionMessageChunk: () => (/* binding */ isFunctionMessageChunk)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

/**
 * Represents a function message in a conversation.
 */
var FunctionMessage = /*#__PURE__*/function (_BaseMessage) {
  function FunctionMessage(fields, /** @deprecated */
  name) {
    _classCallCheck(this, FunctionMessage);
    if (typeof fields === "string") {
      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion
      fields = {
        content: fields,
        name: name
      };
    }
    return _callSuper(this, FunctionMessage, [fields]);
  }
  _inherits(FunctionMessage, _BaseMessage);
  return _createClass(FunctionMessage, [{
    key: "_getType",
    value: function _getType() {
      return "function";
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "FunctionMessage";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage);
/**
 * Represents a chunk of a function message, which can be concatenated
 * with other function message chunks.
 */
var FunctionMessageChunk = /*#__PURE__*/function (_BaseMessageChunk) {
  function FunctionMessageChunk() {
    _classCallCheck(this, FunctionMessageChunk);
    return _callSuper(this, FunctionMessageChunk, arguments);
  }
  _inherits(FunctionMessageChunk, _BaseMessageChunk);
  return _createClass(FunctionMessageChunk, [{
    key: "_getType",
    value: function _getType() {
      return "function";
    }
  }, {
    key: "concat",
    value: function concat(chunk) {
      var _this$name, _this$id;
      return new FunctionMessageChunk({
        content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),
        additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),
        name: (_this$name = this.name) !== null && _this$name !== void 0 ? _this$name : "",
        id: (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : chunk.id
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "FunctionMessageChunk";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk);
function isFunctionMessage(x) {
  return x._getType() === "function";
}
function isFunctionMessageChunk(x) {
  return x._getType() === "function";
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/human.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/human.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HumanMessage: () => (/* binding */ HumanMessage),
/* harmony export */   HumanMessageChunk: () => (/* binding */ HumanMessageChunk),
/* harmony export */   isHumanMessage: () => (/* binding */ isHumanMessage),
/* harmony export */   isHumanMessageChunk: () => (/* binding */ isHumanMessageChunk)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

/**
 * Represents a human message in a conversation.
 */
var HumanMessage = /*#__PURE__*/function (_BaseMessage) {
  function HumanMessage() {
    _classCallCheck(this, HumanMessage);
    return _callSuper(this, HumanMessage, arguments);
  }
  _inherits(HumanMessage, _BaseMessage);
  return _createClass(HumanMessage, [{
    key: "_getType",
    value: function _getType() {
      return "human";
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "HumanMessage";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage);
/**
 * Represents a chunk of a human message, which can be concatenated with
 * other human message chunks.
 */
var HumanMessageChunk = /*#__PURE__*/function (_BaseMessageChunk) {
  function HumanMessageChunk() {
    _classCallCheck(this, HumanMessageChunk);
    return _callSuper(this, HumanMessageChunk, arguments);
  }
  _inherits(HumanMessageChunk, _BaseMessageChunk);
  return _createClass(HumanMessageChunk, [{
    key: "_getType",
    value: function _getType() {
      return "human";
    }
  }, {
    key: "concat",
    value: function concat(chunk) {
      var _this$id;
      return new HumanMessageChunk({
        content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),
        additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),
        id: (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : chunk.id
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "HumanMessageChunk";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk);
function isHumanMessage(x) {
  return x.getType() === "human";
}
function isHumanMessageChunk(x) {
  return x.getType() === "human";
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/system.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/system.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SystemMessage: () => (/* binding */ SystemMessage),
/* harmony export */   SystemMessageChunk: () => (/* binding */ SystemMessageChunk),
/* harmony export */   isSystemMessage: () => (/* binding */ isSystemMessage),
/* harmony export */   isSystemMessageChunk: () => (/* binding */ isSystemMessageChunk)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

/**
 * Represents a system message in a conversation.
 */
var SystemMessage = /*#__PURE__*/function (_BaseMessage) {
  function SystemMessage() {
    _classCallCheck(this, SystemMessage);
    return _callSuper(this, SystemMessage, arguments);
  }
  _inherits(SystemMessage, _BaseMessage);
  return _createClass(SystemMessage, [{
    key: "_getType",
    value: function _getType() {
      return "system";
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "SystemMessage";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage);
/**
 * Represents a chunk of a system message, which can be concatenated with
 * other system message chunks.
 */
var SystemMessageChunk = /*#__PURE__*/function (_BaseMessageChunk) {
  function SystemMessageChunk() {
    _classCallCheck(this, SystemMessageChunk);
    return _callSuper(this, SystemMessageChunk, arguments);
  }
  _inherits(SystemMessageChunk, _BaseMessageChunk);
  return _createClass(SystemMessageChunk, [{
    key: "_getType",
    value: function _getType() {
      return "system";
    }
  }, {
    key: "concat",
    value: function concat(chunk) {
      var _this$id;
      return new SystemMessageChunk({
        content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),
        additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),
        id: (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : chunk.id
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "SystemMessageChunk";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk);
function isSystemMessage(x) {
  return x._getType() === "system";
}
function isSystemMessageChunk(x) {
  return x._getType() === "system";
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/tool.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/tool.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToolMessage: () => (/* binding */ ToolMessage),
/* harmony export */   ToolMessageChunk: () => (/* binding */ ToolMessageChunk),
/* harmony export */   defaultToolCallParser: () => (/* binding */ defaultToolCallParser),
/* harmony export */   isToolMessage: () => (/* binding */ isToolMessage),
/* harmony export */   isToolMessageChunk: () => (/* binding */ isToolMessageChunk)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

/**
 * Represents a tool message in a conversation.
 */
var ToolMessage = /*#__PURE__*/function (_BaseMessage) {
  function ToolMessage(fields, tool_call_id, name) {
    var _this;
    _classCallCheck(this, ToolMessage);
    if (typeof fields === "string") {
      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion
      fields = {
        content: fields,
        name: name,
        tool_call_id: tool_call_id
      };
    }
    _this = _callSuper(this, ToolMessage, [fields]);
    /**
     * Status of the tool invocation.
     * @version 0.2.19
     */
    Object.defineProperty(_this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "tool_call_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Artifact of the Tool execution which is not meant to be sent to the model.
     *
     * Should only be specified if it is different from the message content, e.g. if only
     * a subset of the full tool output is being passed as message content but the full
     * output is needed in other parts of the code.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.defineProperty(_this, "artifact", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.tool_call_id = fields.tool_call_id;
    _this.artifact = fields.artifact;
    _this.status = fields.status;
    return _this;
  }
  _inherits(ToolMessage, _BaseMessage);
  return _createClass(ToolMessage, [{
    key: "lc_aliases",
    get: function get() {
      // exclude snake case conversion to pascal case
      return {
        tool_call_id: "tool_call_id"
      };
    }
  }, {
    key: "_getType",
    value: function _getType() {
      return "tool";
    }
  }, {
    key: "_printableFields",
    get: function get() {
      return _objectSpread(_objectSpread({}, _superPropGet(ToolMessage, "_printableFields", this, 1)), {}, {
        tool_call_id: this.tool_call_id,
        artifact: this.artifact
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "ToolMessage";
    }
  }, {
    key: "isInstance",
    value: function isInstance(message) {
      return message._getType() === "tool";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage);
/**
 * Represents a chunk of a tool message, which can be concatenated
 * with other tool message chunks.
 */
var ToolMessageChunk = /*#__PURE__*/function (_BaseMessageChunk) {
  function ToolMessageChunk(fields) {
    var _this2;
    _classCallCheck(this, ToolMessageChunk);
    _this2 = _callSuper(this, ToolMessageChunk, [fields]);
    Object.defineProperty(_this2, "tool_call_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Status of the tool invocation.
     * @version 0.2.19
     */
    Object.defineProperty(_this2, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Artifact of the Tool execution which is not meant to be sent to the model.
     *
     * Should only be specified if it is different from the message content, e.g. if only
     * a subset of the full tool output is being passed as message content but the full
     * output is needed in other parts of the code.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.defineProperty(_this2, "artifact", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this2.tool_call_id = fields.tool_call_id;
    _this2.artifact = fields.artifact;
    _this2.status = fields.status;
    return _this2;
  }
  _inherits(ToolMessageChunk, _BaseMessageChunk);
  return _createClass(ToolMessageChunk, [{
    key: "_getType",
    value: function _getType() {
      return "tool";
    }
  }, {
    key: "concat",
    value: function concat(chunk) {
      var _this$id;
      return new ToolMessageChunk({
        content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),
        additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),
        artifact: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeObj)(this.artifact, chunk.artifact),
        tool_call_id: this.tool_call_id,
        id: (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : chunk.id,
        status: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeStatus)(this.status, chunk.status)
      });
    }
  }, {
    key: "_printableFields",
    get: function get() {
      return _objectSpread(_objectSpread({}, _superPropGet(ToolMessageChunk, "_printableFields", this, 1)), {}, {
        tool_call_id: this.tool_call_id,
        artifact: this.artifact
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "ToolMessageChunk";
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk);
function defaultToolCallParser(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
rawToolCalls) {
  var toolCalls = [];
  var invalidToolCalls = [];
  var _iterator = _createForOfIteratorHelper(rawToolCalls),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var toolCall = _step.value;
      if (!toolCall["function"]) {
        continue;
      } else {
        var functionName = toolCall["function"].name;
        try {
          var functionArgs = JSON.parse(toolCall["function"].arguments);
          var parsed = {
            name: functionName || "",
            args: functionArgs || {},
            id: toolCall.id
          };
          toolCalls.push(parsed);
        } catch (error) {
          invalidToolCalls.push({
            name: functionName,
            args: toolCall["function"].arguments,
            id: toolCall.id,
            error: "Malformed args."
          });
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return [toolCalls, invalidToolCalls];
}
function isToolMessage(x) {
  return x._getType() === "tool";
}
function isToolMessageChunk(x) {
  return x._getType() === "tool";
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/messages/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coerceMessageLikeToMessage: () => (/* binding */ coerceMessageLikeToMessage),
/* harmony export */   convertToChunk: () => (/* binding */ convertToChunk),
/* harmony export */   getBufferString: () => (/* binding */ getBufferString),
/* harmony export */   mapChatMessagesToStoredMessages: () => (/* binding */ mapChatMessagesToStoredMessages),
/* harmony export */   mapStoredMessageToChatMessage: () => (/* binding */ mapStoredMessageToChatMessage),
/* harmony export */   mapStoredMessagesToChatMessages: () => (/* binding */ mapStoredMessagesToChatMessages)
/* harmony export */ });
/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/index.js */ "./node_modules/@langchain/core/dist/errors/index.js");
/* harmony import */ var _tools_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/utils.js */ "./node_modules/@langchain/core/dist/tools/utils.js");
/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai.js */ "./node_modules/@langchain/core/dist/messages/ai.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/messages/base.js");
/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chat.js */ "./node_modules/@langchain/core/dist/messages/chat.js");
/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function.js */ "./node_modules/@langchain/core/dist/messages/function.js");
/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./human.js */ "./node_modules/@langchain/core/dist/messages/human.js");
/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./system.js */ "./node_modules/@langchain/core/dist/messages/system.js");
/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tool.js */ "./node_modules/@langchain/core/dist/messages/tool.js");
var _excluded = ["type"],
  _excluded2 = ["tool_calls"],
  _excluded3 = ["role"];
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }









function _coerceToolCall(toolCall) {
  if ((0,_tools_utils_js__WEBPACK_IMPORTED_MODULE_1__._isToolCall)(toolCall)) {
    return toolCall;
  } else if (typeof toolCall.id === "string" && toolCall.type === "function" && _typeof(toolCall["function"]) === "object" && toolCall["function"] !== null && "arguments" in toolCall["function"] && typeof toolCall["function"].arguments === "string" && "name" in toolCall["function"] && typeof toolCall["function"].name === "string") {
    // Handle OpenAI tool call format
    return {
      id: toolCall.id,
      args: JSON.parse(toolCall["function"].arguments),
      name: toolCall["function"].name,
      type: "tool_call"
    };
  } else {
    // TODO: Throw an error?
    return toolCall;
  }
}
function isSerializedConstructor(x) {
  return _typeof(x) === "object" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && _typeof(x.kwargs) === "object";
}
function _constructMessageFromParams(params) {
  var type;
  var rest;
  // Support serialized messages
  if (isSerializedConstructor(params)) {
    var className = params.id.at(-1);
    if (className === "HumanMessage" || className === "HumanMessageChunk") {
      type = "user";
    } else if (className === "AIMessage" || className === "AIMessageChunk") {
      type = "assistant";
    } else if (className === "SystemMessage" || className === "SystemMessageChunk") {
      type = "system";
    } else {
      type = "unknown";
    }
    rest = params.kwargs;
  } else {
    var extractedType = params.type,
      otherParams = _objectWithoutProperties(params, _excluded);
    type = extractedType;
    rest = otherParams;
  }
  if (type === "human" || type === "user") {
    return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessage(rest);
  } else if (type === "ai" || type === "assistant") {
    var _rest = rest,
      rawToolCalls = _rest.tool_calls,
      other = _objectWithoutProperties(_rest, _excluded2);
    if (!Array.isArray(rawToolCalls)) {
      return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage(rest);
    }
    var tool_calls = rawToolCalls.map(_coerceToolCall);
    return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage(_objectSpread(_objectSpread({}, other), {}, {
      tool_calls: tool_calls
    }));
  } else if (type === "system") {
    return new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessage(rest);
  } else if (type === "tool" && "tool_call_id" in rest) {
    return new _tool_js__WEBPACK_IMPORTED_MODULE_8__.ToolMessage(_objectSpread(_objectSpread({}, rest), {}, {
      content: rest.content,
      tool_call_id: rest.tool_call_id,
      name: rest.name
    }));
  } else {
    var error = (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_0__.addLangChainErrorFields)(new Error("Unable to coerce message from array: only human, AI, system, or tool message coercion is currently supported.\n\nReceived: ".concat(JSON.stringify(params, null, 2))), "MESSAGE_COERCION_FAILURE");
    throw error;
  }
}
function coerceMessageLikeToMessage(messageLike) {
  if (typeof messageLike === "string") {
    return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessage(messageLike);
  } else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_3__.isBaseMessage)(messageLike)) {
    return messageLike;
  }
  if (Array.isArray(messageLike)) {
    var _messageLike = _slicedToArray(messageLike, 2),
      type = _messageLike[0],
      content = _messageLike[1];
    return _constructMessageFromParams({
      type: type,
      content: content
    });
  } else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_3__._isMessageFieldWithRole)(messageLike)) {
    var _type = messageLike.role,
      rest = _objectWithoutProperties(messageLike, _excluded3);
    return _constructMessageFromParams(_objectSpread(_objectSpread({}, rest), {}, {
      type: _type
    }));
  } else {
    return _constructMessageFromParams(messageLike);
  }
}
/**
 * This function is used by memory classes to get a string representation
 * of the chat message history, based on the message content and role.
 */
function getBufferString(messages) {
  var humanPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Human";
  var aiPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "AI";
  var string_messages = [];
  var _iterator = _createForOfIteratorHelper(messages),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var m = _step.value;
      var role = void 0;
      if (m._getType() === "human") {
        role = humanPrefix;
      } else if (m._getType() === "ai") {
        role = aiPrefix;
      } else if (m._getType() === "system") {
        role = "System";
      } else if (m._getType() === "function") {
        role = "Function";
      } else if (m._getType() === "tool") {
        role = "Tool";
      } else if (m._getType() === "generic") {
        role = m.role;
      } else {
        throw new Error("Got unsupported message type: ".concat(m._getType()));
      }
      var nameStr = m.name ? "".concat(m.name, ", ") : "";
      var readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
      string_messages.push("".concat(role, ": ").concat(nameStr).concat(readableContent));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return string_messages.join("\n");
}
/**
 * Maps messages from an older format (V1) to the current `StoredMessage`
 * format. If the message is already in the `StoredMessage` format, it is
 * returned as is. Otherwise, it transforms the V1 message into a
 * `StoredMessage`. This function is important for maintaining
 * compatibility with older message formats.
 */
function mapV1MessageToStoredMessage(message) {
  // TODO: Remove this mapper when we deprecate the old message format.
  if (message.data !== undefined) {
    return message;
  } else {
    var v1Message = message;
    return {
      type: v1Message.type,
      data: {
        content: v1Message.text,
        role: v1Message.role,
        name: undefined,
        tool_call_id: undefined
      }
    };
  }
}
function mapStoredMessageToChatMessage(message) {
  var storedMessage = mapV1MessageToStoredMessage(message);
  switch (storedMessage.type) {
    case "human":
      return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessage(storedMessage.data);
    case "ai":
      return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage(storedMessage.data);
    case "system":
      return new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessage(storedMessage.data);
    case "function":
      if (storedMessage.data.name === undefined) {
        throw new Error("Name must be defined for function messages");
      }
      return new _function_js__WEBPACK_IMPORTED_MODULE_5__.FunctionMessage(storedMessage.data);
    case "tool":
      if (storedMessage.data.tool_call_id === undefined) {
        throw new Error("Tool call ID must be defined for tool messages");
      }
      return new _tool_js__WEBPACK_IMPORTED_MODULE_8__.ToolMessage(storedMessage.data);
    case "generic":
      {
        if (storedMessage.data.role === undefined) {
          throw new Error("Role must be defined for chat messages");
        }
        return new _chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessage(storedMessage.data);
      }
    default:
      throw new Error("Got unexpected type: ".concat(storedMessage.type));
  }
}
/**
 * Transforms an array of `StoredMessage` instances into an array of
 * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`
 * function to ensure all messages are in the `StoredMessage` format, then
 * creates new instances of the appropriate `BaseMessage` subclass based
 * on the type of each message. This function is used to prepare stored
 * messages for use in a chat context.
 */
function mapStoredMessagesToChatMessages(messages) {
  return messages.map(mapStoredMessageToChatMessage);
}
/**
 * Transforms an array of `BaseMessage` instances into an array of
 * `StoredMessage` instances. It does this by calling the `toDict` method
 * on each `BaseMessage`, which returns a `StoredMessage`. This function
 * is used to prepare chat messages for storage.
 */
function mapChatMessagesToStoredMessages(messages) {
  return messages.map(function (message) {
    return message.toDict();
  });
}
function convertToChunk(message) {
  var type = message._getType();
  if (type === "human") {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessageChunk(_objectSpread({}, message));
  } else if (type === "ai") {
    var aiChunkFields = _objectSpread({}, message);
    if ("tool_calls" in aiChunkFields) {
      var _aiChunkFields$tool_c;
      aiChunkFields = _objectSpread(_objectSpread({}, aiChunkFields), {}, {
        tool_call_chunks: (_aiChunkFields$tool_c = aiChunkFields.tool_calls) === null || _aiChunkFields$tool_c === void 0 ? void 0 : _aiChunkFields$tool_c.map(function (tc) {
          return _objectSpread(_objectSpread({}, tc), {}, {
            type: "tool_call_chunk",
            index: undefined,
            args: JSON.stringify(tc.args)
          });
        })
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessageChunk(_objectSpread({}, aiChunkFields));
  } else if (type === "system") {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessageChunk(_objectSpread({}, message));
  } else if (type === "function") {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new _function_js__WEBPACK_IMPORTED_MODULE_5__.FunctionMessageChunk(_objectSpread({}, message));
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
  } else if (_chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessage.isInstance(message)) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new _chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessageChunk(_objectSpread({}, message));
  } else {
    throw new Error("Unknown message type.");
  }
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/outputs.js":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/outputs.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChatGenerationChunk: () => (/* binding */ ChatGenerationChunk),
/* harmony export */   GenerationChunk: () => (/* binding */ GenerationChunk),
/* harmony export */   RUN_KEY: () => (/* binding */ RUN_KEY)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var RUN_KEY = "__run";
/**
 * Chunk of a single generation. Used for streaming.
 */
var GenerationChunk = /*#__PURE__*/function () {
  function GenerationChunk(fields) {
    _classCallCheck(this, GenerationChunk);
    Object.defineProperty(this, "text", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.defineProperty(this, "generationInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.text = fields.text;
    this.generationInfo = fields.generationInfo;
  }
  return _createClass(GenerationChunk, [{
    key: "concat",
    value: function concat(chunk) {
      return new GenerationChunk({
        text: this.text + chunk.text,
        generationInfo: _objectSpread(_objectSpread({}, this.generationInfo), chunk.generationInfo)
      });
    }
  }]);
}();
var ChatGenerationChunk = /*#__PURE__*/function (_GenerationChunk) {
  function ChatGenerationChunk(fields) {
    var _this;
    _classCallCheck(this, ChatGenerationChunk);
    _this = _callSuper(this, ChatGenerationChunk, [fields]);
    Object.defineProperty(_this, "message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.message = fields.message;
    return _this;
  }
  _inherits(ChatGenerationChunk, _GenerationChunk);
  return _createClass(ChatGenerationChunk, [{
    key: "concat",
    value: function concat(chunk) {
      return new ChatGenerationChunk({
        text: this.text + chunk.text,
        generationInfo: _objectSpread(_objectSpread({}, this.generationInfo), chunk.generationInfo),
        message: this.message.concat(chunk.message)
      });
    }
  }]);
}(GenerationChunk);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/retrievers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/retrievers/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseRetriever: () => (/* binding */ BaseRetriever)
/* harmony export */ });
/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/manager.js */ "./node_modules/@langchain/core/dist/callbacks/manager.js");
/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runnables/base.js */ "./node_modules/@langchain/core/dist/runnables/base.js");
/* harmony import */ var _runnables_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runnables/config.js */ "./node_modules/@langchain/core/dist/runnables/config.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



/**
 * Abstract base class for a document retrieval system, designed to
 * process string queries and return the most relevant documents from a source.
 *
 * `BaseRetriever` provides common properties and methods for derived retrievers,
 * such as callbacks, tagging, and verbose logging. Custom retrieval systems
 * should extend this class and implement `_getRelevantDocuments` to define
 * the specific retrieval logic.
 *
 * @template Metadata - The type of metadata associated with each document,
 *                      defaulting to `Record<string, any>`.
 */
var BaseRetriever = /*#__PURE__*/function (_Runnable) {
  /**
   * Constructs a new `BaseRetriever` instance with optional configuration fields.
   *
   * @param fields - Optional input configuration that can include `callbacks`,
   *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.
   */
  function BaseRetriever(fields) {
    var _fields$tags, _fields$metadata, _fields$verbose;
    var _this;
    _classCallCheck(this, BaseRetriever);
    _this = _callSuper(this, BaseRetriever, [fields]);
    /**
     * Optional callbacks to handle various events in the retrieval process.
     */
    Object.defineProperty(_this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Tags to label or categorize the retrieval operation.
     */
    Object.defineProperty(_this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Metadata to provide additional context or information about the retrieval
     * operation.
     */
    Object.defineProperty(_this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * If set to `true`, enables verbose logging for the retrieval process.
     */
    Object.defineProperty(_this, "verbose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.callbacks = fields === null || fields === void 0 ? void 0 : fields.callbacks;
    _this.tags = (_fields$tags = fields === null || fields === void 0 ? void 0 : fields.tags) !== null && _fields$tags !== void 0 ? _fields$tags : [];
    _this.metadata = (_fields$metadata = fields === null || fields === void 0 ? void 0 : fields.metadata) !== null && _fields$metadata !== void 0 ? _fields$metadata : {};
    _this.verbose = (_fields$verbose = fields === null || fields === void 0 ? void 0 : fields.verbose) !== null && _fields$verbose !== void 0 ? _fields$verbose : false;
    return _this;
  }
  /**
   * TODO: This should be an abstract method, but we'd like to avoid breaking
   * changes to people currently using subclassed custom retrievers.
   * Change it on next major release.
   */
  /**
   * Placeholder method for retrieving relevant documents based on a query.
   *
   * This method is intended to be implemented by subclasses and will be
   * converted to an abstract method in the next major release. Currently, it
   * throws an error if not implemented, ensuring that custom retrievers define
   * the specific retrieval logic.
   *
   * @param _query - The query string used to search for relevant documents.
   * @param _callbacks - (optional) Callback manager for managing callbacks
   *                     during retrieval.
   * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.
   * @throws {Error} Throws an error indicating the method is not implemented.
   */
  _inherits(BaseRetriever, _Runnable);
  return _createClass(BaseRetriever, [{
    key: "_getRelevantDocuments",
    value: function _getRelevantDocuments(_query, _callbacks) {
      throw new Error("Not implemented!");
    }
    /**
     * Executes a retrieval operation.
     *
     * @param input - The query string used to search for relevant documents.
     * @param options - (optional) Configuration options for the retrieval run,
     *                  which may include callbacks, tags, and metadata.
     * @returns A promise that resolves to an array of `DocumentInterface` instances
     *          representing the most relevant documents to the query.
     */
  }, {
    key: "invoke",
    value: (function () {
      var _invoke = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, options) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.getRelevantDocuments(input, (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureConfig)(options)));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function invoke(_x, _x2) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
    /**
     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
     *
     * Main method used to retrieve relevant documents. It takes a query
     * string and an optional configuration object, and returns a promise that
     * resolves to an array of `Document` objects. This method handles the
     * retrieval process, including starting and ending callbacks, and error
     * handling.
     * @param query The query string to retrieve relevant documents for.
     * @param config Optional configuration object for the retrieval process.
     * @returns A promise that resolves to an array of `Document` objects.
     */
    )
  }, {
    key: "getRelevantDocuments",
    value: (function () {
      var _getRelevantDocuments2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(query, config) {
        var parsedConfig, callbackManager_, runManager, results;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              parsedConfig = (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureConfig)((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.parseCallbackConfigArg)(config));
              _context2.next = 3;
              return _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, {
                verbose: this.verbose
              });
            case 3:
              callbackManager_ = _context2.sent;
              _context2.next = 6;
              return callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleRetrieverStart(this.toJSON(), query, parsedConfig.runId, undefined, undefined, undefined, parsedConfig.runName);
            case 6:
              runManager = _context2.sent;
              _context2.prev = 7;
              _context2.next = 10;
              return this._getRelevantDocuments(query, runManager);
            case 10:
              results = _context2.sent;
              _context2.next = 13;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleRetrieverEnd(results);
            case 13:
              return _context2.abrupt("return", results);
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](7);
              _context2.next = 20;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleRetrieverError(_context2.t0);
            case 20:
              throw _context2.t0;
            case 21:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[7, 16]]);
      }));
      function getRelevantDocuments(_x3, _x4) {
        return _getRelevantDocuments2.apply(this, arguments);
      }
      return getRelevantDocuments;
    }())
  }]);
}(_runnables_base_js__WEBPACK_IMPORTED_MODULE_1__.Runnable);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Runnable: () => (/* binding */ Runnable),
/* harmony export */   RunnableAssign: () => (/* binding */ RunnableAssign),
/* harmony export */   RunnableBinding: () => (/* binding */ RunnableBinding),
/* harmony export */   RunnableEach: () => (/* binding */ RunnableEach),
/* harmony export */   RunnableLambda: () => (/* binding */ RunnableLambda),
/* harmony export */   RunnableMap: () => (/* binding */ RunnableMap),
/* harmony export */   RunnableParallel: () => (/* binding */ RunnableParallel),
/* harmony export */   RunnablePick: () => (/* binding */ RunnablePick),
/* harmony export */   RunnableRetry: () => (/* binding */ RunnableRetry),
/* harmony export */   RunnableSequence: () => (/* binding */ RunnableSequence),
/* harmony export */   RunnableToolLike: () => (/* binding */ RunnableToolLike),
/* harmony export */   RunnableTraceable: () => (/* binding */ RunnableTraceable),
/* harmony export */   RunnableWithFallbacks: () => (/* binding */ RunnableWithFallbacks),
/* harmony export */   _coerceToDict: () => (/* binding */ _coerceToDict),
/* harmony export */   _coerceToRunnable: () => (/* binding */ _coerceToRunnable),
/* harmony export */   convertRunnableToTool: () => (/* binding */ convertRunnableToTool)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ "./node_modules/@langchain/core/node_modules/p-retry/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langsmith/singletons/traceable */ "./node_modules/langsmith/singletons/traceable.js");
/* harmony import */ var _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tracers/log_stream.js */ "./node_modules/@langchain/core/dist/tracers/log_stream.js");
/* harmony import */ var _tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tracers/event_stream.js */ "./node_modules/@langchain/core/dist/tracers/event_stream.js");
/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../load/serializable.js */ "./node_modules/@langchain/core/dist/load/serializable.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/@langchain/core/dist/utils/stream.js");
/* harmony import */ var _utils_signal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/signal.js */ "./node_modules/@langchain/core/dist/utils/signal.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./config.js */ "./node_modules/@langchain/core/dist/runnables/config.js");
/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/async_caller.js */ "./node_modules/@langchain/core/dist/utils/async_caller.js");
/* harmony import */ var _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tracers/root_listener.js */ "./node_modules/@langchain/core/dist/tracers/root_listener.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@langchain/core/dist/runnables/utils.js");
/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../singletons/index.js */ "./node_modules/@langchain/core/dist/singletons/index.js");
/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./graph.js */ "./node_modules/@langchain/core/dist/runnables/graph.js");
/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./wrappers.js */ "./node_modules/@langchain/core/dist/runnables/wrappers.js");
/* harmony import */ var _iter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./iter.js */ "./node_modules/@langchain/core/dist/runnables/iter.js");
/* harmony import */ var _tools_utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../tools/utils.js */ "./node_modules/@langchain/core/dist/tools/utils.js");
var _excluded = ["runId"],
  _excluded2 = ["runId"],
  _excluded3 = ["runId"];
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _asyncGeneratorDelegate(t) { var e = {}, n = !1; function pump(e, r) { return n = !0, r = new Promise(function (n) { n(t[e](r)); }), { done: !1, value: new _OverloadYield(r, 1) }; } return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, e.next = function (t) { return n ? (n = !1, t) : pump("next", t); }, "function" == typeof t["throw"] && (e["throw"] = function (t) { if (n) throw n = !1, t; return pump("throw", t); }), "function" == typeof t["return"] && (e["return"] = function (t) { return n ? (n = !1, t) : pump("return", t); }), e; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(r) { var n = this.s["return"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, "throw": function _throw(r) { var n = this.s["return"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _OverloadYield(e, d) { this.v = e, this.k = d; }


















// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) &&
  // eslint-disable-next-line no-instanceof/no-instanceof
  !(value instanceof Date) && _typeof(value) === "object" ? value : _defineProperty({}, defaultKey, value);
}
/**
 * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or
 * transformed.
 */
var Runnable = /*#__PURE__*/function (_Serializable) {
  function Runnable() {
    var _this17;
    _classCallCheck(this, Runnable);
    _this17 = _callSuper(this, Runnable, arguments);
    Object.defineProperty(_this17, "lc_runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this17, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    return _this17;
  }
  _inherits(Runnable, _Serializable);
  return _createClass(Runnable, [{
    key: "getName",
    value: function getName(suffix) {
      var _ref3, _this$name;
      var name = // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (_ref3 = (_this$name = this.name) !== null && _this$name !== void 0 ? _this$name : this.constructor.lc_name()) !== null && _ref3 !== void 0 ? _ref3 : this.constructor.name;
      return suffix ? "".concat(name).concat(suffix) : name;
    }
    /**
     * Bind arguments to a Runnable, returning a new Runnable.
     * @param kwargs
     * @returns A new RunnableBinding that, when invoked, will apply the bound args.
     */
  }, {
    key: "bind",
    value: function bind(kwargs) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableBinding({
        bound: this,
        kwargs: kwargs,
        config: {}
      });
    }
    /**
     * Return a new Runnable that maps a list of inputs to a list of outputs,
     * by calling invoke() with each input.
     */
  }, {
    key: "map",
    value: function map() {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableEach({
        bound: this
      });
    }
    /**
     * Add retry logic to an existing runnable.
     * @param kwargs
     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
     */
  }, {
    key: "withRetry",
    value: function withRetry(fields) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableRetry(_objectSpread({
        bound: this,
        kwargs: {},
        config: {},
        maxAttemptNumber: fields === null || fields === void 0 ? void 0 : fields.stopAfterAttempt
      }, fields));
    }
    /**
     * Bind config to a Runnable, returning a new Runnable.
     * @param config New configuration parameters to attach to the new runnable.
     * @returns A new RunnableBinding with a config matching what's passed.
     */
  }, {
    key: "withConfig",
    value: function withConfig(config) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableBinding({
        bound: this,
        config: config,
        kwargs: {}
      });
    }
    /**
     * Create a new runnable from the current one that will try invoking
     * other passed fallback runnables if the initial invocation fails.
     * @param fields.fallbacks Other runnables to call if the runnable errors.
     * @returns A new RunnableWithFallbacks.
     */
  }, {
    key: "withFallbacks",
    value: function withFallbacks(fields) {
      var fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableWithFallbacks({
        runnable: this,
        fallbacks: fallbacks
      });
    }
  }, {
    key: "_getOptionsList",
    value: function _getOptionsList(options) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (Array.isArray(options) && options.length !== length) {
        throw new Error("Passed \"options\" must be an array with the same length as the inputs, but got ".concat(options.length, " options for ").concat(length, " inputs"));
      }
      if (Array.isArray(options)) {
        return options.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig);
      }
      if (length > 1 && !Array.isArray(options) && options.runId) {
        console.warn("Provided runId will be used only for the first element of the batch.");
        var subsequent = Object.fromEntries(Object.entries(options).filter(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 1),
            key = _ref5[0];
          return key !== "runId";
        }));
        return Array.from({
          length: length
        }, function (_, i) {
          return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(i === 0 ? options : subsequent);
        });
      }
      return Array.from({
        length: length
      }, function () {
        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
      });
    }
  }, {
    key: "batch",
    value: function () {
      var _batch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(inputs, options, batchOptions) {
        var _configList$0$maxConc,
          _configList$,
          _this18 = this;
        var configList, maxConcurrency, caller, batchCalls;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);
              maxConcurrency = (_configList$0$maxConc = (_configList$ = configList[0]) === null || _configList$ === void 0 ? void 0 : _configList$.maxConcurrency) !== null && _configList$0$maxConc !== void 0 ? _configList$0$maxConc : batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.maxConcurrency;
              caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_8__.AsyncCaller({
                maxConcurrency: maxConcurrency,
                onFailedAttempt: function onFailedAttempt(e) {
                  throw e;
                }
              });
              batchCalls = inputs.map(function (input, i) {
                return caller.call(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  var result;
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        _context.next = 3;
                        return _this18.invoke(input, configList[i]);
                      case 3:
                        result = _context.sent;
                        return _context.abrupt("return", result);
                      case 7:
                        _context.prev = 7;
                        _context.t0 = _context["catch"](0);
                        if (!(batchOptions !== null && batchOptions !== void 0 && batchOptions.returnExceptions)) {
                          _context.next = 11;
                          break;
                        }
                        return _context.abrupt("return", _context.t0);
                      case 11:
                        throw _context.t0;
                      case 12:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee, null, [[0, 7]]);
                })));
              });
              return _context2.abrupt("return", Promise.all(batchCalls));
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function batch(_x, _x2, _x3) {
        return _batch.apply(this, arguments);
      }
      return batch;
    }()
    /**
     * Default streaming implementation.
     * Subclasses should override this method if they support streaming output.
     * @param input
     * @param options
     */
  }, {
    key: "_streamIterator",
    value: function _streamIterator(input, options) {
      var _this = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _this.invoke(input, options);
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
    /**
     * Stream output in chunks.
     * @param input
     * @param options
     * @returns A readable stream that is also an iterable.
     */
  }, {
    key: "stream",
    value: (function () {
      var _stream = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(input, options) {
        var config, wrappedGenerator;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              // Buffer the first streamed chunk to allow for initial errors
              // to surface immediately.
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({
                generator: this._streamIterator(input, config),
                config: config
              });
              _context4.next = 4;
              return wrappedGenerator.setup;
            case 4:
              return _context4.abrupt("return", _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator));
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function stream(_x4, _x5) {
        return _stream.apply(this, arguments);
      }
      return stream;
    }())
  }, {
    key: "_separateRunnableConfigFromCallOptions",
    value: function _separateRunnableConfigFromCallOptions(options) {
      var runnableConfig;
      if (options === undefined) {
        runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
      } else {
        runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)({
          callbacks: options.callbacks,
          tags: options.tags,
          metadata: options.metadata,
          runName: options.runName,
          configurable: options.configurable,
          recursionLimit: options.recursionLimit,
          maxConcurrency: options.maxConcurrency,
          runId: options.runId,
          timeout: options.timeout,
          signal: options.signal
        });
      }
      var callOptions = _objectSpread({}, options);
      delete callOptions.callbacks;
      delete callOptions.tags;
      delete callOptions.metadata;
      delete callOptions.runName;
      delete callOptions.configurable;
      delete callOptions.recursionLimit;
      delete callOptions.maxConcurrency;
      delete callOptions.runId;
      delete callOptions.timeout;
      delete callOptions.signal;
      return [runnableConfig, callOptions];
    }
  }, {
    key: "_callWithConfig",
    value: function () {
      var _callWithConfig2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(func, input, options) {
        var _config$runName;
        var config, callbackManager_, runManager, output, promise;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              _context5.next = 3;
              return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);
            case 3:
              callbackManager_ = _context5.sent;
              _context5.next = 6;
              return callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config.runId, config === null || config === void 0 ? void 0 : config.runType, undefined, undefined, (_config$runName = config === null || config === void 0 ? void 0 : config.runName) !== null && _config$runName !== void 0 ? _config$runName : this.getName());
            case 6:
              runManager = _context5.sent;
              delete config.runId;
              _context5.prev = 8;
              promise = func.call(this, input, config, runManager);
              _context5.next = 12;
              return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options === null || options === void 0 ? void 0 : options.signal);
            case 12:
              output = _context5.sent;
              _context5.next = 20;
              break;
            case 15:
              _context5.prev = 15;
              _context5.t0 = _context5["catch"](8);
              _context5.next = 19;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context5.t0);
            case 19:
              throw _context5.t0;
            case 20:
              _context5.next = 22;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output"));
            case 22:
              return _context5.abrupt("return", output);
            case 23:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[8, 15]]);
      }));
      function _callWithConfig(_x6, _x7, _x8) {
        return _callWithConfig2.apply(this, arguments);
      }
      return _callWithConfig;
    }()
    /**
     * Internal method that handles batching and configuration for a runnable
     * It takes a function, input values, and optional configuration, and
     * returns a promise that resolves to the output values.
     * @param func The function to be executed for each input value.
     * @param input The input values to be processed.
     * @param config Optional configuration for the function execution.
     * @returns A promise that resolves to the output values.
     */
  }, {
    key: "_batchWithConfig",
    value: (function () {
      var _batchWithConfig2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(func, inputs, options, batchOptions) {
        var _this19 = this;
        var optionsList, callbackManagers, runManagers, outputs, _optionsList$, promise;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              optionsList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);
              _context7.next = 3;
              return Promise.all(optionsList.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig));
            case 3:
              callbackManagers = _context7.sent;
              _context7.next = 6;
              return Promise.all(callbackManagers.map(/*#__PURE__*/function () {
                var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(callbackManager, i) {
                  var _optionsList$i$runNam;
                  var handleStartRes;
                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(_this19.toJSON(), _coerceToDict(inputs[i], "input"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, (_optionsList$i$runNam = optionsList[i].runName) !== null && _optionsList$i$runNam !== void 0 ? _optionsList$i$runNam : _this19.getName());
                      case 2:
                        handleStartRes = _context6.sent;
                        delete optionsList[i].runId;
                        return _context6.abrupt("return", handleStartRes);
                      case 5:
                      case "end":
                        return _context6.stop();
                    }
                  }, _callee6);
                }));
                return function (_x13, _x14) {
                  return _ref7.apply(this, arguments);
                };
              }()));
            case 6:
              runManagers = _context7.sent;
              _context7.prev = 7;
              promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
              _context7.next = 11;
              return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, optionsList === null || optionsList === void 0 || (_optionsList$ = optionsList[0]) === null || _optionsList$ === void 0 ? void 0 : _optionsList$.signal);
            case 11:
              outputs = _context7.sent;
              _context7.next = 19;
              break;
            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](7);
              _context7.next = 18;
              return Promise.all(runManagers.map(function (runManager) {
                return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context7.t0);
              }));
            case 18:
              throw _context7.t0;
            case 19:
              _context7.next = 21;
              return Promise.all(runManagers.map(function (runManager) {
                return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs, "output"));
              }));
            case 21:
              return _context7.abrupt("return", outputs);
            case 22:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[7, 14]]);
      }));
      function _batchWithConfig(_x9, _x10, _x11, _x12) {
        return _batchWithConfig2.apply(this, arguments);
      }
      return _batchWithConfig;
    }()
    /**
     * Helper method to transform an Iterator of Input values into an Iterator of
     * Output values, with callbacks.
     * Use this to implement `stream()` or `transform()` in Runnable subclasses.
     */
    )
  }, {
    key: "_transformStreamWithConfig",
    value: function _transformStreamWithConfig(inputGenerator, transformer, options) {
      var _this2 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var _runManager4, _finalOutput;
        var finalInput, finalInputSupported, finalOutput, finalOutputSupported, config, callbackManager_, wrapInputForTracing, _wrapInputForTracing, runManager, _runManager, _runManager2, pipe, streamEventsHandler, iterator, streamLogHandler, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, _runManager3;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _wrapInputForTracing = function _wrapInputForTracing3() {
                _wrapInputForTracing = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                  var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk;
                  return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                    while (1) switch (_context8.prev = _context8.next) {
                      case 0:
                        _iteratorAbruptCompletion2 = false;
                        _didIteratorError2 = false;
                        _context8.prev = 2;
                        _iterator2 = _asyncIterator(inputGenerator);
                      case 4:
                        _context8.next = 6;
                        return _awaitAsyncGenerator(_iterator2.next());
                      case 6:
                        if (!(_iteratorAbruptCompletion2 = !(_step2 = _context8.sent).done)) {
                          _context8.next = 14;
                          break;
                        }
                        chunk = _step2.value;
                        if (finalInputSupported) {
                          if (finalInput === undefined) {
                            finalInput = chunk;
                          } else {
                            try {
                              // eslint-disable-next-line @typescript-eslint/no-explicit-any
                              finalInput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalInput, chunk);
                            } catch (_unused) {
                              finalInput = undefined;
                              finalInputSupported = false;
                            }
                          }
                        }
                        _context8.next = 11;
                        return chunk;
                      case 11:
                        _iteratorAbruptCompletion2 = false;
                        _context8.next = 4;
                        break;
                      case 14:
                        _context8.next = 20;
                        break;
                      case 16:
                        _context8.prev = 16;
                        _context8.t0 = _context8["catch"](2);
                        _didIteratorError2 = true;
                        _iteratorError2 = _context8.t0;
                      case 20:
                        _context8.prev = 20;
                        _context8.prev = 21;
                        if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                          _context8.next = 25;
                          break;
                        }
                        _context8.next = 25;
                        return _awaitAsyncGenerator(_iterator2["return"]());
                      case 25:
                        _context8.prev = 25;
                        if (!_didIteratorError2) {
                          _context8.next = 28;
                          break;
                        }
                        throw _iteratorError2;
                      case 28:
                        return _context8.finish(25);
                      case 29:
                        return _context8.finish(20);
                      case 30:
                      case "end":
                        return _context8.stop();
                    }
                  }, _callee8, null, [[2, 16, 20, 30], [21,, 25, 29]]);
                }));
                return _wrapInputForTracing.apply(this, arguments);
              };
              wrapInputForTracing = function _wrapInputForTracing2() {
                return _wrapInputForTracing.apply(this, arguments);
              };
              finalInputSupported = true;
              finalOutputSupported = true;
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              _context10.next = 7;
              return _awaitAsyncGenerator((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config));
            case 7:
              callbackManager_ = _context10.sent;
              _context10.prev = 8;
              _context10.next = 11;
              return _awaitAsyncGenerator((0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.pipeGeneratorWithSetup)(transformer.bind(_this2), wrapInputForTracing(), /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                var _config$runName2;
                return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                  while (1) switch (_context9.prev = _context9.next) {
                    case 0:
                      return _context9.abrupt("return", callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(_this2.toJSON(), {
                        input: ""
                      }, config.runId, config.runType, undefined, undefined, (_config$runName2 = config.runName) !== null && _config$runName2 !== void 0 ? _config$runName2 : _this2.getName()));
                    case 1:
                    case "end":
                      return _context9.stop();
                  }
                }, _callee9);
              })), options === null || options === void 0 ? void 0 : options.signal, config));
            case 11:
              pipe = _context10.sent;
              delete config.runId;
              runManager = pipe.setup;
              streamEventsHandler = (_runManager = runManager) === null || _runManager === void 0 ? void 0 : _runManager.handlers.find(_tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__.isStreamEventsHandler);
              iterator = pipe.output;
              if (streamEventsHandler !== undefined && runManager !== undefined) {
                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
              }
              streamLogHandler = (_runManager2 = runManager) === null || _runManager2 === void 0 ? void 0 : _runManager2.handlers.find(_tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.isLogStreamHandler);
              if (streamLogHandler !== undefined && runManager !== undefined) {
                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
              }
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context10.prev = 21;
              _iterator = _asyncIterator(iterator);
            case 23:
              _context10.next = 25;
              return _awaitAsyncGenerator(_iterator.next());
            case 25:
              if (!(_iteratorAbruptCompletion = !(_step = _context10.sent).done)) {
                _context10.next = 33;
                break;
              }
              chunk = _step.value;
              _context10.next = 29;
              return chunk;
            case 29:
              if (finalOutputSupported) {
                if (finalOutput === undefined) {
                  finalOutput = chunk;
                } else {
                  try {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);
                  } catch (_unused2) {
                    finalOutput = undefined;
                    finalOutputSupported = false;
                  }
                }
              }
            case 30:
              _iteratorAbruptCompletion = false;
              _context10.next = 23;
              break;
            case 33:
              _context10.next = 39;
              break;
            case 35:
              _context10.prev = 35;
              _context10.t0 = _context10["catch"](21);
              _didIteratorError = true;
              _iteratorError = _context10.t0;
            case 39:
              _context10.prev = 39;
              _context10.prev = 40;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context10.next = 44;
                break;
              }
              _context10.next = 44;
              return _awaitAsyncGenerator(_iterator["return"]());
            case 44:
              _context10.prev = 44;
              if (!_didIteratorError) {
                _context10.next = 47;
                break;
              }
              throw _iteratorError;
            case 47:
              return _context10.finish(44);
            case 48:
              return _context10.finish(39);
            case 49:
              _context10.next = 56;
              break;
            case 51:
              _context10.prev = 51;
              _context10.t1 = _context10["catch"](8);
              _context10.next = 55;
              return _awaitAsyncGenerator((_runManager3 = runManager) === null || _runManager3 === void 0 ? void 0 : _runManager3.handleChainError(_context10.t1, undefined, undefined, undefined, {
                inputs: _coerceToDict(finalInput, "input")
              }));
            case 55:
              throw _context10.t1;
            case 56:
              _context10.next = 58;
              return _awaitAsyncGenerator((_runManager4 = runManager) === null || _runManager4 === void 0 ? void 0 : _runManager4.handleChainEnd((_finalOutput = finalOutput) !== null && _finalOutput !== void 0 ? _finalOutput : {}, undefined, undefined, undefined, {
                inputs: _coerceToDict(finalInput, "input")
              }));
            case 58:
            case "end":
              return _context10.stop();
          }
        }, _callee10, null, [[8, 51], [21, 35, 39, 49], [40,, 44, 48]]);
      }))();
    }
  }, {
    key: "getGraph",
    value: function getGraph(_) {
      var graph = new _graph_js__WEBPACK_IMPORTED_MODULE_12__.Graph();
      // TODO: Add input schema for runnables
      var inputNode = graph.addNode({
        name: "".concat(this.getName(), "Input"),
        schema: zod__WEBPACK_IMPORTED_MODULE_16__.z.any()
      });
      var runnableNode = graph.addNode(this);
      // TODO: Add output schemas for runnables
      var outputNode = graph.addNode({
        name: "".concat(this.getName(), "Output"),
        schema: zod__WEBPACK_IMPORTED_MODULE_16__.z.any()
      });
      graph.addEdge(inputNode, runnableNode);
      graph.addEdge(runnableNode, outputNode);
      return graph;
    }
    /**
     * Create a new runnable sequence that runs each individual runnable in series,
     * piping the output of one runnable into another runnable or runnable-like.
     * @param coerceable A runnable, function, or object whose values are functions or runnables.
     * @returns A new runnable sequence.
     */
  }, {
    key: "pipe",
    value: function pipe(coerceable) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableSequence({
        first: this,
        last: _coerceToRunnable(coerceable)
      });
    }
    /**
     * Pick keys from the dict output of this runnable. Returns a new runnable.
     */
  }, {
    key: "pick",
    value: function pick(keys) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return this.pipe(new RunnablePick(keys));
    }
    /**
     * Assigns new fields to the dict output of this runnable. Returns a new runnable.
     */
  }, {
    key: "assign",
    value: function assign(mapping) {
      return this.pipe(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new RunnableAssign(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new RunnableMap({
        steps: mapping
      })));
    }
    /**
     * Default implementation of transform, which buffers input and then calls stream.
     * Subclasses should override this method if they can start producing output while
     * input is still being generated.
     * @param generator
     * @param options
     */
  }, {
    key: "transform",
    value: function transform(generator, options) {
      var _this3 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var finalChunk, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, chunk;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _iteratorAbruptCompletion3 = false;
              _didIteratorError3 = false;
              _context11.prev = 2;
              _iterator3 = _asyncIterator(generator);
            case 4:
              _context11.next = 6;
              return _awaitAsyncGenerator(_iterator3.next());
            case 6:
              if (!(_iteratorAbruptCompletion3 = !(_step3 = _context11.sent).done)) {
                _context11.next = 12;
                break;
              }
              chunk = _step3.value;
              if (finalChunk === undefined) {
                finalChunk = chunk;
              } else {
                // Make a best effort to gather, for any type that supports concat.
                // This method should throw an error if gathering fails.
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                finalChunk = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalChunk, chunk);
              }
            case 9:
              _iteratorAbruptCompletion3 = false;
              _context11.next = 4;
              break;
            case 12:
              _context11.next = 18;
              break;
            case 14:
              _context11.prev = 14;
              _context11.t0 = _context11["catch"](2);
              _didIteratorError3 = true;
              _iteratorError3 = _context11.t0;
            case 18:
              _context11.prev = 18;
              _context11.prev = 19;
              if (!(_iteratorAbruptCompletion3 && _iterator3["return"] != null)) {
                _context11.next = 23;
                break;
              }
              _context11.next = 23;
              return _awaitAsyncGenerator(_iterator3["return"]());
            case 23:
              _context11.prev = 23;
              if (!_didIteratorError3) {
                _context11.next = 26;
                break;
              }
              throw _iteratorError3;
            case 26:
              return _context11.finish(23);
            case 27:
              return _context11.finish(18);
            case 28:
              return _context11.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this3._streamIterator(finalChunk, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options))), _awaitAsyncGenerator), "t1", 29);
            case 29:
            case "end":
              return _context11.stop();
          }
        }, _callee11, null, [[2, 14, 18, 28], [19,, 23, 27]]);
      }))();
    }
    /**
     * Stream all output from a runnable, as reported to the callback system.
     * This includes all inner runs of LLMs, Retrievers, Tools, etc.
     * Output is streamed as Log objects, which include a list of
     * jsonpatch ops that describe how the state of the run has changed in each
     * step, and the final state of the run.
     * The jsonpatch ops can be applied in order to construct state.
     * @param input
     * @param options
     * @param streamOptions
     */
  }, {
    key: "streamLog",
    value: function streamLog(input, options, streamOptions) {
      var _this4 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var logStreamCallbackHandler, config;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler(_objectSpread(_objectSpread({}, streamOptions), {}, {
                autoClose: false,
                _schemaFormat: "original"
              }));
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              return _context12.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this4._streamLog(input, logStreamCallbackHandler, config)), _awaitAsyncGenerator), "t0", 3);
            case 3:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }))();
    }
  }, {
    key: "_streamLog",
    value: function _streamLog(input, logStreamCallbackHandler, config) {
      var _this5 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var callbacks, copiedCallbacks, runnableStreamPromise, consumeRunnableStream, _consumeRunnableStream, runnableStreamConsumePromise, _iteratorAbruptCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, log;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _consumeRunnableStream = function _consumeRunnableStrea2() {
                _consumeRunnableStream = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                  var runnableStream, _iteratorAbruptCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, chunk, patch;
                  return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                    while (1) switch (_context13.prev = _context13.next) {
                      case 0:
                        _context13.prev = 0;
                        _context13.next = 3;
                        return runnableStreamPromise;
                      case 3:
                        runnableStream = _context13.sent;
                        _iteratorAbruptCompletion5 = false;
                        _didIteratorError5 = false;
                        _context13.prev = 6;
                        _iterator5 = _asyncIterator(runnableStream);
                      case 8:
                        _context13.next = 10;
                        return _iterator5.next();
                      case 10:
                        if (!(_iteratorAbruptCompletion5 = !(_step5 = _context13.sent).done)) {
                          _context13.next = 18;
                          break;
                        }
                        chunk = _step5.value;
                        patch = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLogPatch({
                          ops: [{
                            op: "add",
                            path: "/streamed_output/-",
                            value: chunk
                          }]
                        });
                        _context13.next = 15;
                        return logStreamCallbackHandler.writer.write(patch);
                      case 15:
                        _iteratorAbruptCompletion5 = false;
                        _context13.next = 8;
                        break;
                      case 18:
                        _context13.next = 24;
                        break;
                      case 20:
                        _context13.prev = 20;
                        _context13.t0 = _context13["catch"](6);
                        _didIteratorError5 = true;
                        _iteratorError5 = _context13.t0;
                      case 24:
                        _context13.prev = 24;
                        _context13.prev = 25;
                        if (!(_iteratorAbruptCompletion5 && _iterator5["return"] != null)) {
                          _context13.next = 29;
                          break;
                        }
                        _context13.next = 29;
                        return _iterator5["return"]();
                      case 29:
                        _context13.prev = 29;
                        if (!_didIteratorError5) {
                          _context13.next = 32;
                          break;
                        }
                        throw _iteratorError5;
                      case 32:
                        return _context13.finish(29);
                      case 33:
                        return _context13.finish(24);
                      case 34:
                        _context13.prev = 34;
                        _context13.next = 37;
                        return logStreamCallbackHandler.writer.close();
                      case 37:
                        return _context13.finish(34);
                      case 38:
                      case "end":
                        return _context13.stop();
                    }
                  }, _callee13, null, [[0,, 34, 38], [6, 20, 24, 34], [25,, 29, 33]]);
                }));
                return _consumeRunnableStream.apply(this, arguments);
              };
              consumeRunnableStream = function _consumeRunnableStrea() {
                return _consumeRunnableStream.apply(this, arguments);
              };
              callbacks = config.callbacks;
              if (callbacks === undefined) {
                // eslint-disable-next-line no-param-reassign
                config.callbacks = [logStreamCallbackHandler];
              } else if (Array.isArray(callbacks)) {
                // eslint-disable-next-line no-param-reassign
                config.callbacks = callbacks.concat([logStreamCallbackHandler]);
              } else {
                copiedCallbacks = callbacks.copy();
                copiedCallbacks.addHandler(logStreamCallbackHandler, true);
                // eslint-disable-next-line no-param-reassign
                config.callbacks = copiedCallbacks;
              }
              runnableStreamPromise = _this5.stream(input, config);
              runnableStreamConsumePromise = consumeRunnableStream();
              _context14.prev = 6;
              _iteratorAbruptCompletion4 = false;
              _didIteratorError4 = false;
              _context14.prev = 9;
              _iterator4 = _asyncIterator(logStreamCallbackHandler);
            case 11:
              _context14.next = 13;
              return _awaitAsyncGenerator(_iterator4.next());
            case 13:
              if (!(_iteratorAbruptCompletion4 = !(_step4 = _context14.sent).done)) {
                _context14.next = 20;
                break;
              }
              log = _step4.value;
              _context14.next = 17;
              return log;
            case 17:
              _iteratorAbruptCompletion4 = false;
              _context14.next = 11;
              break;
            case 20:
              _context14.next = 26;
              break;
            case 22:
              _context14.prev = 22;
              _context14.t0 = _context14["catch"](9);
              _didIteratorError4 = true;
              _iteratorError4 = _context14.t0;
            case 26:
              _context14.prev = 26;
              _context14.prev = 27;
              if (!(_iteratorAbruptCompletion4 && _iterator4["return"] != null)) {
                _context14.next = 31;
                break;
              }
              _context14.next = 31;
              return _awaitAsyncGenerator(_iterator4["return"]());
            case 31:
              _context14.prev = 31;
              if (!_didIteratorError4) {
                _context14.next = 34;
                break;
              }
              throw _iteratorError4;
            case 34:
              return _context14.finish(31);
            case 35:
              return _context14.finish(26);
            case 36:
              _context14.prev = 36;
              _context14.next = 39;
              return _awaitAsyncGenerator(runnableStreamConsumePromise);
            case 39:
              return _context14.finish(36);
            case 40:
            case "end":
              return _context14.stop();
          }
        }, _callee14, null, [[6,, 36, 40], [9, 22, 26, 36], [27,, 31, 35]]);
      }))();
    }
  }, {
    key: "streamEvents",
    value: function streamEvents(input, options, streamOptions) {
      var stream;
      if (options.version === "v1") {
        stream = this._streamEventsV1(input, options, streamOptions);
      } else if (options.version === "v2") {
        stream = this._streamEventsV2(input, options, streamOptions);
      } else {
        throw new Error("Only versions \"v1\" and \"v2\" of the schema are currently supported.");
      }
      if (options.encoding === "text/event-stream") {
        return (0,_wrappers_js__WEBPACK_IMPORTED_MODULE_13__.convertToHttpEventStream)(stream);
      } else {
        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(stream);
      }
    }
  }, {
    key: "_streamEventsV2",
    value: function _streamEventsV2(input, options, streamOptions) {
      var _this6 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var _config$runId;
        var eventStreamer, config, runId, callbacks, copiedCallbacks, outerThis, consumeRunnableStream, _consumeRunnableStream2, runnableStreamConsumePromise, firstEventSent, firstEventRunId, _iteratorAbruptCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, event, _event$data;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _consumeRunnableStream2 = function _consumeRunnableStrea4() {
                _consumeRunnableStream2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                  var runnableStream, tappedStream, _iteratorAbruptCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _;
                  return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                    while (1) switch (_context15.prev = _context15.next) {
                      case 0:
                        _context15.prev = 0;
                        _context15.next = 3;
                        return outerThis.stream(input, config);
                      case 3:
                        runnableStream = _context15.sent;
                        tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream); // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        _iteratorAbruptCompletion7 = false;
                        _didIteratorError7 = false;
                        _context15.prev = 7;
                        _iterator7 = _asyncIterator(tappedStream);
                      case 9:
                        _context15.next = 11;
                        return _iterator7.next();
                      case 11:
                        if (!(_iteratorAbruptCompletion7 = !(_step7 = _context15.sent).done)) {
                          _context15.next = 16;
                          break;
                        }
                        _ = _step7.value;
                      case 13:
                        _iteratorAbruptCompletion7 = false;
                        _context15.next = 9;
                        break;
                      case 16:
                        _context15.next = 22;
                        break;
                      case 18:
                        _context15.prev = 18;
                        _context15.t0 = _context15["catch"](7);
                        _didIteratorError7 = true;
                        _iteratorError7 = _context15.t0;
                      case 22:
                        _context15.prev = 22;
                        _context15.prev = 23;
                        if (!(_iteratorAbruptCompletion7 && _iterator7["return"] != null)) {
                          _context15.next = 27;
                          break;
                        }
                        _context15.next = 27;
                        return _iterator7["return"]();
                      case 27:
                        _context15.prev = 27;
                        if (!_didIteratorError7) {
                          _context15.next = 30;
                          break;
                        }
                        throw _iteratorError7;
                      case 30:
                        return _context15.finish(27);
                      case 31:
                        return _context15.finish(22);
                      case 32:
                        _context15.prev = 32;
                        _context15.next = 35;
                        return eventStreamer.finish();
                      case 35:
                        return _context15.finish(32);
                      case 36:
                      case "end":
                        return _context15.stop();
                    }
                  }, _callee15, null, [[0,, 32, 36], [7, 18, 22, 32], [23,, 27, 31]]);
                }));
                return _consumeRunnableStream2.apply(this, arguments);
              };
              consumeRunnableStream = function _consumeRunnableStrea3() {
                return _consumeRunnableStream2.apply(this, arguments);
              };
              eventStreamer = new _tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__.EventStreamCallbackHandler(_objectSpread(_objectSpread({}, streamOptions), {}, {
                autoClose: false
              }));
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              runId = (_config$runId = config.runId) !== null && _config$runId !== void 0 ? _config$runId : (0,uuid__WEBPACK_IMPORTED_MODULE_17__["default"])();
              config.runId = runId;
              callbacks = config.callbacks;
              if (callbacks === undefined) {
                config.callbacks = [eventStreamer];
              } else if (Array.isArray(callbacks)) {
                config.callbacks = callbacks.concat(eventStreamer);
              } else {
                copiedCallbacks = callbacks.copy();
                copiedCallbacks.addHandler(eventStreamer, true);
                // eslint-disable-next-line no-param-reassign
                config.callbacks = copiedCallbacks;
              }
              // Call the runnable in streaming mode,
              // add each chunk to the output stream
              outerThis = _this6;
              runnableStreamConsumePromise = consumeRunnableStream();
              firstEventSent = false;
              _context16.prev = 11;
              _iteratorAbruptCompletion6 = false;
              _didIteratorError6 = false;
              _context16.prev = 14;
              _iterator6 = _asyncIterator(eventStreamer);
            case 16:
              _context16.next = 18;
              return _awaitAsyncGenerator(_iterator6.next());
            case 18:
              if (!(_iteratorAbruptCompletion6 = !(_step6 = _context16.sent).done)) {
                _context16.next = 33;
                break;
              }
              event = _step6.value;
              if (firstEventSent) {
                _context16.next = 27;
                break;
              }
              event.data.input = input;
              firstEventSent = true;
              firstEventRunId = event.run_id;
              _context16.next = 26;
              return event;
            case 26:
              return _context16.abrupt("continue", 30);
            case 27:
              if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
                // If it's the end event corresponding to the root runnable
                // we dont include the input in the event since it's guaranteed
                // to be included in the first event.
                if ((_event$data = event.data) !== null && _event$data !== void 0 && _event$data.input) {
                  delete event.data.input;
                }
              }
              _context16.next = 30;
              return event;
            case 30:
              _iteratorAbruptCompletion6 = false;
              _context16.next = 16;
              break;
            case 33:
              _context16.next = 39;
              break;
            case 35:
              _context16.prev = 35;
              _context16.t0 = _context16["catch"](14);
              _didIteratorError6 = true;
              _iteratorError6 = _context16.t0;
            case 39:
              _context16.prev = 39;
              _context16.prev = 40;
              if (!(_iteratorAbruptCompletion6 && _iterator6["return"] != null)) {
                _context16.next = 44;
                break;
              }
              _context16.next = 44;
              return _awaitAsyncGenerator(_iterator6["return"]());
            case 44:
              _context16.prev = 44;
              if (!_didIteratorError6) {
                _context16.next = 47;
                break;
              }
              throw _iteratorError6;
            case 47:
              return _context16.finish(44);
            case 48:
              return _context16.finish(39);
            case 49:
              _context16.prev = 49;
              _context16.next = 52;
              return _awaitAsyncGenerator(runnableStreamConsumePromise);
            case 52:
              return _context16.finish(49);
            case 53:
            case "end":
              return _context16.stop();
          }
        }, _callee16, null, [[11,, 49, 53], [14, 35, 39, 49], [40,, 44, 48]]);
      }))();
    }
  }, {
    key: "_streamEventsV1",
    value: function _streamEventsV1(input, options, streamOptions) {
      var _this7 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var _config$tags, _config$metadata, _config$runName3, _runLog2;
        var runLog, hasEncounteredStartEvent, config, rootTags, rootMetadata, rootName, logStreamCallbackHandler, rootEventFilter, logStream, _iteratorAbruptCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, log, _state, event, paths, dedupedPaths, _iterator19, _step19, path, eventType, _data, logEntry, _chunkCount, _runLog, _state2, chunkCount, data, _event, state, _event2;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              hasEncounteredStartEvent = false;
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              rootTags = (_config$tags = config.tags) !== null && _config$tags !== void 0 ? _config$tags : [];
              rootMetadata = (_config$metadata = config.metadata) !== null && _config$metadata !== void 0 ? _config$metadata : {};
              rootName = (_config$runName3 = config.runName) !== null && _config$runName3 !== void 0 ? _config$runName3 : _this7.getName();
              logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler(_objectSpread(_objectSpread({}, streamOptions), {}, {
                autoClose: false,
                _schemaFormat: "streaming_events"
              }));
              rootEventFilter = new _utils_js__WEBPACK_IMPORTED_MODULE_10__._RootEventFilter(_objectSpread({}, streamOptions));
              logStream = _this7._streamLog(input, logStreamCallbackHandler, config);
              _iteratorAbruptCompletion8 = false;
              _didIteratorError8 = false;
              _context17.prev = 10;
              _iterator8 = _asyncIterator(logStream);
            case 12:
              _context17.next = 14;
              return _awaitAsyncGenerator(_iterator8.next());
            case 14:
              if (!(_iteratorAbruptCompletion8 = !(_step8 = _context17.sent).done)) {
                _context17.next = 78;
                break;
              }
              log = _step8.value;
              if (!runLog) {
                runLog = _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLog.fromRunLogPatch(log);
              } else {
                runLog = runLog.concat(log);
              }
              if (!(runLog.state === undefined)) {
                _context17.next = 19;
                break;
              }
              throw new Error("Internal error: \"streamEvents\" state is missing. Please open a bug report.");
            case 19:
              if (hasEncounteredStartEvent) {
                _context17.next = 26;
                break;
              }
              hasEncounteredStartEvent = true;
              _state = _objectSpread({}, runLog.state);
              event = {
                run_id: _state.id,
                event: "on_".concat(_state.type, "_start"),
                name: rootName,
                tags: rootTags,
                metadata: rootMetadata,
                data: {
                  input: input
                }
              };
              if (!rootEventFilter.includeEvent(event, _state.type)) {
                _context17.next = 26;
                break;
              }
              _context17.next = 26;
              return event;
            case 26:
              paths = log.ops.filter(function (op) {
                return op.path.startsWith("/logs/");
              }).map(function (op) {
                return op.path.split("/")[2];
              });
              dedupedPaths = _toConsumableArray(new Set(paths));
              _iterator19 = _createForOfIteratorHelper(dedupedPaths);
              _context17.prev = 29;
              _iterator19.s();
            case 31:
              if ((_step19 = _iterator19.n()).done) {
                _context17.next = 56;
                break;
              }
              path = _step19.value;
              eventType = void 0;
              _data = {};
              logEntry = runLog.state.logs[path];
              if (logEntry.end_time === undefined) {
                if (logEntry.streamed_output.length > 0) {
                  eventType = "stream";
                } else {
                  eventType = "start";
                }
              } else {
                eventType = "end";
              }
              if (!(eventType === "start")) {
                _context17.next = 41;
                break;
              }
              // Include the inputs with the start event if they are available.
              // Usually they will NOT be available for components that operate
              // on streams, since those components stream the input and
              // don't know its final value until the end of the stream.
              if (logEntry.inputs !== undefined) {
                _data.input = logEntry.inputs;
              }
              _context17.next = 52;
              break;
            case 41:
              if (!(eventType === "end")) {
                _context17.next = 46;
                break;
              }
              if (logEntry.inputs !== undefined) {
                _data.input = logEntry.inputs;
              }
              _data.output = logEntry.final_output;
              _context17.next = 52;
              break;
            case 46:
              if (!(eventType === "stream")) {
                _context17.next = 52;
                break;
              }
              _chunkCount = logEntry.streamed_output.length;
              if (!(_chunkCount !== 1)) {
                _context17.next = 50;
                break;
              }
              throw new Error("Expected exactly one chunk of streamed output, got ".concat(_chunkCount, " instead. Encountered in: \"").concat(logEntry.name, "\""));
            case 50:
              _data = {
                chunk: logEntry.streamed_output[0]
              };
              // Clean up the stream, we don't need it anymore.
              // And this avoids duplicates as well!
              logEntry.streamed_output = [];
            case 52:
              _context17.next = 54;
              return {
                event: "on_".concat(logEntry.type, "_").concat(eventType),
                name: logEntry.name,
                run_id: logEntry.id,
                tags: logEntry.tags,
                metadata: logEntry.metadata,
                data: _data
              };
            case 54:
              _context17.next = 31;
              break;
            case 56:
              _context17.next = 61;
              break;
            case 58:
              _context17.prev = 58;
              _context17.t0 = _context17["catch"](29);
              _iterator19.e(_context17.t0);
            case 61:
              _context17.prev = 61;
              _iterator19.f();
              return _context17.finish(61);
            case 64:
              // Finally, we take care of the streaming output from the root chain
              // if there is any.
              _runLog = runLog, _state2 = _runLog.state;
              if (!(_state2.streamed_output.length > 0)) {
                _context17.next = 75;
                break;
              }
              chunkCount = _state2.streamed_output.length;
              if (!(chunkCount !== 1)) {
                _context17.next = 69;
                break;
              }
              throw new Error("Expected exactly one chunk of streamed output, got ".concat(chunkCount, " instead. Encountered in: \"").concat(_state2.name, "\""));
            case 69:
              data = {
                chunk: _state2.streamed_output[0]
              }; // Clean up the stream, we don't need it anymore.
              _state2.streamed_output = [];
              _event = {
                event: "on_".concat(_state2.type, "_stream"),
                run_id: _state2.id,
                tags: rootTags,
                metadata: rootMetadata,
                name: rootName,
                data: data
              };
              if (!rootEventFilter.includeEvent(_event, _state2.type)) {
                _context17.next = 75;
                break;
              }
              _context17.next = 75;
              return _event;
            case 75:
              _iteratorAbruptCompletion8 = false;
              _context17.next = 12;
              break;
            case 78:
              _context17.next = 84;
              break;
            case 80:
              _context17.prev = 80;
              _context17.t1 = _context17["catch"](10);
              _didIteratorError8 = true;
              _iteratorError8 = _context17.t1;
            case 84:
              _context17.prev = 84;
              _context17.prev = 85;
              if (!(_iteratorAbruptCompletion8 && _iterator8["return"] != null)) {
                _context17.next = 89;
                break;
              }
              _context17.next = 89;
              return _awaitAsyncGenerator(_iterator8["return"]());
            case 89:
              _context17.prev = 89;
              if (!_didIteratorError8) {
                _context17.next = 92;
                break;
              }
              throw _iteratorError8;
            case 92:
              return _context17.finish(89);
            case 93:
              return _context17.finish(84);
            case 94:
              state = (_runLog2 = runLog) === null || _runLog2 === void 0 ? void 0 : _runLog2.state;
              if (!(state !== undefined)) {
                _context17.next = 100;
                break;
              }
              // Finally, yield the end event for the root runnable.
              _event2 = {
                event: "on_".concat(state.type, "_end"),
                name: rootName,
                run_id: state.id,
                tags: rootTags,
                metadata: rootMetadata,
                data: {
                  output: state.final_output
                }
              };
              if (!rootEventFilter.includeEvent(_event2, state.type)) {
                _context17.next = 100;
                break;
              }
              _context17.next = 100;
              return _event2;
            case 100:
            case "end":
              return _context17.stop();
          }
        }, _callee17, null, [[10, 80, 84, 94], [29, 58, 61, 64], [85,, 89, 93]]);
      }))();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "withListeners",
    value:
    /**
     * Bind lifecycle listeners to a Runnable, returning a new Runnable.
     * The Run object contains information about the run, including its id,
     * type, input, output, error, startTime, endTime, and any tags or metadata
     * added to the run.
     *
     * @param {Object} params - The object containing the callback functions.
     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
     */
    function withListeners(_ref9) {
      var onStart = _ref9.onStart,
        onEnd = _ref9.onEnd,
        onError = _ref9.onError;
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunnableBinding({
        bound: this,
        config: {},
        configFactories: [function (config) {
          return {
            callbacks: [new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__.RootListenersTracer({
              config: config,
              onStart: onStart,
              onEnd: onEnd,
              onError: onError
            })]
          };
        }]
      });
    }
    /**
     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
     * which contains the runnable, name, description and schema.
     *
     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
     *
     * @param fields
     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
     */
  }, {
    key: "asTool",
    value: function asTool(fields) {
      return convertRunnableToTool(this, fields);
    }
  }], [{
    key: "isRunnable",
    value: function isRunnable(thing) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.isRunnableInterface)(thing);
    }
  }]);
}(_load_serializable_js__WEBPACK_IMPORTED_MODULE_4__.Serializable);
/**
 * A runnable that delegates calls to another runnable with a set of kwargs.
 * @example
 * ```typescript
 * import {
 *   type RunnableConfig,
 *   RunnableLambda,
 * } from "@langchain/core/runnables";
 *
 * const enhanceProfile = (
 *   profile: Record<string, any>,
 *   config?: RunnableConfig
 * ) => {
 *   if (config?.configurable?.role) {
 *     return { ...profile, role: config.configurable.role };
 *   }
 *   return profile;
 * };
 *
 * const runnable = RunnableLambda.from(enhanceProfile);
 *
 * // Bind configuration to the runnable to set the user's role dynamically
 * const adminRunnable = runnable.bind({ configurable: { role: "Admin" } });
 * const userRunnable = runnable.bind({ configurable: { role: "User" } });
 *
 * const result1 = await adminRunnable.invoke({
 *   name: "Alice",
 *   email: "alice@example.com"
 * });
 *
 * // { name: "Alice", email: "alice@example.com", role: "Admin" }
 *
 * const result2 = await userRunnable.invoke({
 *   name: "Bob",
 *   email: "bob@example.com"
 * });
 *
 * // { name: "Bob", email: "bob@example.com", role: "User" }
 * ```
 */
var RunnableBinding = /*#__PURE__*/function (_Runnable) {
  function RunnableBinding(fields) {
    var _this20;
    _classCallCheck(this, RunnableBinding);
    _this20 = _callSuper(this, RunnableBinding, [fields]);
    Object.defineProperty(_this20, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this20, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this20, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this20, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this20, "kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this20, "configFactories", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this20.bound = fields.bound;
    _this20.kwargs = fields.kwargs;
    _this20.config = fields.config;
    _this20.configFactories = fields.configFactories;
    return _this20;
  }
  _inherits(RunnableBinding, _Runnable);
  return _createClass(RunnableBinding, [{
    key: "getName",
    value: function getName(suffix) {
      return this.bound.getName(suffix);
    }
  }, {
    key: "_mergeConfig",
    value: function () {
      var _mergeConfig2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        var _len,
          options,
          _key,
          config,
          _args19 = arguments;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              for (_len = _args19.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
                options[_key] = _args19[_key];
              }
              config = _config_js__WEBPACK_IMPORTED_MODULE_7__.mergeConfigs.apply(void 0, [this.config].concat(options));
              _context19.t0 = _config_js__WEBPACK_IMPORTED_MODULE_7__.mergeConfigs;
              _context19.t1 = void 0;
              _context19.t2 = [config];
              _context19.t3 = _toConsumableArray;
              if (!this.configFactories) {
                _context19.next = 12;
                break;
              }
              _context19.next = 9;
              return Promise.all(this.configFactories.map(/*#__PURE__*/function () {
                var _ref10 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(configFactory) {
                  return _regeneratorRuntime().wrap(function _callee18$(_context18) {
                    while (1) switch (_context18.prev = _context18.next) {
                      case 0:
                        _context18.next = 2;
                        return configFactory(config);
                      case 2:
                        return _context18.abrupt("return", _context18.sent);
                      case 3:
                      case "end":
                        return _context18.stop();
                    }
                  }, _callee18);
                }));
                return function (_x15) {
                  return _ref10.apply(this, arguments);
                };
              }()));
            case 9:
              _context19.t4 = _context19.sent;
              _context19.next = 13;
              break;
            case 12:
              _context19.t4 = [];
            case 13:
              _context19.t5 = _context19.t4;
              _context19.t6 = (0, _context19.t3)(_context19.t5);
              _context19.t7 = _context19.t2.concat.call(_context19.t2, _context19.t6);
              return _context19.abrupt("return", _context19.t0.apply.call(_context19.t0, _context19.t1, _context19.t7));
            case 17:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function _mergeConfig() {
        return _mergeConfig2.apply(this, arguments);
      }
      return _mergeConfig;
    }()
  }, {
    key: "bind",
    value: function bind(kwargs) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return new this.constructor({
        bound: this.bound,
        kwargs: _objectSpread(_objectSpread({}, this.kwargs), kwargs),
        config: this.config
      });
    }
  }, {
    key: "withConfig",
    value: function withConfig(config) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return new this.constructor({
        bound: this.bound,
        kwargs: this.kwargs,
        config: _objectSpread(_objectSpread({}, this.config), config)
      });
    }
  }, {
    key: "withRetry",
    value: function withRetry(fields) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return new this.constructor({
        bound: this.bound.withRetry(fields),
        kwargs: this.kwargs,
        config: this.config
      });
    }
  }, {
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(input, options) {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.t0 = this.bound;
              _context20.t1 = input;
              _context20.next = 4;
              return this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs);
            case 4:
              _context20.t2 = _context20.sent;
              return _context20.abrupt("return", _context20.t0.invoke.call(_context20.t0, _context20.t1, _context20.t2));
            case 6:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function invoke(_x16, _x17) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "batch",
    value: function () {
      var _batch2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(inputs, options, batchOptions) {
        var _this21 = this;
        var mergedOptions;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              if (!Array.isArray(options)) {
                _context22.next = 6;
                break;
              }
              _context22.next = 3;
              return Promise.all(options.map(/*#__PURE__*/function () {
                var _ref11 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(individualOption) {
                  return _regeneratorRuntime().wrap(function _callee21$(_context21) {
                    while (1) switch (_context21.prev = _context21.next) {
                      case 0:
                        return _context21.abrupt("return", _this21._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(individualOption), _this21.kwargs));
                      case 1:
                      case "end":
                        return _context21.stop();
                    }
                  }, _callee21);
                }));
                return function (_x21) {
                  return _ref11.apply(this, arguments);
                };
              }()));
            case 3:
              _context22.t0 = _context22.sent;
              _context22.next = 9;
              break;
            case 6:
              _context22.next = 8;
              return this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs);
            case 8:
              _context22.t0 = _context22.sent;
            case 9:
              mergedOptions = _context22.t0;
              return _context22.abrupt("return", this.bound.batch(inputs, mergedOptions, batchOptions));
            case 11:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function batch(_x18, _x19, _x20) {
        return _batch2.apply(this, arguments);
      }
      return batch;
    }()
  }, {
    key: "_streamIterator",
    value: function _streamIterator(input, options) {
      var _this8 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.t0 = _asyncGeneratorDelegate;
              _context23.t1 = _asyncIterator;
              _context23.t2 = _this8.bound;
              _context23.t3 = input;
              _context23.next = 6;
              return _awaitAsyncGenerator(_this8._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), _this8.kwargs));
            case 6:
              _context23.t4 = _context23.sent;
              _context23.t5 = _context23.t2._streamIterator.call(_context23.t2, _context23.t3, _context23.t4);
              _context23.t6 = (0, _context23.t1)(_context23.t5);
              _context23.t7 = _awaitAsyncGenerator;
              return _context23.delegateYield((0, _context23.t0)(_context23.t6, _context23.t7), "t8", 11);
            case 11:
            case "end":
              return _context23.stop();
          }
        }, _callee23);
      }))();
    }
  }, {
    key: "stream",
    value: function () {
      var _stream2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(input, options) {
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.t0 = this.bound;
              _context24.t1 = input;
              _context24.next = 4;
              return this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs);
            case 4:
              _context24.t2 = _context24.sent;
              return _context24.abrupt("return", _context24.t0.stream.call(_context24.t0, _context24.t1, _context24.t2));
            case 6:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function stream(_x22, _x23) {
        return _stream2.apply(this, arguments);
      }
      return stream;
    }()
  }, {
    key: "transform",
    value: function transform(generator, options) {
      var _this9 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _context25.t0 = _asyncGeneratorDelegate;
              _context25.t1 = _asyncIterator;
              _context25.t2 = _this9.bound;
              _context25.t3 = generator;
              _context25.next = 6;
              return _awaitAsyncGenerator(_this9._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), _this9.kwargs));
            case 6:
              _context25.t4 = _context25.sent;
              _context25.t5 = _context25.t2.transform.call(_context25.t2, _context25.t3, _context25.t4);
              _context25.t6 = (0, _context25.t1)(_context25.t5);
              _context25.t7 = _awaitAsyncGenerator;
              return _context25.delegateYield((0, _context25.t0)(_context25.t6, _context25.t7), "t8", 11);
            case 11:
            case "end":
              return _context25.stop();
          }
        }, _callee25);
      }))();
    }
  }, {
    key: "streamEvents",
    value: function streamEvents(input, options, streamOptions) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var outerThis = this;
      var generator = /*#__PURE__*/function () {
        var _ref = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                _context26.t0 = _asyncGeneratorDelegate;
                _context26.t1 = _asyncIterator;
                _context26.t2 = outerThis.bound;
                _context26.t3 = input;
                _context26.t4 = _objectSpread;
                _context26.t5 = _objectSpread;
                _context26.t6 = {};
                _context26.next = 9;
                return _awaitAsyncGenerator(outerThis._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), outerThis.kwargs));
              case 9:
                _context26.t7 = _context26.sent;
                _context26.t8 = (0, _context26.t5)(_context26.t6, _context26.t7);
                _context26.t9 = {};
                _context26.t10 = {
                  version: options.version
                };
                _context26.t11 = (0, _context26.t4)(_context26.t8, _context26.t9, _context26.t10);
                _context26.t12 = streamOptions;
                _context26.t13 = _context26.t2.streamEvents.call(_context26.t2, _context26.t3, _context26.t11, _context26.t12);
                _context26.t14 = (0, _context26.t1)(_context26.t13);
                _context26.t15 = _awaitAsyncGenerator;
                return _context26.delegateYield((0, _context26.t0)(_context26.t14, _context26.t15), "t16", 19);
              case 19:
              case "end":
                return _context26.stop();
            }
          }, _callee26);
        }));
        return function generator() {
          return _ref.apply(this, arguments);
        };
      }();
      return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(generator());
    }
  }, {
    key: "withListeners",
    value:
    /**
     * Bind lifecycle listeners to a Runnable, returning a new Runnable.
     * The Run object contains information about the run, including its id,
     * type, input, output, error, startTime, endTime, and any tags or metadata
     * added to the run.
     *
     * @param {Object} params - The object containing the callback functions.
     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
     */
    function withListeners(_ref12) {
      var onStart = _ref12.onStart,
        onEnd = _ref12.onEnd,
        onError = _ref12.onError;
      return new RunnableBinding({
        bound: this.bound,
        kwargs: this.kwargs,
        config: this.config,
        configFactories: [function (config) {
          return {
            callbacks: [new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__.RootListenersTracer({
              config: config,
              onStart: onStart,
              onEnd: onEnd,
              onError: onError
            })]
          };
        }]
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableBinding";
    }
  }, {
    key: "isRunnableBinding",
    value: function isRunnableBinding(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    thing
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
      return thing.bound && Runnable.isRunnable(thing.bound);
    }
  }]);
}(Runnable);
/**
 * A runnable that delegates calls to another runnable
 * with each element of the input sequence.
 * @example
 * ```typescript
 * import { RunnableEach, RunnableLambda } from "@langchain/core/runnables";
 *
 * const toUpperCase = (input: string): string => input.toUpperCase();
 * const addGreeting = (input: string): string => `Hello, ${input}!`;
 *
 * const upperCaseLambda = RunnableLambda.from(toUpperCase);
 * const greetingLambda = RunnableLambda.from(addGreeting);
 *
 * const chain = new RunnableEach({
 *   bound: upperCaseLambda.pipe(greetingLambda),
 * });
 *
 * const result = await chain.invoke(["alice", "bob", "carol"])
 *
 * // ["Hello, ALICE!", "Hello, BOB!", "Hello, CAROL!"]
 * ```
 */
var RunnableEach = /*#__PURE__*/function (_Runnable2) {
  function RunnableEach(fields) {
    var _this22;
    _classCallCheck(this, RunnableEach);
    _this22 = _callSuper(this, RunnableEach, [fields]);
    Object.defineProperty(_this22, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this22, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this22, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this22.bound = fields.bound;
    return _this22;
  }
  /**
   * Binds the runnable with the specified arguments.
   * @param kwargs The arguments to bind the runnable with.
   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.
   */
  _inherits(RunnableEach, _Runnable2);
  return _createClass(RunnableEach, [{
    key: "bind",
    value: function bind(kwargs) {
      return new RunnableEach({
        bound: this.bound.bind(kwargs)
      });
    }
    /**
     * Invokes the runnable with the specified input and configuration.
     * @param input The input to invoke the runnable with.
     * @param config The configuration to invoke the runnable with.
     * @returns A promise that resolves to the output of the runnable.
     */
  }, {
    key: "invoke",
    value: (function () {
      var _invoke2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(inputs, config) {
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              return _context27.abrupt("return", this._callWithConfig(this._invoke.bind(this), inputs, config));
            case 1:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function invoke(_x24, _x25) {
        return _invoke2.apply(this, arguments);
      }
      return invoke;
    }()
    /**
     * A helper method that is used to invoke the runnable with the specified input and configuration.
     * @param input The input to invoke the runnable with.
     * @param config The configuration to invoke the runnable with.
     * @returns A promise that resolves to the output of the runnable.
     */
    )
  }, {
    key: "_invoke",
    value: (function () {
      var _invoke3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(inputs, config, runManager) {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              return _context28.abrupt("return", this.bound.batch(inputs, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()
              })));
            case 1:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function _invoke(_x26, _x27, _x28) {
        return _invoke3.apply(this, arguments);
      }
      return _invoke;
    }()
    /**
     * Bind lifecycle listeners to a Runnable, returning a new Runnable.
     * The Run object contains information about the run, including its id,
     * type, input, output, error, startTime, endTime, and any tags or metadata
     * added to the run.
     *
     * @param {Object} params - The object containing the callback functions.
     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
     */
    )
  }, {
    key: "withListeners",
    value: function withListeners(_ref13) {
      var onStart = _ref13.onStart,
        onEnd = _ref13.onEnd,
        onError = _ref13.onError;
      return new RunnableEach({
        bound: this.bound.withListeners({
          onStart: onStart,
          onEnd: onEnd,
          onError: onError
        })
      });
    }
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableEach";
    }
  }]);
}(Runnable);
/**
 * Base class for runnables that can be retried a
 * specified number of times.
 * @example
 * ```typescript
 * import {
 *   RunnableLambda,
 *   RunnableRetry,
 * } from "@langchain/core/runnables";
 *
 * // Simulate an API call that fails
 * const simulateApiCall = (input: string): string => {
 *   console.log(`Attempting API call with input: ${input}`);
 *   throw new Error("API call failed due to network issue");
 * };
 *
 * const apiCallLambda = RunnableLambda.from(simulateApiCall);
 *
 * // Apply retry logic using the .withRetry() method
 * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });
 *
 * // Alternatively, create a RunnableRetry instance manually
 * const manualRetry = new RunnableRetry({
 *   bound: apiCallLambda,
 *   maxAttemptNumber: 3,
 *   config: {},
 * });
 *
 * // Example invocation using the .withRetry() method
 * const res = await apiCallWithRetry
 *   .invoke("Request 1")
 *   .catch((error) => {
 *     console.error("Failed after multiple retries:", error.message);
 *   });
 *
 * // Example invocation using the manual retry instance
 * const res2 = await manualRetry
 *   .invoke("Request 2")
 *   .catch((error) => {
 *     console.error("Failed after multiple retries:", error.message);
 *   });
 * ```
 */
var RunnableRetry = /*#__PURE__*/function (_RunnableBinding) {
  function RunnableRetry(fields) {
    var _fields$maxAttemptNum, _fields$onFailedAttem;
    var _this23;
    _classCallCheck(this, RunnableRetry);
    _this23 = _callSuper(this, RunnableRetry, [fields]);
    Object.defineProperty(_this23, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this23, "maxAttemptNumber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.defineProperty(_this23, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function value() {}
    });
    _this23.maxAttemptNumber = (_fields$maxAttemptNum = fields.maxAttemptNumber) !== null && _fields$maxAttemptNum !== void 0 ? _fields$maxAttemptNum : _this23.maxAttemptNumber;
    _this23.onFailedAttempt = (_fields$onFailedAttem = fields.onFailedAttempt) !== null && _fields$onFailedAttem !== void 0 ? _fields$onFailedAttem : _this23.onFailedAttempt;
    return _this23;
  }
  _inherits(RunnableRetry, _RunnableBinding);
  return _createClass(RunnableRetry, [{
    key: "_patchConfigForRetry",
    value: function _patchConfigForRetry(attempt, config, runManager) {
      var tag = attempt > 1 ? "retry:attempt:".concat(attempt) : undefined;
      return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(tag)
      });
    }
  }, {
    key: "_invoke",
    value: function () {
      var _invoke4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(input, config, runManager) {
        var _this24 = this;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              return _context29.abrupt("return", p_retry__WEBPACK_IMPORTED_MODULE_0__(function (attemptNumber) {
                return _superPropGet(RunnableRetry, "invoke", _this24, 3)([input, _this24._patchConfigForRetry(attemptNumber, config, runManager)]);
              }, {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                onFailedAttempt: function onFailedAttempt(error) {
                  return _this24.onFailedAttempt(error, input);
                },
                retries: Math.max(this.maxAttemptNumber - 1, 0),
                randomize: true
              }));
            case 1:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
      function _invoke(_x29, _x30, _x31) {
        return _invoke4.apply(this, arguments);
      }
      return _invoke;
    }()
    /**
     * Method that invokes the runnable with the specified input, run manager,
     * and config. It handles the retry logic by catching any errors and
     * recursively invoking itself with the updated config for the next retry
     * attempt.
     * @param input The input for the runnable.
     * @param runManager The run manager for the runnable.
     * @param config The config for the runnable.
     * @returns A promise that resolves to the output of the runnable.
     */
  }, {
    key: "invoke",
    value: (function () {
      var _invoke5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(input, config) {
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              return _context30.abrupt("return", this._callWithConfig(this._invoke.bind(this), input, config));
            case 1:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function invoke(_x32, _x33) {
        return _invoke5.apply(this, arguments);
      }
      return invoke;
    }())
  }, {
    key: "_batch",
    value: function () {
      var _batch3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(inputs, configs, runManagers, batchOptions) {
        var _this25 = this;
        var resultsMap;
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              resultsMap = {};
              _context32.prev = 1;
              _context32.next = 4;
              return p_retry__WEBPACK_IMPORTED_MODULE_0__(/*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(attemptNumber) {
                  var remainingIndexes, remainingInputs, patchedConfigs, results, firstException, i, result, resultMapIndex;
                  return _regeneratorRuntime().wrap(function _callee31$(_context31) {
                    while (1) switch (_context31.prev = _context31.next) {
                      case 0:
                        remainingIndexes = inputs.map(function (_, i) {
                          return i;
                        }).filter(function (i) {
                          return resultsMap[i.toString()] === undefined ||
                          // eslint-disable-next-line no-instanceof/no-instanceof
                          resultsMap[i.toString()] instanceof Error;
                        });
                        remainingInputs = remainingIndexes.map(function (i) {
                          return inputs[i];
                        });
                        patchedConfigs = remainingIndexes.map(function (i) {
                          return _this25._patchConfigForRetry(attemptNumber, configs === null || configs === void 0 ? void 0 : configs[i], runManagers === null || runManagers === void 0 ? void 0 : runManagers[i]);
                        });
                        _context31.next = 5;
                        return _superPropGet(RunnableRetry, "batch", _this25, 3)([remainingInputs, patchedConfigs, _objectSpread(_objectSpread({}, batchOptions), {}, {
                          returnExceptions: true
                        })]);
                      case 5:
                        results = _context31.sent;
                        for (i = 0; i < results.length; i += 1) {
                          result = results[i];
                          resultMapIndex = remainingIndexes[i]; // eslint-disable-next-line no-instanceof/no-instanceof
                          if (result instanceof Error) {
                            if (firstException === undefined) {
                              firstException = result;
                              // eslint-disable-next-line @typescript-eslint/no-explicit-any
                              firstException.input = remainingInputs[i];
                            }
                          }
                          resultsMap[resultMapIndex.toString()] = result;
                        }
                        if (!firstException) {
                          _context31.next = 9;
                          break;
                        }
                        throw firstException;
                      case 9:
                        return _context31.abrupt("return", results);
                      case 10:
                      case "end":
                        return _context31.stop();
                    }
                  }, _callee31);
                }));
                return function (_x38) {
                  return _ref14.apply(this, arguments);
                };
              }(), {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                onFailedAttempt: function onFailedAttempt(error) {
                  return _this25.onFailedAttempt(error, error.input);
                },
                retries: Math.max(this.maxAttemptNumber - 1, 0),
                randomize: true
              });
            case 4:
              _context32.next = 10;
              break;
            case 6:
              _context32.prev = 6;
              _context32.t0 = _context32["catch"](1);
              if (!((batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.returnExceptions) !== true)) {
                _context32.next = 10;
                break;
              }
              throw _context32.t0;
            case 10:
              return _context32.abrupt("return", Object.keys(resultsMap).sort(function (a, b) {
                return parseInt(a, 10) - parseInt(b, 10);
              }).map(function (key) {
                return resultsMap[parseInt(key, 10)];
              }));
            case 11:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this, [[1, 6]]);
      }));
      function _batch(_x34, _x35, _x36, _x37) {
        return _batch3.apply(this, arguments);
      }
      return _batch;
    }()
  }, {
    key: "batch",
    value: function () {
      var _batch4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(inputs, options, batchOptions) {
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              return _context33.abrupt("return", this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions));
            case 1:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function batch(_x39, _x40, _x41) {
        return _batch4.apply(this, arguments);
      }
      return batch;
    }()
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableRetry";
    }
  }]);
}(RunnableBinding);
/**
 * A sequence of runnables, where the output of each is the input of the next.
 * @example
 * ```typescript
 * const promptTemplate = PromptTemplate.fromTemplate(
 *   "Tell me a joke about {topic}",
 * );
 * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);
 * const result = await chain.invoke({ topic: "bears" });
 * ```
 */
var RunnableSequence = /*#__PURE__*/function (_Runnable3) {
  function RunnableSequence(fields) {
    var _fields$middle, _fields$omitSequenceT;
    var _this26;
    _classCallCheck(this, RunnableSequence);
    _this26 = _callSuper(this, RunnableSequence, [fields]);
    Object.defineProperty(_this26, "first", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this26, "middle", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.defineProperty(_this26, "last", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this26, "omitSequenceTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this26, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this26, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    _this26.first = fields.first;
    _this26.middle = (_fields$middle = fields.middle) !== null && _fields$middle !== void 0 ? _fields$middle : _this26.middle;
    _this26.last = fields.last;
    _this26.name = fields.name;
    _this26.omitSequenceTags = (_fields$omitSequenceT = fields.omitSequenceTags) !== null && _fields$omitSequenceT !== void 0 ? _fields$omitSequenceT : _this26.omitSequenceTags;
    return _this26;
  }
  _inherits(RunnableSequence, _Runnable3);
  return _createClass(RunnableSequence, [{
    key: "steps",
    get: function get() {
      return [this.first].concat(_toConsumableArray(this.middle), [this.last]);
    }
  }, {
    key: "invoke",
    value: function () {
      var _invoke6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(input, options) {
        var config, callbackManager_, runManager, nextStepInput, finalOutput, _options$signal, initialSteps, i, step, promise;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              _context34.next = 3;
              return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);
            case 3:
              callbackManager_ = _context34.sent;
              _context34.next = 6;
              return callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config.runId, undefined, undefined, undefined, config === null || config === void 0 ? void 0 : config.runName);
            case 6:
              runManager = _context34.sent;
              delete config.runId;
              nextStepInput = input;
              _context34.prev = 9;
              initialSteps = [this.first].concat(_toConsumableArray(this.middle));
              i = 0;
            case 12:
              if (!(i < initialSteps.length)) {
                _context34.next = 21;
                break;
              }
              step = initialSteps[i];
              promise = step.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(this.omitSequenceTags ? undefined : "seq:step:".concat(i + 1))
              }));
              _context34.next = 17;
              return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options === null || options === void 0 ? void 0 : options.signal);
            case 17:
              nextStepInput = _context34.sent;
            case 18:
              i += 1;
              _context34.next = 12;
              break;
            case 21:
              if (!(options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted)) {
                _context34.next = 23;
                break;
              }
              throw new Error("Aborted");
            case 23:
              _context34.next = 25;
              return this.last.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(this.omitSequenceTags ? undefined : "seq:step:".concat(this.steps.length))
              }));
            case 25:
              finalOutput = _context34.sent;
              _context34.next = 33;
              break;
            case 28:
              _context34.prev = 28;
              _context34.t0 = _context34["catch"](9);
              _context34.next = 32;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context34.t0);
            case 32:
              throw _context34.t0;
            case 33:
              _context34.next = 35;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output"));
            case 35:
              return _context34.abrupt("return", finalOutput);
            case 36:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this, [[9, 28]]);
      }));
      function invoke(_x42, _x43) {
        return _invoke6.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "batch",
    value: function () {
      var _batch5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(inputs, options, batchOptions) {
        var _this27 = this;
        var configList, callbackManagers, runManagers, nextStepInputs, _loop, i;
        return _regeneratorRuntime().wrap(function _callee36$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);
              _context37.next = 3;
              return Promise.all(configList.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig));
            case 3:
              callbackManagers = _context37.sent;
              _context37.next = 6;
              return Promise.all(callbackManagers.map(/*#__PURE__*/function () {
                var _ref15 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(callbackManager, i) {
                  var handleStartRes;
                  return _regeneratorRuntime().wrap(function _callee35$(_context35) {
                    while (1) switch (_context35.prev = _context35.next) {
                      case 0:
                        _context35.next = 2;
                        return callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(_this27.toJSON(), _coerceToDict(inputs[i], "input"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);
                      case 2:
                        handleStartRes = _context35.sent;
                        delete configList[i].runId;
                        return _context35.abrupt("return", handleStartRes);
                      case 5:
                      case "end":
                        return _context35.stop();
                    }
                  }, _callee35);
                }));
                return function (_x47, _x48) {
                  return _ref15.apply(this, arguments);
                };
              }()));
            case 6:
              runManagers = _context37.sent;
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              nextStepInputs = inputs;
              _context37.prev = 8;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {
                var _configList$2;
                var step, promise;
                return _regeneratorRuntime().wrap(function _loop$(_context36) {
                  while (1) switch (_context36.prev = _context36.next) {
                    case 0:
                      step = _this27.steps[i];
                      promise = step.batch(nextStepInputs, runManagers.map(function (runManager, j) {
                        var childRunManager = runManager === null || runManager === void 0 ? void 0 : runManager.getChild(_this27.omitSequenceTags ? undefined : "seq:step:".concat(i + 1));
                        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(configList[j], {
                          callbacks: childRunManager
                        });
                      }), batchOptions);
                      _context36.next = 4;
                      return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, (_configList$2 = configList[0]) === null || _configList$2 === void 0 ? void 0 : _configList$2.signal);
                    case 4:
                      nextStepInputs = _context36.sent;
                    case 5:
                    case "end":
                      return _context36.stop();
                  }
                }, _loop);
              });
              i = 0;
            case 11:
              if (!(i < this.steps.length)) {
                _context37.next = 16;
                break;
              }
              return _context37.delegateYield(_loop(i), "t0", 13);
            case 13:
              i += 1;
              _context37.next = 11;
              break;
            case 16:
              _context37.next = 23;
              break;
            case 18:
              _context37.prev = 18;
              _context37.t1 = _context37["catch"](8);
              _context37.next = 22;
              return Promise.all(runManagers.map(function (runManager) {
                return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context37.t1);
              }));
            case 22:
              throw _context37.t1;
            case 23:
              _context37.next = 25;
              return Promise.all(runManagers.map(function (runManager) {
                return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(nextStepInputs, "output"));
              }));
            case 25:
              return _context37.abrupt("return", nextStepInputs);
            case 26:
            case "end":
              return _context37.stop();
          }
        }, _callee36, this, [[8, 18]]);
      }));
      function batch(_x44, _x45, _x46) {
        return _batch5.apply(this, arguments);
      }
      return batch;
    }()
  }, {
    key: "_streamIterator",
    value: function _streamIterator(input, options) {
      var _this10 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {
        var callbackManager_, _ref16, runId, otherOptions, runManager, steps, concatSupported, finalOutput, inputGenerator, _inputGenerator, finalGenerator, i, step, _iteratorAbruptCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, chunk, _options$signal2;
        return _regeneratorRuntime().wrap(function _callee38$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _inputGenerator = function _inputGenerator3() {
                _inputGenerator = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
                  return _regeneratorRuntime().wrap(function _callee37$(_context38) {
                    while (1) switch (_context38.prev = _context38.next) {
                      case 0:
                        _context38.next = 2;
                        return input;
                      case 2:
                      case "end":
                        return _context38.stop();
                    }
                  }, _callee37);
                }));
                return _inputGenerator.apply(this, arguments);
              };
              inputGenerator = function _inputGenerator2() {
                return _inputGenerator.apply(this, arguments);
              };
              _context39.next = 4;
              return _awaitAsyncGenerator((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options));
            case 4:
              callbackManager_ = _context39.sent;
              _ref16 = options !== null && options !== void 0 ? options : {}, runId = _ref16.runId, otherOptions = _objectWithoutProperties(_ref16, _excluded);
              _context39.next = 8;
              return _awaitAsyncGenerator(callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(_this10.toJSON(), _coerceToDict(input, "input"), runId, undefined, undefined, undefined, otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.runName));
            case 8:
              runManager = _context39.sent;
              steps = [_this10.first].concat(_toConsumableArray(_this10.middle), [_this10.last]);
              concatSupported = true;
              _context39.prev = 11;
              finalGenerator = steps[0].transform(inputGenerator(), (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherOptions, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(_this10.omitSequenceTags ? undefined : "seq:step:1")
              }));
              i = 1;
            case 14:
              if (!(i < steps.length)) {
                _context39.next = 22;
                break;
              }
              step = steps[i];
              _context39.next = 18;
              return _awaitAsyncGenerator(step.transform(finalGenerator, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherOptions, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(_this10.omitSequenceTags ? undefined : "seq:step:".concat(i + 1))
              })));
            case 18:
              finalGenerator = _context39.sent;
            case 19:
              i += 1;
              _context39.next = 14;
              break;
            case 22:
              _iteratorAbruptCompletion9 = false;
              _didIteratorError9 = false;
              _context39.prev = 24;
              _iterator9 = _asyncIterator(finalGenerator);
            case 26:
              _context39.next = 28;
              return _awaitAsyncGenerator(_iterator9.next());
            case 28:
              if (!(_iteratorAbruptCompletion9 = !(_step9 = _context39.sent).done)) {
                _context39.next = 37;
                break;
              }
              chunk = _step9.value;
              options === null || options === void 0 || (_options$signal2 = options.signal) === null || _options$signal2 === void 0 || _options$signal2.throwIfAborted();
              _context39.next = 33;
              return chunk;
            case 33:
              if (concatSupported) {
                if (finalOutput === undefined) {
                  finalOutput = chunk;
                } else {
                  try {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);
                  } catch (e) {
                    finalOutput = undefined;
                    concatSupported = false;
                  }
                }
              }
            case 34:
              _iteratorAbruptCompletion9 = false;
              _context39.next = 26;
              break;
            case 37:
              _context39.next = 43;
              break;
            case 39:
              _context39.prev = 39;
              _context39.t0 = _context39["catch"](24);
              _didIteratorError9 = true;
              _iteratorError9 = _context39.t0;
            case 43:
              _context39.prev = 43;
              _context39.prev = 44;
              if (!(_iteratorAbruptCompletion9 && _iterator9["return"] != null)) {
                _context39.next = 48;
                break;
              }
              _context39.next = 48;
              return _awaitAsyncGenerator(_iterator9["return"]());
            case 48:
              _context39.prev = 48;
              if (!_didIteratorError9) {
                _context39.next = 51;
                break;
              }
              throw _iteratorError9;
            case 51:
              return _context39.finish(48);
            case 52:
              return _context39.finish(43);
            case 53:
              _context39.next = 60;
              break;
            case 55:
              _context39.prev = 55;
              _context39.t1 = _context39["catch"](11);
              _context39.next = 59;
              return _awaitAsyncGenerator(runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context39.t1));
            case 59:
              throw _context39.t1;
            case 60:
              _context39.next = 62;
              return _awaitAsyncGenerator(runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
            case 62:
            case "end":
              return _context39.stop();
          }
        }, _callee38, null, [[11, 55], [24, 39, 43, 53], [44,, 48, 52]]);
      }))();
    }
  }, {
    key: "getGraph",
    value: function getGraph(config) {
      var _this28 = this;
      var graph = new _graph_js__WEBPACK_IMPORTED_MODULE_12__.Graph();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var currentLastNode = null;
      this.steps.forEach(function (step, index) {
        var stepGraph = step.getGraph(config);
        if (index !== 0) {
          stepGraph.trimFirstNode();
        }
        if (index !== _this28.steps.length - 1) {
          stepGraph.trimLastNode();
        }
        graph.extend(stepGraph);
        var stepFirstNode = stepGraph.firstNode();
        if (!stepFirstNode) {
          throw new Error("Runnable ".concat(step, " has no first node"));
        }
        if (currentLastNode) {
          graph.addEdge(currentLastNode, stepFirstNode);
        }
        currentLastNode = stepGraph.lastNode();
      });
      return graph;
    }
  }, {
    key: "pipe",
    value: function pipe(coerceable) {
      if (RunnableSequence.isRunnableSequence(coerceable)) {
        var _this$name2;
        return new RunnableSequence({
          first: this.first,
          middle: this.middle.concat([this.last, coerceable.first].concat(_toConsumableArray(coerceable.middle))),
          last: coerceable.last,
          name: (_this$name2 = this.name) !== null && _this$name2 !== void 0 ? _this$name2 : coerceable.name
        });
      } else {
        return new RunnableSequence({
          first: this.first,
          middle: [].concat(_toConsumableArray(this.middle), [this.last]),
          last: _coerceToRunnable(coerceable),
          name: this.name
        });
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableSequence";
    }
  }, {
    key: "isRunnableSequence",
    value: function isRunnableSequence(thing) {
      return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "from",
    value: function from(_ref17, nameOrFields) {
      var _ref18 = _toArray(_ref17),
        first = _ref18[0],
        runnables = _ref18.slice(1);
      var extra = {};
      if (typeof nameOrFields === "string") {
        extra.name = nameOrFields;
      } else if (nameOrFields !== undefined) {
        extra = nameOrFields;
      }
      return new RunnableSequence(_objectSpread(_objectSpread({}, extra), {}, {
        first: _coerceToRunnable(first),
        middle: runnables.slice(0, -1).map(_coerceToRunnable),
        last: _coerceToRunnable(runnables[runnables.length - 1])
      }));
    }
  }]);
}(Runnable);
/**
 * A runnable that runs a mapping of runnables in parallel,
 * and returns a mapping of their outputs.
 * @example
 * ```typescript
 * const mapChain = RunnableMap.from({
 *   joke: PromptTemplate.fromTemplate("Tell me a joke about {topic}").pipe(
 *     new ChatAnthropic({}),
 *   ),
 *   poem: PromptTemplate.fromTemplate("write a 2-line poem about {topic}").pipe(
 *     new ChatAnthropic({}),
 *   ),
 * });
 * const result = await mapChain.invoke({ topic: "bear" });
 * ```
 */
var RunnableMap = /*#__PURE__*/function (_Runnable4) {
  function RunnableMap(fields) {
    var _this29;
    _classCallCheck(this, RunnableMap);
    _this29 = _callSuper(this, RunnableMap, [fields]);
    Object.defineProperty(_this29, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this29, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this29, "steps", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this29.steps = {};
    for (var _i = 0, _Object$entries = Object.entries(fields.steps); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
      _this29.steps[key] = _coerceToRunnable(value);
    }
    return _this29;
  }
  _inherits(RunnableMap, _Runnable4);
  return _createClass(RunnableMap, [{
    key: "getStepsKeys",
    value: function getStepsKeys() {
      return Object.keys(this.steps);
    }
  }, {
    key: "invoke",
    value: function () {
      var _invoke7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40(input, options) {
        var config, callbackManager_, runManager, output, promises;
        return _regeneratorRuntime().wrap(function _callee40$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              _context41.next = 3;
              return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);
            case 3:
              callbackManager_ = _context41.sent;
              _context41.next = 6;
              return callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {
                input: input
              }, config.runId, undefined, undefined, undefined, config === null || config === void 0 ? void 0 : config.runName);
            case 6:
              runManager = _context41.sent;
              delete config.runId;
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              output = {};
              _context41.prev = 9;
              promises = Object.entries(this.steps).map(/*#__PURE__*/function () {
                var _ref20 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(_ref19) {
                  var _ref21, key, runnable;
                  return _regeneratorRuntime().wrap(function _callee39$(_context40) {
                    while (1) switch (_context40.prev = _context40.next) {
                      case 0:
                        _ref21 = _slicedToArray(_ref19, 2), key = _ref21[0], runnable = _ref21[1];
                        _context40.next = 3;
                        return runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild("map:key:".concat(key))
                        }));
                      case 3:
                        output[key] = _context40.sent;
                      case 4:
                      case "end":
                        return _context40.stop();
                    }
                  }, _callee39);
                }));
                return function (_x51) {
                  return _ref20.apply(this, arguments);
                };
              }());
              _context41.next = 13;
              return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(Promise.all(promises), options === null || options === void 0 ? void 0 : options.signal);
            case 13:
              _context41.next = 20;
              break;
            case 15:
              _context41.prev = 15;
              _context41.t0 = _context41["catch"](9);
              _context41.next = 19;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context41.t0);
            case 19:
              throw _context41.t0;
            case 20:
              _context41.next = 22;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(output);
            case 22:
              return _context41.abrupt("return", output);
            case 23:
            case "end":
              return _context41.stop();
          }
        }, _callee40, this, [[9, 15]]);
      }));
      function invoke(_x49, _x50) {
        return _invoke7.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_transform",
    value: function _transform(generator, runManager, options) {
      var _this11 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        var steps, inputCopies, tasks, _loop2;
        return _regeneratorRuntime().wrap(function _callee41$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              // shallow copy steps to ignore changes while iterating
              steps = _objectSpread({}, _this11.steps); // each step gets a copy of the input iterator
              inputCopies = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.atee)(generator, Object.keys(steps).length); // start the first iteration of each output iterator
              tasks = new Map(Object.entries(steps).map(function (_ref22, i) {
                var _ref23 = _slicedToArray(_ref22, 2),
                  key = _ref23[0],
                  runnable = _ref23[1];
                var gen = runnable.transform(inputCopies[i], (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(options, {
                  callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild("map:key:".concat(key))
                }));
                return [key, gen.next().then(function (result) {
                  return {
                    key: key,
                    gen: gen,
                    result: result
                  };
                })];
              })); // yield chunks as they become available,
              // starting new iterations as needed,
              // until all iterators are done
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var promise, _yield$_awaitAsyncGen, key, result, gen;
                return _regeneratorRuntime().wrap(function _loop2$(_context42) {
                  while (1) switch (_context42.prev = _context42.next) {
                    case 0:
                      promise = Promise.race(tasks.values());
                      _context42.next = 3;
                      return _awaitAsyncGenerator((0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options === null || options === void 0 ? void 0 : options.signal));
                    case 3:
                      _yield$_awaitAsyncGen = _context42.sent;
                      key = _yield$_awaitAsyncGen.key;
                      result = _yield$_awaitAsyncGen.result;
                      gen = _yield$_awaitAsyncGen.gen;
                      tasks["delete"](key);
                      if (result.done) {
                        _context42.next = 12;
                        break;
                      }
                      _context42.next = 11;
                      return _defineProperty({}, key, result.value);
                    case 11:
                      tasks.set(key, gen.next().then(function (result) {
                        return {
                          key: key,
                          gen: gen,
                          result: result
                        };
                      }));
                    case 12:
                    case "end":
                      return _context42.stop();
                  }
                }, _loop2);
              });
            case 4:
              if (!tasks.size) {
                _context43.next = 8;
                break;
              }
              return _context43.delegateYield(_loop2(), "t0", 6);
            case 6:
              _context43.next = 4;
              break;
            case 8:
            case "end":
              return _context43.stop();
          }
        }, _callee41);
      }))();
    }
  }, {
    key: "transform",
    value: function transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
  }, {
    key: "stream",
    value: function () {
      var _stream3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43(input, options) {
        var generator, _generator, config, wrappedGenerator;
        return _regeneratorRuntime().wrap(function _callee43$(_context45) {
          while (1) switch (_context45.prev = _context45.next) {
            case 0:
              _generator = function _generator6() {
                _generator = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
                  return _regeneratorRuntime().wrap(function _callee42$(_context44) {
                    while (1) switch (_context44.prev = _context44.next) {
                      case 0:
                        _context44.next = 2;
                        return input;
                      case 2:
                      case "end":
                        return _context44.stop();
                    }
                  }, _callee42);
                }));
                return _generator.apply(this, arguments);
              };
              generator = function _generator5() {
                return _generator.apply(this, arguments);
              };
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({
                generator: this.transform(generator(), config),
                config: config
              });
              _context45.next = 6;
              return wrappedGenerator.setup;
            case 6:
              return _context45.abrupt("return", _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator));
            case 7:
            case "end":
              return _context45.stop();
          }
        }, _callee43, this);
      }));
      function stream(_x52, _x53) {
        return _stream3.apply(this, arguments);
      }
      return stream;
    }()
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableMap";
    }
  }, {
    key: "from",
    value: function from(steps) {
      return new RunnableMap({
        steps: steps
      });
    }
  }]);
}(Runnable);
/**
 * A runnable that wraps a traced LangSmith function.
 */
var RunnableTraceable = /*#__PURE__*/function (_Runnable5) {
  function RunnableTraceable(fields) {
    var _this30;
    _classCallCheck(this, RunnableTraceable);
    _this30 = _callSuper(this, RunnableTraceable, [fields]);
    Object.defineProperty(_this30, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this30, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this30, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (!(0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(fields.func)) {
      throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    }
    _this30.func = fields.func;
    return _this30;
  }
  _inherits(RunnableTraceable, _Runnable5);
  return _createClass(RunnableTraceable, [{
    key: "invoke",
    value: function () {
      var _invoke8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(input, options) {
        var _this$_getOptionsList, _this$_getOptionsList2, config, callbacks, promise;
        return _regeneratorRuntime().wrap(function _callee44$(_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              _this$_getOptionsList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, 1), _this$_getOptionsList2 = _slicedToArray(_this$_getOptionsList, 1), config = _this$_getOptionsList2[0];
              _context46.next = 3;
              return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);
            case 3:
              callbacks = _context46.sent;
              promise = this.func((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                callbacks: callbacks
              }), input);
              return _context46.abrupt("return", (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, config === null || config === void 0 ? void 0 : config.signal));
            case 6:
            case "end":
              return _context46.stop();
          }
        }, _callee44, this);
      }));
      function invoke(_x54, _x55) {
        return _invoke8.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_streamIterator",
    value: function _streamIterator(input, options) {
      var _this12 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {
        var _this12$_getOptionsLi, _this12$_getOptionsLi2, config, result, _iteratorAbruptCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, item, _config$signal, _config$signal2, state;
        return _regeneratorRuntime().wrap(function _callee45$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              _this12$_getOptionsLi = _this12._getOptionsList(options !== null && options !== void 0 ? options : {}, 1), _this12$_getOptionsLi2 = _slicedToArray(_this12$_getOptionsLi, 1), config = _this12$_getOptionsLi2[0];
              _context47.next = 3;
              return _awaitAsyncGenerator(_this12.invoke(input, options));
            case 3:
              result = _context47.sent;
              if (!(0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(result)) {
                _context47.next = 36;
                break;
              }
              _iteratorAbruptCompletion10 = false;
              _didIteratorError10 = false;
              _context47.prev = 7;
              _iterator10 = _asyncIterator(result);
            case 9:
              _context47.next = 11;
              return _awaitAsyncGenerator(_iterator10.next());
            case 11:
              if (!(_iteratorAbruptCompletion10 = !(_step10 = _context47.sent).done)) {
                _context47.next = 19;
                break;
              }
              item = _step10.value;
              config === null || config === void 0 || (_config$signal = config.signal) === null || _config$signal === void 0 || _config$signal.throwIfAborted();
              _context47.next = 16;
              return item;
            case 16:
              _iteratorAbruptCompletion10 = false;
              _context47.next = 9;
              break;
            case 19:
              _context47.next = 25;
              break;
            case 21:
              _context47.prev = 21;
              _context47.t0 = _context47["catch"](7);
              _didIteratorError10 = true;
              _iteratorError10 = _context47.t0;
            case 25:
              _context47.prev = 25;
              _context47.prev = 26;
              if (!(_iteratorAbruptCompletion10 && _iterator10["return"] != null)) {
                _context47.next = 30;
                break;
              }
              _context47.next = 30;
              return _awaitAsyncGenerator(_iterator10["return"]());
            case 30:
              _context47.prev = 30;
              if (!_didIteratorError10) {
                _context47.next = 33;
                break;
              }
              throw _iteratorError10;
            case 33:
              return _context47.finish(30);
            case 34:
              return _context47.finish(25);
            case 35:
              return _context47.abrupt("return");
            case 36:
              if (!(0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterator)(result)) {
                _context47.next = 47;
                break;
              }
            case 37:
              if (false) {}
              config === null || config === void 0 || (_config$signal2 = config.signal) === null || _config$signal2 === void 0 || _config$signal2.throwIfAborted();
              state = result.next();
              if (!state.done) {
                _context47.next = 42;
                break;
              }
              return _context47.abrupt("break", 46);
            case 42:
              _context47.next = 44;
              return state.value;
            case 44:
              _context47.next = 37;
              break;
            case 46:
              return _context47.abrupt("return");
            case 47:
              _context47.next = 49;
              return result;
            case 49:
            case "end":
              return _context47.stop();
          }
        }, _callee45, null, [[7, 21, 25, 35], [26,, 30, 34]]);
      }))();
    }
  }], [{
    key: "from",
    value: function from(func) {
      return new RunnableTraceable({
        func: func
      });
    }
  }]);
}(Runnable);
function assertNonTraceableFunction(func) {
  if ((0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(func)) {
    throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
  }
}
/**
 * A runnable that wraps an arbitrary function that takes a single argument.
 * @example
 * ```typescript
 * import { RunnableLambda } from "@langchain/core/runnables";
 *
 * const add = (input: { x: number; y: number }) => input.x + input.y;
 *
 * const multiply = (input: { value: number; multiplier: number }) =>
 *   input.value * input.multiplier;
 *
 * // Create runnables for the functions
 * const addLambda = RunnableLambda.from(add);
 * const multiplyLambda = RunnableLambda.from(multiply);
 *
 * // Chain the lambdas for a mathematical operation
 * const chainedLambda = addLambda.pipe((result) =>
 *   multiplyLambda.invoke({ value: result, multiplier: 2 })
 * );
 *
 * // Example invocation of the chainedLambda
 * const result = await chainedLambda.invoke({ x: 2, y: 3 });
 *
 * // Will log "10" (since (2 + 3) * 2 = 10)
 * ```
 */
var RunnableLambda = /*#__PURE__*/function (_Runnable6) {
  function RunnableLambda(fields) {
    var _this31;
    _classCallCheck(this, RunnableLambda);
    if ((0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(fields.func)) {
      // eslint-disable-next-line no-constructor-return
      return _possibleConstructorReturn(_this31, RunnableTraceable.from(fields.func));
    }
    _this31 = _callSuper(this, RunnableLambda, [fields]);
    Object.defineProperty(_this31, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this31, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    assertNonTraceableFunction(fields.func);
    _this31.func = fields.func;
    return _this31;
  }
  _inherits(RunnableLambda, _Runnable6);
  return _createClass(RunnableLambda, [{
    key: "_invoke",
    value: function () {
      var _invoke9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(input, config, runManager) {
        var _this32 = this;
        return _regeneratorRuntime().wrap(function _callee47$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              return _context49.abrupt("return", new Promise(function (resolve, reject) {
                var _config$recursionLimi;
                var childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                  callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(),
                  recursionLimit: ((_config$recursionLimi = config === null || config === void 0 ? void 0 : config.recursionLimit) !== null && _config$recursionLimi !== void 0 ? _config$recursionLimi : _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1
                });
                void _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {
                  var output, _childConfig$recursio, finalOutput, _iteratorAbruptCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, chunk, _config$signal3, _finalOutput2, _iterator20, _step20, _config$signal4, _chunk;
                  return _regeneratorRuntime().wrap(function _callee46$(_context48) {
                    while (1) switch (_context48.prev = _context48.next) {
                      case 0:
                        _context48.prev = 0;
                        _context48.next = 3;
                        return _this32.func(input, _objectSpread({}, childConfig));
                      case 3:
                        output = _context48.sent;
                        if (!(output && Runnable.isRunnable(output))) {
                          _context48.next = 12;
                          break;
                        }
                        if (!((config === null || config === void 0 ? void 0 : config.recursionLimit) === 0)) {
                          _context48.next = 7;
                          break;
                        }
                        throw new Error("Recursion limit reached.");
                      case 7:
                        _context48.next = 9;
                        return output.invoke(input, _objectSpread(_objectSpread({}, childConfig), {}, {
                          recursionLimit: ((_childConfig$recursio = childConfig.recursionLimit) !== null && _childConfig$recursio !== void 0 ? _childConfig$recursio : _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1
                        }));
                      case 9:
                        output = _context48.sent;
                        _context48.next = 46;
                        break;
                      case 12:
                        if (!(0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(output)) {
                          _context48.next = 45;
                          break;
                        }
                        _iteratorAbruptCompletion11 = false;
                        _didIteratorError11 = false;
                        _context48.prev = 15;
                        _iterator11 = _asyncIterator((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, output));
                      case 17:
                        _context48.next = 19;
                        return _iterator11.next();
                      case 19:
                        if (!(_iteratorAbruptCompletion11 = !(_step11 = _context48.sent).done)) {
                          _context48.next = 26;
                          break;
                        }
                        chunk = _step11.value;
                        config === null || config === void 0 || (_config$signal3 = config.signal) === null || _config$signal3 === void 0 || _config$signal3.throwIfAborted();
                        if (finalOutput === undefined) {
                          finalOutput = chunk;
                        } else {
                          // Make a best effort to gather, for any type that supports concat.
                          try {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);
                          } catch (e) {
                            finalOutput = chunk;
                          }
                        }
                      case 23:
                        _iteratorAbruptCompletion11 = false;
                        _context48.next = 17;
                        break;
                      case 26:
                        _context48.next = 32;
                        break;
                      case 28:
                        _context48.prev = 28;
                        _context48.t0 = _context48["catch"](15);
                        _didIteratorError11 = true;
                        _iteratorError11 = _context48.t0;
                      case 32:
                        _context48.prev = 32;
                        _context48.prev = 33;
                        if (!(_iteratorAbruptCompletion11 && _iterator11["return"] != null)) {
                          _context48.next = 37;
                          break;
                        }
                        _context48.next = 37;
                        return _iterator11["return"]();
                      case 37:
                        _context48.prev = 37;
                        if (!_didIteratorError11) {
                          _context48.next = 40;
                          break;
                        }
                        throw _iteratorError11;
                      case 40:
                        return _context48.finish(37);
                      case 41:
                        return _context48.finish(32);
                      case 42:
                        output = finalOutput;
                        _context48.next = 46;
                        break;
                      case 45:
                        if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterableIterator)(output)) {
                          _iterator20 = _createForOfIteratorHelper((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeIteratorInContext)(childConfig, output));
                          try {
                            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                              _chunk = _step20.value;
                              config === null || config === void 0 || (_config$signal4 = config.signal) === null || _config$signal4 === void 0 || _config$signal4.throwIfAborted();
                              if (_finalOutput2 === undefined) {
                                _finalOutput2 = _chunk;
                              } else {
                                // Make a best effort to gather, for any type that supports concat.
                                try {
                                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                  _finalOutput2 = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(_finalOutput2, _chunk);
                                } catch (e) {
                                  _finalOutput2 = _chunk;
                                }
                              }
                            }
                          } catch (err) {
                            _iterator20.e(err);
                          } finally {
                            _iterator20.f();
                          }
                          output = _finalOutput2;
                        }
                      case 46:
                        resolve(output);
                        _context48.next = 52;
                        break;
                      case 49:
                        _context48.prev = 49;
                        _context48.t1 = _context48["catch"](0);
                        reject(_context48.t1);
                      case 52:
                      case "end":
                        return _context48.stop();
                    }
                  }, _callee46, null, [[0, 49], [15, 28, 32, 42], [33,, 37, 41]]);
                })));
              }));
            case 1:
            case "end":
              return _context49.stop();
          }
        }, _callee47);
      }));
      function _invoke(_x56, _x57, _x58) {
        return _invoke9.apply(this, arguments);
      }
      return _invoke;
    }()
  }, {
    key: "invoke",
    value: function () {
      var _invoke10 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48(input, options) {
        return _regeneratorRuntime().wrap(function _callee48$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              return _context50.abrupt("return", this._callWithConfig(this._invoke.bind(this), input, options));
            case 1:
            case "end":
              return _context50.stop();
          }
        }, _callee48, this);
      }));
      function invoke(_x59, _x60) {
        return _invoke10.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_transform",
    value: function _transform(generator, runManager, config) {
      var _this13 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee50() {
        var _config$recursionLimi2;
        var finalChunk, _iteratorAbruptCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, chunk, childConfig, output, stream, _iteratorAbruptCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, _chunk2, _iteratorAbruptCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, _chunk3, _config$signal5, _iterator21, _step21, _config$signal6, _chunk4;
        return _regeneratorRuntime().wrap(function _callee50$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              _iteratorAbruptCompletion12 = false;
              _didIteratorError12 = false;
              _context52.prev = 2;
              _iterator12 = _asyncIterator(generator);
            case 4:
              _context52.next = 6;
              return _awaitAsyncGenerator(_iterator12.next());
            case 6:
              if (!(_iteratorAbruptCompletion12 = !(_step12 = _context52.sent).done)) {
                _context52.next = 12;
                break;
              }
              chunk = _step12.value;
              if (finalChunk === undefined) {
                finalChunk = chunk;
              } else {
                // Make a best effort to gather, for any type that supports concat.
                try {
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  finalChunk = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalChunk, chunk);
                } catch (e) {
                  finalChunk = chunk;
                }
              }
            case 9:
              _iteratorAbruptCompletion12 = false;
              _context52.next = 4;
              break;
            case 12:
              _context52.next = 18;
              break;
            case 14:
              _context52.prev = 14;
              _context52.t0 = _context52["catch"](2);
              _didIteratorError12 = true;
              _iteratorError12 = _context52.t0;
            case 18:
              _context52.prev = 18;
              _context52.prev = 19;
              if (!(_iteratorAbruptCompletion12 && _iterator12["return"] != null)) {
                _context52.next = 23;
                break;
              }
              _context52.next = 23;
              return _awaitAsyncGenerator(_iterator12["return"]());
            case 23:
              _context52.prev = 23;
              if (!_didIteratorError12) {
                _context52.next = 26;
                break;
              }
              throw _iteratorError12;
            case 26:
              return _context52.finish(23);
            case 27:
              return _context52.finish(18);
            case 28:
              childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(),
                recursionLimit: ((_config$recursionLimi2 = config === null || config === void 0 ? void 0 : config.recursionLimit) !== null && _config$recursionLimi2 !== void 0 ? _config$recursionLimi2 : _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1
              });
              _context52.next = 31;
              return _awaitAsyncGenerator(new Promise(function (resolve, reject) {
                void _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49() {
                  var res;
                  return _regeneratorRuntime().wrap(function _callee49$(_context51) {
                    while (1) switch (_context51.prev = _context51.next) {
                      case 0:
                        _context51.prev = 0;
                        _context51.next = 3;
                        return _this13.func(finalChunk, _objectSpread(_objectSpread({}, childConfig), {}, {
                          config: childConfig
                        }));
                      case 3:
                        res = _context51.sent;
                        resolve(res);
                        _context51.next = 10;
                        break;
                      case 7:
                        _context51.prev = 7;
                        _context51.t0 = _context51["catch"](0);
                        reject(_context51.t0);
                      case 10:
                      case "end":
                        return _context51.stop();
                    }
                  }, _callee49, null, [[0, 7]]);
                })));
              }));
            case 31:
              output = _context52.sent;
              if (!(output && Runnable.isRunnable(output))) {
                _context52.next = 69;
                break;
              }
              if (!((config === null || config === void 0 ? void 0 : config.recursionLimit) === 0)) {
                _context52.next = 35;
                break;
              }
              throw new Error("Recursion limit reached.");
            case 35:
              _context52.next = 37;
              return _awaitAsyncGenerator(output.stream(finalChunk, childConfig));
            case 37:
              stream = _context52.sent;
              _iteratorAbruptCompletion13 = false;
              _didIteratorError13 = false;
              _context52.prev = 40;
              _iterator13 = _asyncIterator(stream);
            case 42:
              _context52.next = 44;
              return _awaitAsyncGenerator(_iterator13.next());
            case 44:
              if (!(_iteratorAbruptCompletion13 = !(_step13 = _context52.sent).done)) {
                _context52.next = 51;
                break;
              }
              _chunk2 = _step13.value;
              _context52.next = 48;
              return _chunk2;
            case 48:
              _iteratorAbruptCompletion13 = false;
              _context52.next = 42;
              break;
            case 51:
              _context52.next = 57;
              break;
            case 53:
              _context52.prev = 53;
              _context52.t1 = _context52["catch"](40);
              _didIteratorError13 = true;
              _iteratorError13 = _context52.t1;
            case 57:
              _context52.prev = 57;
              _context52.prev = 58;
              if (!(_iteratorAbruptCompletion13 && _iterator13["return"] != null)) {
                _context52.next = 62;
                break;
              }
              _context52.next = 62;
              return _awaitAsyncGenerator(_iterator13["return"]());
            case 62:
              _context52.prev = 62;
              if (!_didIteratorError13) {
                _context52.next = 65;
                break;
              }
              throw _iteratorError13;
            case 65:
              return _context52.finish(62);
            case 66:
              return _context52.finish(57);
            case 67:
              _context52.next = 125;
              break;
            case 69:
              if (!(0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(output)) {
                _context52.next = 102;
                break;
              }
              _iteratorAbruptCompletion14 = false;
              _didIteratorError14 = false;
              _context52.prev = 72;
              _iterator14 = _asyncIterator((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, output));
            case 74:
              _context52.next = 76;
              return _awaitAsyncGenerator(_iterator14.next());
            case 76:
              if (!(_iteratorAbruptCompletion14 = !(_step14 = _context52.sent).done)) {
                _context52.next = 84;
                break;
              }
              _chunk3 = _step14.value;
              config === null || config === void 0 || (_config$signal5 = config.signal) === null || _config$signal5 === void 0 || _config$signal5.throwIfAborted();
              _context52.next = 81;
              return _chunk3;
            case 81:
              _iteratorAbruptCompletion14 = false;
              _context52.next = 74;
              break;
            case 84:
              _context52.next = 90;
              break;
            case 86:
              _context52.prev = 86;
              _context52.t2 = _context52["catch"](72);
              _didIteratorError14 = true;
              _iteratorError14 = _context52.t2;
            case 90:
              _context52.prev = 90;
              _context52.prev = 91;
              if (!(_iteratorAbruptCompletion14 && _iterator14["return"] != null)) {
                _context52.next = 95;
                break;
              }
              _context52.next = 95;
              return _awaitAsyncGenerator(_iterator14["return"]());
            case 95:
              _context52.prev = 95;
              if (!_didIteratorError14) {
                _context52.next = 98;
                break;
              }
              throw _iteratorError14;
            case 98:
              return _context52.finish(95);
            case 99:
              return _context52.finish(90);
            case 100:
              _context52.next = 125;
              break;
            case 102:
              if (!(0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterableIterator)(output)) {
                _context52.next = 123;
                break;
              }
              _iterator21 = _createForOfIteratorHelper((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeIteratorInContext)(childConfig, output));
              _context52.prev = 104;
              _iterator21.s();
            case 106:
              if ((_step21 = _iterator21.n()).done) {
                _context52.next = 113;
                break;
              }
              _chunk4 = _step21.value;
              config === null || config === void 0 || (_config$signal6 = config.signal) === null || _config$signal6 === void 0 || _config$signal6.throwIfAborted();
              _context52.next = 111;
              return _chunk4;
            case 111:
              _context52.next = 106;
              break;
            case 113:
              _context52.next = 118;
              break;
            case 115:
              _context52.prev = 115;
              _context52.t3 = _context52["catch"](104);
              _iterator21.e(_context52.t3);
            case 118:
              _context52.prev = 118;
              _iterator21.f();
              return _context52.finish(118);
            case 121:
              _context52.next = 125;
              break;
            case 123:
              _context52.next = 125;
              return output;
            case 125:
            case "end":
              return _context52.stop();
          }
        }, _callee50, null, [[2, 14, 18, 28], [19,, 23, 27], [40, 53, 57, 67], [58,, 62, 66], [72, 86, 90, 100], [91,, 95, 99], [104, 115, 118, 121]]);
      }))();
    }
  }, {
    key: "transform",
    value: function transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
  }, {
    key: "stream",
    value: function () {
      var _stream4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee52(input, options) {
        var generator, _generator2, config, wrappedGenerator;
        return _regeneratorRuntime().wrap(function _callee52$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              _generator2 = function _generator8() {
                _generator2 = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {
                  return _regeneratorRuntime().wrap(function _callee51$(_context53) {
                    while (1) switch (_context53.prev = _context53.next) {
                      case 0:
                        _context53.next = 2;
                        return input;
                      case 2:
                      case "end":
                        return _context53.stop();
                    }
                  }, _callee51);
                }));
                return _generator2.apply(this, arguments);
              };
              generator = function _generator7() {
                return _generator2.apply(this, arguments);
              };
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({
                generator: this.transform(generator(), config),
                config: config
              });
              _context54.next = 6;
              return wrappedGenerator.setup;
            case 6:
              return _context54.abrupt("return", _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator));
            case 7:
            case "end":
              return _context54.stop();
          }
        }, _callee52, this);
      }));
      function stream(_x61, _x62) {
        return _stream4.apply(this, arguments);
      }
      return stream;
    }()
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableLambda";
    }
  }, {
    key: "from",
    value: function from(func) {
      return new RunnableLambda({
        func: func
      });
    }
  }]);
}(Runnable);
/**
 * A runnable that runs a mapping of runnables in parallel,
 * and returns a mapping of their outputs.
 * @example
 * ```typescript
 * import {
 *   RunnableLambda,
 *   RunnableParallel,
 * } from "@langchain/core/runnables";
 *
 * const addYears = (age: number): number => age + 5;
 * const yearsToFifty = (age: number): number => 50 - age;
 * const yearsToHundred = (age: number): number => 100 - age;
 *
 * const addYearsLambda = RunnableLambda.from(addYears);
 * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);
 * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);
 *
 * // Pipe will coerce objects into RunnableParallel by default, but we
 * // explicitly instantiate one here to demonstrate
 * const sequence = addYearsLambda.pipe(
 *   RunnableParallel.from({
 *     years_to_fifty: milestoneFiftyLambda,
 *     years_to_hundred: milestoneHundredLambda,
 *   })
 * );
 *
 * // Invoke the sequence with a single age input
 * const res = sequence.invoke(25);
 *
 * // { years_to_fifty: 25, years_to_hundred: 75 }
 * ```
 */
var RunnableParallel = /*#__PURE__*/function (_RunnableMap) {
  function RunnableParallel() {
    _classCallCheck(this, RunnableParallel);
    return _callSuper(this, RunnableParallel, arguments);
  }
  _inherits(RunnableParallel, _RunnableMap);
  return _createClass(RunnableParallel);
}(RunnableMap);
/**
 * A Runnable that can fallback to other Runnables if it fails.
 * External APIs (e.g., APIs for a language model) may at times experience
 * degraded performance or even downtime.
 *
 * In these cases, it can be useful to have a fallback Runnable that can be
 * used in place of the original Runnable (e.g., fallback to another LLM provider).
 *
 * Fallbacks can be defined at the level of a single Runnable, or at the level
 * of a chain of Runnables. Fallbacks are tried in order until one succeeds or
 * all fail.
 *
 * While you can instantiate a `RunnableWithFallbacks` directly, it is usually
 * more convenient to use the `withFallbacks` method on an existing Runnable.
 *
 * When streaming, fallbacks will only be called on failures during the initial
 * stream creation. Errors that occur after a stream starts will not fallback
 * to the next Runnable.
 *
 * @example
 * ```typescript
 * import {
 *   RunnableLambda,
 *   RunnableWithFallbacks,
 * } from "@langchain/core/runnables";
 *
 * const primaryOperation = (input: string): string => {
 *   if (input !== "safe") {
 *     throw new Error("Primary operation failed due to unsafe input");
 *   }
 *   return `Processed: ${input}`;
 * };
 *
 * // Define a fallback operation that processes the input differently
 * const fallbackOperation = (input: string): string =>
 *   `Fallback processed: ${input}`;
 *
 * const primaryRunnable = RunnableLambda.from(primaryOperation);
 * const fallbackRunnable = RunnableLambda.from(fallbackOperation);
 *
 * // Apply the fallback logic using the .withFallbacks() method
 * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);
 *
 * // Alternatively, create a RunnableWithFallbacks instance manually
 * const manualFallbackChain = new RunnableWithFallbacks({
 *   runnable: primaryRunnable,
 *   fallbacks: [fallbackRunnable],
 * });
 *
 * // Example invocation using .withFallbacks()
 * const res = await runnableWithFallback
 *   .invoke("unsafe input")
 *   .catch((error) => {
 *     console.error("Failed after all attempts:", error.message);
 *   });
 *
 * // "Fallback processed: unsafe input"
 *
 * // Example invocation using manual instantiation
 * const res = await manualFallbackChain
 *   .invoke("safe")
 *   .catch((error) => {
 *     console.error("Failed after all attempts:", error.message);
 *   });
 *
 * // "Processed: safe"
 * ```
 */
var RunnableWithFallbacks = /*#__PURE__*/function (_Runnable7) {
  function RunnableWithFallbacks(fields) {
    var _this33;
    _classCallCheck(this, RunnableWithFallbacks);
    _this33 = _callSuper(this, RunnableWithFallbacks, [fields]);
    Object.defineProperty(_this33, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this33, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this33, "runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this33, "fallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this33.runnable = fields.runnable;
    _this33.fallbacks = fields.fallbacks;
    return _this33;
  }
  _inherits(RunnableWithFallbacks, _Runnable7);
  return _createClass(RunnableWithFallbacks, [{
    key: "runnables",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function runnables() {
      var _iterator22, _step22, fallback;
      return _regeneratorRuntime().wrap(function runnables$(_context55) {
        while (1) switch (_context55.prev = _context55.next) {
          case 0:
            _context55.next = 2;
            return this.runnable;
          case 2:
            _iterator22 = _createForOfIteratorHelper(this.fallbacks);
            _context55.prev = 3;
            _iterator22.s();
          case 5:
            if ((_step22 = _iterator22.n()).done) {
              _context55.next = 11;
              break;
            }
            fallback = _step22.value;
            _context55.next = 9;
            return fallback;
          case 9:
            _context55.next = 5;
            break;
          case 11:
            _context55.next = 16;
            break;
          case 13:
            _context55.prev = 13;
            _context55.t0 = _context55["catch"](3);
            _iterator22.e(_context55.t0);
          case 16:
            _context55.prev = 16;
            _iterator22.f();
            return _context55.finish(16);
          case 19:
          case "end":
            return _context55.stop();
        }
      }, runnables, this, [[3, 13, 16, 19]]);
    })
  }, {
    key: "invoke",
    value: function () {
      var _invoke11 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee53(input, options) {
        var config, callbackManager_, runId, otherConfigFields, runManager, firstError, _iterator23, _step23, _config$signal7, runnable, output;
        return _regeneratorRuntime().wrap(function _callee53$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              _context56.next = 3;
              return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options);
            case 3:
              callbackManager_ = _context56.sent;
              runId = config.runId, otherConfigFields = _objectWithoutProperties(config, _excluded2);
              _context56.next = 7;
              return callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, undefined, undefined, undefined, otherConfigFields === null || otherConfigFields === void 0 ? void 0 : otherConfigFields.runName);
            case 7:
              runManager = _context56.sent;
              _iterator23 = _createForOfIteratorHelper(this.runnables());
              _context56.prev = 9;
              _iterator23.s();
            case 11:
              if ((_step23 = _iterator23.n()).done) {
                _context56.next = 28;
                break;
              }
              runnable = _step23.value;
              config === null || config === void 0 || (_config$signal7 = config.signal) === null || _config$signal7 === void 0 || _config$signal7.throwIfAborted();
              _context56.prev = 14;
              _context56.next = 17;
              return runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherConfigFields, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()
              }));
            case 17:
              output = _context56.sent;
              _context56.next = 20;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output"));
            case 20:
              return _context56.abrupt("return", output);
            case 23:
              _context56.prev = 23;
              _context56.t0 = _context56["catch"](14);
              if (firstError === undefined) {
                firstError = _context56.t0;
              }
            case 26:
              _context56.next = 11;
              break;
            case 28:
              _context56.next = 33;
              break;
            case 30:
              _context56.prev = 30;
              _context56.t1 = _context56["catch"](9);
              _iterator23.e(_context56.t1);
            case 33:
              _context56.prev = 33;
              _iterator23.f();
              return _context56.finish(33);
            case 36:
              if (!(firstError === undefined)) {
                _context56.next = 38;
                break;
              }
              throw new Error("No error stored at end of fallback.");
            case 38:
              _context56.next = 40;
              return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(firstError);
            case 40:
              throw firstError;
            case 41:
            case "end":
              return _context56.stop();
          }
        }, _callee53, this, [[9, 30, 33, 36], [14, 23]]);
      }));
      function invoke(_x63, _x64) {
        return _invoke11.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_streamIterator",
    value: function _streamIterator(input, options) {
      var _this14 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee54() {
        var config, callbackManager_, runId, otherConfigFields, runManager, firstError, stream, _iterator24, _step24, _config$signal8, runnable, childConfig, _firstError, error, output, _iteratorAbruptCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, chunk;
        return _regeneratorRuntime().wrap(function _callee54$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              _context57.next = 3;
              return _awaitAsyncGenerator((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options));
            case 3:
              callbackManager_ = _context57.sent;
              runId = config.runId, otherConfigFields = _objectWithoutProperties(config, _excluded3);
              _context57.next = 7;
              return _awaitAsyncGenerator(callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(_this14.toJSON(), _coerceToDict(input, "input"), runId, undefined, undefined, undefined, otherConfigFields === null || otherConfigFields === void 0 ? void 0 : otherConfigFields.runName));
            case 7:
              runManager = _context57.sent;
              _iterator24 = _createForOfIteratorHelper(_this14.runnables());
              _context57.prev = 9;
              _iterator24.s();
            case 11:
              if ((_step24 = _iterator24.n()).done) {
                _context57.next = 27;
                break;
              }
              runnable = _step24.value;
              config === null || config === void 0 || (_config$signal8 = config.signal) === null || _config$signal8 === void 0 || _config$signal8.throwIfAborted();
              childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherConfigFields, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()
              });
              _context57.prev = 15;
              _context57.next = 18;
              return _awaitAsyncGenerator(runnable.stream(input, childConfig));
            case 18:
              stream = _context57.sent;
              return _context57.abrupt("break", 27);
            case 22:
              _context57.prev = 22;
              _context57.t0 = _context57["catch"](15);
              if (firstError === undefined) {
                firstError = _context57.t0;
              }
            case 25:
              _context57.next = 11;
              break;
            case 27:
              _context57.next = 32;
              break;
            case 29:
              _context57.prev = 29;
              _context57.t1 = _context57["catch"](9);
              _iterator24.e(_context57.t1);
            case 32:
              _context57.prev = 32;
              _iterator24.f();
              return _context57.finish(32);
            case 35:
              if (!(stream === undefined)) {
                _context57.next = 40;
                break;
              }
              error = (_firstError = firstError) !== null && _firstError !== void 0 ? _firstError : new Error("No error stored at end of fallback.");
              _context57.next = 39;
              return _awaitAsyncGenerator(runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(error));
            case 39:
              throw error;
            case 40:
              _context57.prev = 40;
              _iteratorAbruptCompletion15 = false;
              _didIteratorError15 = false;
              _context57.prev = 43;
              _iterator15 = _asyncIterator(stream);
            case 45:
              _context57.next = 47;
              return _awaitAsyncGenerator(_iterator15.next());
            case 47:
              if (!(_iteratorAbruptCompletion15 = !(_step15 = _context57.sent).done)) {
                _context57.next = 55;
                break;
              }
              chunk = _step15.value;
              _context57.next = 51;
              return chunk;
            case 51:
              try {
                output = output === undefined ? output : (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(output, chunk);
              } catch (e) {
                output = undefined;
              }
            case 52:
              _iteratorAbruptCompletion15 = false;
              _context57.next = 45;
              break;
            case 55:
              _context57.next = 61;
              break;
            case 57:
              _context57.prev = 57;
              _context57.t2 = _context57["catch"](43);
              _didIteratorError15 = true;
              _iteratorError15 = _context57.t2;
            case 61:
              _context57.prev = 61;
              _context57.prev = 62;
              if (!(_iteratorAbruptCompletion15 && _iterator15["return"] != null)) {
                _context57.next = 66;
                break;
              }
              _context57.next = 66;
              return _awaitAsyncGenerator(_iterator15["return"]());
            case 66:
              _context57.prev = 66;
              if (!_didIteratorError15) {
                _context57.next = 69;
                break;
              }
              throw _iteratorError15;
            case 69:
              return _context57.finish(66);
            case 70:
              return _context57.finish(61);
            case 71:
              _context57.next = 78;
              break;
            case 73:
              _context57.prev = 73;
              _context57.t3 = _context57["catch"](40);
              _context57.next = 77;
              return _awaitAsyncGenerator(runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(_context57.t3));
            case 77:
              throw _context57.t3;
            case 78:
              _context57.next = 80;
              return _awaitAsyncGenerator(runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
            case 80:
            case "end":
              return _context57.stop();
          }
        }, _callee54, null, [[9, 29, 32, 35], [15, 22], [40, 73], [43, 57, 61, 71], [62,, 66, 70]]);
      }))();
    }
  }, {
    key: "batch",
    value: function () {
      var _batch6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee56(inputs, options, batchOptions) {
        var _this34 = this;
        var configList, callbackManagers, runManagers, firstError, _iterator25, _step25, _loop3, _ret;
        return _regeneratorRuntime().wrap(function _callee56$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              if (!(batchOptions !== null && batchOptions !== void 0 && batchOptions.returnExceptions)) {
                _context60.next = 2;
                break;
              }
              throw new Error("Not implemented.");
            case 2:
              configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);
              _context60.next = 5;
              return Promise.all(configList.map(function (config) {
                return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);
              }));
            case 5:
              callbackManagers = _context60.sent;
              _context60.next = 8;
              return Promise.all(callbackManagers.map(/*#__PURE__*/function () {
                var _ref26 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee55(callbackManager, i) {
                  var handleStartRes;
                  return _regeneratorRuntime().wrap(function _callee55$(_context58) {
                    while (1) switch (_context58.prev = _context58.next) {
                      case 0:
                        _context58.next = 2;
                        return callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(_this34.toJSON(), _coerceToDict(inputs[i], "input"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);
                      case 2:
                        handleStartRes = _context58.sent;
                        delete configList[i].runId;
                        return _context58.abrupt("return", handleStartRes);
                      case 5:
                      case "end":
                        return _context58.stop();
                    }
                  }, _callee55);
                }));
                return function (_x68, _x69) {
                  return _ref26.apply(this, arguments);
                };
              }()));
            case 8:
              runManagers = _context60.sent;
              _iterator25 = _createForOfIteratorHelper(this.runnables());
              _context60.prev = 10;
              _loop3 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop3() {
                var _configList$0$signal;
                var runnable, outputs;
                return _regeneratorRuntime().wrap(function _loop3$(_context59) {
                  while (1) switch (_context59.prev = _context59.next) {
                    case 0:
                      runnable = _step25.value;
                      (_configList$0$signal = configList[0].signal) === null || _configList$0$signal === void 0 || _configList$0$signal.throwIfAborted();
                      _context59.prev = 2;
                      _context59.next = 5;
                      return runnable.batch(inputs, runManagers.map(function (runManager, j) {
                        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(configList[j], {
                          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()
                        });
                      }), batchOptions);
                    case 5:
                      outputs = _context59.sent;
                      _context59.next = 8;
                      return Promise.all(runManagers.map(function (runManager, i) {
                        return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs[i], "output"));
                      }));
                    case 8:
                      return _context59.abrupt("return", {
                        v: outputs
                      });
                    case 11:
                      _context59.prev = 11;
                      _context59.t0 = _context59["catch"](2);
                      if (firstError === undefined) {
                        firstError = _context59.t0;
                      }
                    case 14:
                    case "end":
                      return _context59.stop();
                  }
                }, _loop3, null, [[2, 11]]);
              });
              _iterator25.s();
            case 13:
              if ((_step25 = _iterator25.n()).done) {
                _context60.next = 20;
                break;
              }
              return _context60.delegateYield(_loop3(), "t0", 15);
            case 15:
              _ret = _context60.t0;
              if (!_ret) {
                _context60.next = 18;
                break;
              }
              return _context60.abrupt("return", _ret.v);
            case 18:
              _context60.next = 13;
              break;
            case 20:
              _context60.next = 25;
              break;
            case 22:
              _context60.prev = 22;
              _context60.t1 = _context60["catch"](10);
              _iterator25.e(_context60.t1);
            case 25:
              _context60.prev = 25;
              _iterator25.f();
              return _context60.finish(25);
            case 28:
              if (firstError) {
                _context60.next = 30;
                break;
              }
              throw new Error("No error stored at end of fallbacks.");
            case 30:
              _context60.next = 32;
              return Promise.all(runManagers.map(function (runManager) {
                return runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(firstError);
              }));
            case 32:
              throw firstError;
            case 33:
            case "end":
              return _context60.stop();
          }
        }, _callee56, this, [[10, 22, 25, 28]]);
      }));
      function batch(_x65, _x66, _x67) {
        return _batch6.apply(this, arguments);
      }
      return batch;
    }()
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableWithFallbacks";
    }
  }]);
}(Runnable);
// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function") {
    return new RunnableLambda({
      func: coerceable
    });
  } else if (Runnable.isRunnable(coerceable)) {
    return coerceable;
  } else if (!Array.isArray(coerceable) && _typeof(coerceable) === "object") {
    var runnables = {};
    for (var _i2 = 0, _Object$entries2 = Object.entries(coerceable); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        key = _Object$entries2$_i[0],
        value = _Object$entries2$_i[1];
      runnables[key] = _coerceToRunnable(value);
    }
    return new RunnableMap({
      steps: runnables
    });
  } else {
    throw new Error("Expected a Runnable, function or object.\nInstead got an unsupported type.");
  }
}
/**
 * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.
 * @example
 * ```typescript
 * import {
 *   RunnableAssign,
 *   RunnableLambda,
 *   RunnableParallel,
 * } from "@langchain/core/runnables";
 *
 * const calculateAge = (x: { birthYear: number }): { age: number } => {
 *   const currentYear = new Date().getFullYear();
 *   return { age: currentYear - x.birthYear };
 * };
 *
 * const createGreeting = (x: { name: string }): { greeting: string } => {
 *   return { greeting: `Hello, ${x.name}!` };
 * };
 *
 * const mapper = RunnableParallel.from({
 *   age_step: RunnableLambda.from(calculateAge),
 *   greeting_step: RunnableLambda.from(createGreeting),
 * });
 *
 * const runnableAssign = new RunnableAssign({ mapper });
 *
 * const res = await runnableAssign.invoke({ name: "Alice", birthYear: 1990 });
 *
 * // { name: "Alice", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: "Hello, Alice!" } }
 * ```
 */
var RunnableAssign = /*#__PURE__*/function (_Runnable8) {
  function RunnableAssign(fields) {
    var _this35;
    _classCallCheck(this, RunnableAssign);
    // eslint-disable-next-line no-instanceof/no-instanceof
    if (fields instanceof RunnableMap) {
      // eslint-disable-next-line no-param-reassign
      fields = {
        mapper: fields
      };
    }
    _this35 = _callSuper(this, RunnableAssign, [fields]);
    Object.defineProperty(_this35, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this35, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this35, "mapper", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this35.mapper = fields.mapper;
    return _this35;
  }
  _inherits(RunnableAssign, _Runnable8);
  return _createClass(RunnableAssign, [{
    key: "invoke",
    value: function () {
      var _invoke12 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee57(input, options) {
        var mapperResult;
        return _regeneratorRuntime().wrap(function _callee57$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              _context61.next = 2;
              return this.mapper.invoke(input, options);
            case 2:
              mapperResult = _context61.sent;
              return _context61.abrupt("return", _objectSpread(_objectSpread({}, input), mapperResult));
            case 4:
            case "end":
              return _context61.stop();
          }
        }, _callee57, this);
      }));
      function invoke(_x70, _x71) {
        return _invoke12.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_transform",
    value: function _transform(generator, runManager, options) {
      var _this15 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {
        var mapperKeys, _atee, _atee2, forPassthrough, forMapper, mapperOutput, firstMapperChunkPromise, _iteratorAbruptCompletion16, _didIteratorError16, _iteratorError16, _iterator16, _step16, chunk, filtered, _iteratorAbruptCompletion17, _didIteratorError17, _iteratorError17, _iterator17, _step17, _chunk5;
        return _regeneratorRuntime().wrap(function _callee58$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              // collect mapper keys
              mapperKeys = _this15.mapper.getStepsKeys(); // create two input gens, one for the mapper, one for the input
              _atee = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.atee)(generator), _atee2 = _slicedToArray(_atee, 2), forPassthrough = _atee2[0], forMapper = _atee2[1]; // create mapper output gen
              mapperOutput = _this15.mapper.transform(forMapper, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(options, {
                callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()
              })); // start the mapper
              firstMapperChunkPromise = mapperOutput.next(); // yield the passthrough
              _iteratorAbruptCompletion16 = false;
              _didIteratorError16 = false;
              _context62.prev = 6;
              _iterator16 = _asyncIterator(forPassthrough);
            case 8:
              _context62.next = 10;
              return _awaitAsyncGenerator(_iterator16.next());
            case 10:
              if (!(_iteratorAbruptCompletion16 = !(_step16 = _context62.sent).done)) {
                _context62.next = 21;
                break;
              }
              chunk = _step16.value;
              if (!(_typeof(chunk) !== "object" || Array.isArray(chunk))) {
                _context62.next = 14;
                break;
              }
              throw new Error("RunnableAssign can only be used with objects as input, got ".concat(_typeof(chunk)));
            case 14:
              filtered = Object.fromEntries(Object.entries(chunk).filter(function (_ref27) {
                var _ref28 = _slicedToArray(_ref27, 1),
                  key = _ref28[0];
                return !mapperKeys.includes(key);
              }));
              if (!(Object.keys(filtered).length > 0)) {
                _context62.next = 18;
                break;
              }
              _context62.next = 18;
              return filtered;
            case 18:
              _iteratorAbruptCompletion16 = false;
              _context62.next = 8;
              break;
            case 21:
              _context62.next = 27;
              break;
            case 23:
              _context62.prev = 23;
              _context62.t0 = _context62["catch"](6);
              _didIteratorError16 = true;
              _iteratorError16 = _context62.t0;
            case 27:
              _context62.prev = 27;
              _context62.prev = 28;
              if (!(_iteratorAbruptCompletion16 && _iterator16["return"] != null)) {
                _context62.next = 32;
                break;
              }
              _context62.next = 32;
              return _awaitAsyncGenerator(_iterator16["return"]());
            case 32:
              _context62.prev = 32;
              if (!_didIteratorError16) {
                _context62.next = 35;
                break;
              }
              throw _iteratorError16;
            case 35:
              return _context62.finish(32);
            case 36:
              return _context62.finish(27);
            case 37:
              _context62.next = 39;
              return _awaitAsyncGenerator(firstMapperChunkPromise);
            case 39:
              _context62.next = 41;
              return _context62.sent.value;
            case 41:
              _iteratorAbruptCompletion17 = false;
              _didIteratorError17 = false;
              _context62.prev = 43;
              _iterator17 = _asyncIterator(mapperOutput);
            case 45:
              _context62.next = 47;
              return _awaitAsyncGenerator(_iterator17.next());
            case 47:
              if (!(_iteratorAbruptCompletion17 = !(_step17 = _context62.sent).done)) {
                _context62.next = 54;
                break;
              }
              _chunk5 = _step17.value;
              _context62.next = 51;
              return _chunk5;
            case 51:
              _iteratorAbruptCompletion17 = false;
              _context62.next = 45;
              break;
            case 54:
              _context62.next = 60;
              break;
            case 56:
              _context62.prev = 56;
              _context62.t1 = _context62["catch"](43);
              _didIteratorError17 = true;
              _iteratorError17 = _context62.t1;
            case 60:
              _context62.prev = 60;
              _context62.prev = 61;
              if (!(_iteratorAbruptCompletion17 && _iterator17["return"] != null)) {
                _context62.next = 65;
                break;
              }
              _context62.next = 65;
              return _awaitAsyncGenerator(_iterator17["return"]());
            case 65:
              _context62.prev = 65;
              if (!_didIteratorError17) {
                _context62.next = 68;
                break;
              }
              throw _iteratorError17;
            case 68:
              return _context62.finish(65);
            case 69:
              return _context62.finish(60);
            case 70:
            case "end":
              return _context62.stop();
          }
        }, _callee58, null, [[6, 23, 27, 37], [28,, 32, 36], [43, 56, 60, 70], [61,, 65, 69]]);
      }))();
    }
  }, {
    key: "transform",
    value: function transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
  }, {
    key: "stream",
    value: function () {
      var _stream5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee60(input, options) {
        var generator, _generator3, config, wrappedGenerator;
        return _regeneratorRuntime().wrap(function _callee60$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              _generator3 = function _generator10() {
                _generator3 = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee59() {
                  return _regeneratorRuntime().wrap(function _callee59$(_context63) {
                    while (1) switch (_context63.prev = _context63.next) {
                      case 0:
                        _context63.next = 2;
                        return input;
                      case 2:
                      case "end":
                        return _context63.stop();
                    }
                  }, _callee59);
                }));
                return _generator3.apply(this, arguments);
              };
              generator = function _generator9() {
                return _generator3.apply(this, arguments);
              };
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({
                generator: this.transform(generator(), config),
                config: config
              });
              _context64.next = 6;
              return wrappedGenerator.setup;
            case 6:
              return _context64.abrupt("return", _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator));
            case 7:
            case "end":
              return _context64.stop();
          }
        }, _callee60, this);
      }));
      function stream(_x72, _x73) {
        return _stream5.apply(this, arguments);
      }
      return stream;
    }()
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableAssign";
    }
  }]);
}(Runnable);
/**
 * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.
 * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.
 * @example
 * ```typescript
 * import { RunnablePick } from "@langchain/core/runnables";
 *
 * const inputData = {
 *   name: "John",
 *   age: 30,
 *   city: "New York",
 *   country: "USA",
 *   email: "john.doe@example.com",
 *   phone: "+1234567890",
 * };
 *
 * const basicInfoRunnable = new RunnablePick(["name", "city"]);
 *
 * // Example invocation
 * const res = await basicInfoRunnable.invoke(inputData);
 *
 * // { name: 'John', city: 'New York' }
 * ```
 */
var RunnablePick = /*#__PURE__*/function (_Runnable9) {
  function RunnablePick(fields) {
    var _this36;
    _classCallCheck(this, RunnablePick);
    if (typeof fields === "string" || Array.isArray(fields)) {
      // eslint-disable-next-line no-param-reassign
      fields = {
        keys: fields
      };
    }
    _this36 = _callSuper(this, RunnablePick, [fields]);
    Object.defineProperty(_this36, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(_this36, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this36, "keys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this36.keys = fields.keys;
    return _this36;
  }
  _inherits(RunnablePick, _Runnable9);
  return _createClass(RunnablePick, [{
    key: "_pick",
    value: function () {
      var _pick2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee61(input) {
        var picked;
        return _regeneratorRuntime().wrap(function _callee61$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              if (!(typeof this.keys === "string")) {
                _context65.next = 4;
                break;
              }
              return _context65.abrupt("return", input[this.keys]);
            case 4:
              picked = this.keys.map(function (key) {
                return [key, input[key]];
              }).filter(function (v) {
                return v[1] !== undefined;
              });
              return _context65.abrupt("return", picked.length === 0 ? undefined : Object.fromEntries(picked));
            case 6:
            case "end":
              return _context65.stop();
          }
        }, _callee61, this);
      }));
      function _pick(_x74) {
        return _pick2.apply(this, arguments);
      }
      return _pick;
    }()
  }, {
    key: "invoke",
    value: function () {
      var _invoke13 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee62(input, options) {
        return _regeneratorRuntime().wrap(function _callee62$(_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              return _context66.abrupt("return", this._callWithConfig(this._pick.bind(this), input, options));
            case 1:
            case "end":
              return _context66.stop();
          }
        }, _callee62, this);
      }));
      function invoke(_x75, _x76) {
        return _invoke13.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_transform",
    value: function _transform(generator) {
      var _this16 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee63() {
        var _iteratorAbruptCompletion18, _didIteratorError18, _iteratorError18, _iterator18, _step18, chunk, picked;
        return _regeneratorRuntime().wrap(function _callee63$(_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              _iteratorAbruptCompletion18 = false;
              _didIteratorError18 = false;
              _context67.prev = 2;
              _iterator18 = _asyncIterator(generator);
            case 4:
              _context67.next = 6;
              return _awaitAsyncGenerator(_iterator18.next());
            case 6:
              if (!(_iteratorAbruptCompletion18 = !(_step18 = _context67.sent).done)) {
                _context67.next = 17;
                break;
              }
              chunk = _step18.value;
              _context67.next = 10;
              return _awaitAsyncGenerator(_this16._pick(chunk));
            case 10:
              picked = _context67.sent;
              if (!(picked !== undefined)) {
                _context67.next = 14;
                break;
              }
              _context67.next = 14;
              return picked;
            case 14:
              _iteratorAbruptCompletion18 = false;
              _context67.next = 4;
              break;
            case 17:
              _context67.next = 23;
              break;
            case 19:
              _context67.prev = 19;
              _context67.t0 = _context67["catch"](2);
              _didIteratorError18 = true;
              _iteratorError18 = _context67.t0;
            case 23:
              _context67.prev = 23;
              _context67.prev = 24;
              if (!(_iteratorAbruptCompletion18 && _iterator18["return"] != null)) {
                _context67.next = 28;
                break;
              }
              _context67.next = 28;
              return _awaitAsyncGenerator(_iterator18["return"]());
            case 28:
              _context67.prev = 28;
              if (!_didIteratorError18) {
                _context67.next = 31;
                break;
              }
              throw _iteratorError18;
            case 31:
              return _context67.finish(28);
            case 32:
              return _context67.finish(23);
            case 33:
            case "end":
              return _context67.stop();
          }
        }, _callee63, null, [[2, 19, 23, 33], [24,, 28, 32]]);
      }))();
    }
  }, {
    key: "transform",
    value: function transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
  }, {
    key: "stream",
    value: function () {
      var _stream6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee65(input, options) {
        var generator, _generator4, config, wrappedGenerator;
        return _regeneratorRuntime().wrap(function _callee65$(_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              _generator4 = function _generator12() {
                _generator4 = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee64() {
                  return _regeneratorRuntime().wrap(function _callee64$(_context68) {
                    while (1) switch (_context68.prev = _context68.next) {
                      case 0:
                        _context68.next = 2;
                        return input;
                      case 2:
                      case "end":
                        return _context68.stop();
                    }
                  }, _callee64);
                }));
                return _generator4.apply(this, arguments);
              };
              generator = function _generator11() {
                return _generator4.apply(this, arguments);
              };
              config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);
              wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({
                generator: this.transform(generator(), config),
                config: config
              });
              _context69.next = 6;
              return wrappedGenerator.setup;
            case 6:
              return _context69.abrupt("return", _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator));
            case 7:
            case "end":
              return _context69.stop();
          }
        }, _callee65, this);
      }));
      function stream(_x77, _x78) {
        return _stream6.apply(this, arguments);
      }
      return stream;
    }()
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnablePick";
    }
  }]);
}(Runnable);
var RunnableToolLike = /*#__PURE__*/function (_RunnableBinding2) {
  function RunnableToolLike(fields) {
    var _fields$config;
    var _this37;
    _classCallCheck(this, RunnableToolLike);
    var sequence = RunnableSequence.from([RunnableLambda.from(/*#__PURE__*/function () {
      var _ref29 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee66(input) {
        var toolInput;
        return _regeneratorRuntime().wrap(function _callee66$(_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              if (!(0,_tools_utils_js__WEBPACK_IMPORTED_MODULE_15__._isToolCall)(input)) {
                _context70.next = 12;
                break;
              }
              _context70.prev = 1;
              _context70.next = 4;
              return _this37.schema.parseAsync(input.args);
            case 4:
              toolInput = _context70.sent;
              _context70.next = 10;
              break;
            case 7:
              _context70.prev = 7;
              _context70.t0 = _context70["catch"](1);
              throw new _tools_utils_js__WEBPACK_IMPORTED_MODULE_15__.ToolInputParsingException("Received tool input did not match expected schema", JSON.stringify(input.args));
            case 10:
              _context70.next = 13;
              break;
            case 12:
              toolInput = input;
            case 13:
              return _context70.abrupt("return", toolInput);
            case 14:
            case "end":
              return _context70.stop();
          }
        }, _callee66, null, [[1, 7]]);
      }));
      return function (_x79) {
        return _ref29.apply(this, arguments);
      };
    }()).withConfig({
      runName: "".concat(fields.name, ":parse_input")
    }), fields.bound]).withConfig({
      runName: fields.name
    });
    _this37 = _callSuper(this, RunnableToolLike, [{
      bound: sequence,
      config: (_fields$config = fields.config) !== null && _fields$config !== void 0 ? _fields$config : {}
    }]);
    Object.defineProperty(_this37, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this37, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this37, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this37.name = fields.name;
    _this37.description = fields.description;
    _this37.schema = fields.schema;
    return _this37;
  }
  _inherits(RunnableToolLike, _RunnableBinding2);
  return _createClass(RunnableToolLike, null, [{
    key: "lc_name",
    value: function lc_name() {
      return "RunnableToolLike";
    }
  }]);
}(RunnableBinding);
/**
 * Given a runnable and a Zod schema, convert the runnable to a tool.
 *
 * @template RunInput The input type for the runnable.
 * @template RunOutput The output type for the runnable.
 *
 * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.
 * @param fields
 * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
 * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
 * @param {z.ZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
 * @returns {RunnableToolLike<z.ZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
 */
function convertRunnableToTool(runnable, fields) {
  var _fields$name, _fields$description, _fields$schema;
  var name = (_fields$name = fields.name) !== null && _fields$name !== void 0 ? _fields$name : runnable.getName();
  var description = (_fields$description = fields.description) !== null && _fields$description !== void 0 ? _fields$description : (_fields$schema = fields.schema) === null || _fields$schema === void 0 ? void 0 : _fields$schema.description;
  if (fields.schema.constructor === zod__WEBPACK_IMPORTED_MODULE_16__.z.ZodString) {
    return new RunnableToolLike({
      name: name,
      description: description,
      schema: zod__WEBPACK_IMPORTED_MODULE_16__.z.object({
        input: zod__WEBPACK_IMPORTED_MODULE_16__.z.string()
      }).transform(function (input) {
        return input.input;
      }),
      bound: runnable
    });
  }
  return new RunnableToolLike({
    name: name,
    description: description,
    schema: fields.schema,
    bound: runnable
  });
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/config.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_RECURSION_LIMIT: () => (/* binding */ DEFAULT_RECURSION_LIMIT),
/* harmony export */   ensureConfig: () => (/* binding */ ensureConfig),
/* harmony export */   getCallbackManagerForConfig: () => (/* binding */ getCallbackManagerForConfig),
/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),
/* harmony export */   patchConfig: () => (/* binding */ patchConfig)
/* harmony export */ });
/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/manager.js */ "./node_modules/@langchain/core/dist/callbacks/manager.js");
/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/index.js */ "./node_modules/@langchain/core/dist/singletons/index.js");
var _excluded = ["runId", "runName"];
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }


var DEFAULT_RECURSION_LIMIT = 25;
function getCallbackManagerForConfig(_x) {
  return _getCallbackManagerForConfig.apply(this, arguments);
}
function _getCallbackManagerForConfig() {
  _getCallbackManagerForConfig = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager._configureSync(config === null || config === void 0 ? void 0 : config.callbacks, undefined, config === null || config === void 0 ? void 0 : config.tags, undefined, config === null || config === void 0 ? void 0 : config.metadata));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getCallbackManagerForConfig.apply(this, arguments);
}
function mergeConfigs() {
  // We do not want to call ensureConfig on the empty state here as this may cause
  // double loading of callbacks if async local storage is being used.
  var copy = {};
  for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
    configs[_key] = arguments[_key];
  }
  var _iterator = _createForOfIteratorHelper(configs.filter(function (c) {
      return !!c;
    })),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var options = _step.value;
      for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (key === "metadata") {
          copy[key] = _objectSpread(_objectSpread({}, copy[key]), options[key]);
        } else if (key === "tags") {
          var _copy$key, _options$key;
          var baseKeys = (_copy$key = copy[key]) !== null && _copy$key !== void 0 ? _copy$key : [];
          copy[key] = _toConsumableArray(new Set(baseKeys.concat((_options$key = options[key]) !== null && _options$key !== void 0 ? _options$key : [])));
        } else if (key === "configurable") {
          copy[key] = _objectSpread(_objectSpread({}, copy[key]), options[key]);
        } else if (key === "timeout") {
          if (copy.timeout === undefined) {
            copy.timeout = options.timeout;
          } else if (options.timeout !== undefined) {
            copy.timeout = Math.min(copy.timeout, options.timeout);
          }
        } else if (key === "signal") {
          if (copy.signal === undefined) {
            copy.signal = options.signal;
          } else if (options.signal !== undefined) {
            if ("any" in AbortSignal) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              copy.signal = AbortSignal.any([copy.signal, options.signal]);
            } else {
              copy.signal = options.signal;
            }
          }
        } else if (key === "callbacks") {
          var baseCallbacks = copy.callbacks;
          var providedCallbacks = options.callbacks;
          // callbacks can be either undefined, Array<handler> or manager
          // so merging two callbacks values has 6 cases
          if (Array.isArray(providedCallbacks)) {
            if (!baseCallbacks) {
              copy.callbacks = providedCallbacks;
            } else if (Array.isArray(baseCallbacks)) {
              copy.callbacks = baseCallbacks.concat(providedCallbacks);
            } else {
              // baseCallbacks is a manager
              var manager = baseCallbacks.copy();
              var _iterator2 = _createForOfIteratorHelper(providedCallbacks),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var callback = _step2.value;
                  manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              copy.callbacks = manager;
            }
          } else if (providedCallbacks) {
            // providedCallbacks is a manager
            if (!baseCallbacks) {
              copy.callbacks = providedCallbacks;
            } else if (Array.isArray(baseCallbacks)) {
              var _manager = providedCallbacks.copy();
              var _iterator3 = _createForOfIteratorHelper(baseCallbacks),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var _callback = _step3.value;
                  _manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(_callback), true);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              copy.callbacks = _manager;
            } else {
              // baseCallbacks is also a manager
              copy.callbacks = new _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager(providedCallbacks._parentRunId, {
                handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
                tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
                inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
                metadata: _objectSpread(_objectSpread({}, baseCallbacks.metadata), providedCallbacks.metadata)
              });
            }
          }
        } else {
          var _options$typedKey;
          var typedKey = key;
          copy[typedKey] = (_options$typedKey = options[typedKey]) !== null && _options$typedKey !== void 0 ? _options$typedKey : copy[typedKey];
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return copy;
}
var PRIMITIVES = new Set(["string", "number", "boolean"]);
/**
 * Ensure that a passed config is an object with all required keys present.
 */
function ensureConfig(config) {
  var _empty;
  var implicitConfig = _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.getRunnableConfig();
  var empty = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: undefined
  };
  if (implicitConfig) {
    // Don't allow runId and runName to be loaded implicitly, as this can cause
    // child runs to improperly inherit their parents' run ids.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var runId = implicitConfig.runId,
      runName = implicitConfig.runName,
      rest = _objectWithoutProperties(implicitConfig, _excluded);
    empty = Object.entries(rest).reduce(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function (currentConfig, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      if (value !== undefined) {
        // eslint-disable-next-line no-param-reassign
        currentConfig[key] = value;
      }
      return currentConfig;
    }, empty);
  }
  if (config) {
    empty = Object.entries(config).reduce(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function (currentConfig, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];
      if (value !== undefined) {
        // eslint-disable-next-line no-param-reassign
        currentConfig[key] = value;
      }
      return currentConfig;
    }, empty);
  }
  if ((_empty = empty) !== null && _empty !== void 0 && _empty.configurable) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(empty.configurable); _i2 < _Object$keys2.length; _i2++) {
      var _empty$metadata;
      var key = _Object$keys2[_i2];
      if (PRIMITIVES.has(_typeof(empty.configurable[key])) && !((_empty$metadata = empty.metadata) !== null && _empty$metadata !== void 0 && _empty$metadata[key])) {
        if (!empty.metadata) {
          empty.metadata = {};
        }
        empty.metadata[key] = empty.configurable[key];
      }
    }
  }
  if (empty.timeout !== undefined) {
    if (empty.timeout <= 0) {
      throw new Error("Timeout must be a positive number");
    }
    var timeoutSignal = AbortSignal.timeout(empty.timeout);
    if (empty.signal !== undefined) {
      if ("any" in AbortSignal) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);
      }
    } else {
      empty.signal = timeoutSignal;
    }
    delete empty.timeout;
  }
  return empty;
}
/**
 * Helper function that patches runnable configs with updated properties.
 */
function patchConfig() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    callbacks = _ref5.callbacks,
    maxConcurrency = _ref5.maxConcurrency,
    recursionLimit = _ref5.recursionLimit,
    runName = _ref5.runName,
    configurable = _ref5.configurable,
    runId = _ref5.runId;
  var newConfig = ensureConfig(config);
  if (callbacks !== undefined) {
    /**
     * If we're replacing callbacks we need to unset runName
     * since that should apply only to the same run as the original callbacks
     */
    delete newConfig.runName;
    newConfig.callbacks = callbacks;
  }
  if (recursionLimit !== undefined) {
    newConfig.recursionLimit = recursionLimit;
  }
  if (maxConcurrency !== undefined) {
    newConfig.maxConcurrency = maxConcurrency;
  }
  if (runName !== undefined) {
    newConfig.runName = runName;
  }
  if (configurable !== undefined) {
    newConfig.configurable = _objectSpread(_objectSpread({}, newConfig.configurable), configurable);
  }
  if (runId !== undefined) {
    delete newConfig.runId;
  }
  return newConfig;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/graph.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod-to-json-schema */ "./node_modules/zod-to-json-schema/dist/esm/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@langchain/core/dist/runnables/utils.js");
/* harmony import */ var _graph_mermaid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph_mermaid.js */ "./node_modules/@langchain/core/dist/runnables/graph_mermaid.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




function nodeDataStr(id, data) {
  if (id !== undefined && !(0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(id)) {
    return id;
  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isRunnableInterface)(data)) {
    try {
      var dataStr = data.getName();
      dataStr = dataStr.startsWith("Runnable") ? dataStr.slice("Runnable".length) : dataStr;
      return dataStr;
    } catch (error) {
      return data.getName();
    }
  } else {
    var _data$name;
    return (_data$name = data.name) !== null && _data$name !== void 0 ? _data$name : "UnknownSchema";
  }
}
function nodeDataJson(node) {
  // if node.data implements Runnable
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isRunnableInterface)(node.data)) {
    return {
      type: "runnable",
      data: {
        id: node.data.lc_id,
        name: node.data.getName()
      }
    };
  } else {
    return {
      type: "schema",
      data: _objectSpread(_objectSpread({}, (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(node.data.schema)), {}, {
        title: node.data.name
      })
    };
  }
}
var Graph = /*#__PURE__*/function () {
  function Graph(params) {
    var _params$nodes, _params$edges;
    _classCallCheck(this, Graph);
    Object.defineProperty(this, "nodes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "edges", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    this.nodes = (_params$nodes = params === null || params === void 0 ? void 0 : params.nodes) !== null && _params$nodes !== void 0 ? _params$nodes : this.nodes;
    this.edges = (_params$edges = params === null || params === void 0 ? void 0 : params.edges) !== null && _params$edges !== void 0 ? _params$edges : this.edges;
  }
  // Convert the graph to a JSON-serializable format.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return _createClass(Graph, [{
    key: "toJSON",
    value: function toJSON() {
      var stableNodeIds = {};
      Object.values(this.nodes).forEach(function (node, i) {
        stableNodeIds[node.id] = (0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(node.id) ? i : node.id;
      });
      return {
        nodes: Object.values(this.nodes).map(function (node) {
          return _objectSpread({
            id: stableNodeIds[node.id]
          }, nodeDataJson(node));
        }),
        edges: this.edges.map(function (edge) {
          var item = {
            source: stableNodeIds[edge.source],
            target: stableNodeIds[edge.target]
          };
          if (typeof edge.data !== "undefined") {
            item.data = edge.data;
          }
          if (typeof edge.conditional !== "undefined") {
            item.conditional = edge.conditional;
          }
          return item;
        })
      };
    }
  }, {
    key: "addNode",
    value: function addNode(data, id,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    metadata) {
      if (id !== undefined && this.nodes[id] !== undefined) {
        throw new Error("Node with id ".concat(id, " already exists"));
      }
      var nodeId = id !== null && id !== void 0 ? id : (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])();
      var node = {
        id: nodeId,
        data: data,
        name: nodeDataStr(id, data),
        metadata: metadata
      };
      this.nodes[nodeId] = node;
      return node;
    }
  }, {
    key: "removeNode",
    value: function removeNode(node) {
      // Remove the node from the nodes map
      delete this.nodes[node.id];
      // Filter out edges connected to the node
      this.edges = this.edges.filter(function (edge) {
        return edge.source !== node.id && edge.target !== node.id;
      });
    }
  }, {
    key: "addEdge",
    value: function addEdge(source, target, data, conditional) {
      if (this.nodes[source.id] === undefined) {
        throw new Error("Source node ".concat(source.id, " not in graph"));
      }
      if (this.nodes[target.id] === undefined) {
        throw new Error("Target node ".concat(target.id, " not in graph"));
      }
      var edge = {
        source: source.id,
        target: target.id,
        data: data,
        conditional: conditional
      };
      this.edges.push(edge);
      return edge;
    }
  }, {
    key: "firstNode",
    value: function firstNode() {
      return _firstNode(this);
    }
  }, {
    key: "lastNode",
    value: function lastNode() {
      return _lastNode(this);
    }
    /**
     * Add all nodes and edges from another graph.
     * Note this doesn't check for duplicates, nor does it connect the graphs.
     */
  }, {
    key: "extend",
    value: function extend(graph) {
      var _this = this;
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var finalPrefix = prefix;
      var nodeIds = Object.values(graph.nodes).map(function (node) {
        return node.id;
      });
      if (nodeIds.every(uuid__WEBPACK_IMPORTED_MODULE_3__["default"])) {
        finalPrefix = "";
      }
      var prefixed = function prefixed(id) {
        return finalPrefix ? "".concat(finalPrefix, ":").concat(id) : id;
      };
      Object.entries(graph.nodes).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        _this.nodes[prefixed(key)] = _objectSpread(_objectSpread({}, value), {}, {
          id: prefixed(key)
        });
      });
      var newEdges = graph.edges.map(function (edge) {
        return _objectSpread(_objectSpread({}, edge), {}, {
          source: prefixed(edge.source),
          target: prefixed(edge.target)
        });
      });
      // Add all edges from the other graph
      this.edges = [].concat(_toConsumableArray(this.edges), _toConsumableArray(newEdges));
      var first = graph.firstNode();
      var last = graph.lastNode();
      return [first ? {
        id: prefixed(first.id),
        data: first.data
      } : undefined, last ? {
        id: prefixed(last.id),
        data: last.data
      } : undefined];
    }
  }, {
    key: "trimFirstNode",
    value: function trimFirstNode() {
      var firstNode = this.firstNode();
      if (firstNode && _firstNode(this, [firstNode.id])) {
        this.removeNode(firstNode);
      }
    }
  }, {
    key: "trimLastNode",
    value: function trimLastNode() {
      var lastNode = this.lastNode();
      if (lastNode && _lastNode(this, [lastNode.id])) {
        this.removeNode(lastNode);
      }
    }
    /**
     * Return a new graph with all nodes re-identified,
     * using their unique, readable names where possible.
     */
  }, {
    key: "reid",
    value: function reid() {
      var nodeLabels = Object.fromEntries(Object.values(this.nodes).map(function (node) {
        return [node.id, node.name];
      }));
      var nodeLabelCounts = new Map();
      Object.values(nodeLabels).forEach(function (label) {
        nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
      });
      var getNodeId = function getNodeId(nodeId) {
        var label = nodeLabels[nodeId];
        if ((0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(nodeId) && nodeLabelCounts.get(label) === 1) {
          return label;
        } else {
          return nodeId;
        }
      };
      return new Graph({
        nodes: Object.fromEntries(Object.entries(this.nodes).map(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
            id = _ref4[0],
            node = _ref4[1];
          return [getNodeId(id), _objectSpread(_objectSpread({}, node), {}, {
            id: getNodeId(id)
          })];
        })),
        edges: this.edges.map(function (edge) {
          return _objectSpread(_objectSpread({}, edge), {}, {
            source: getNodeId(edge.source),
            target: getNodeId(edge.target)
          });
        })
      });
    }
  }, {
    key: "drawMermaid",
    value: function drawMermaid(params) {
      var _ref5 = params !== null && params !== void 0 ? params : {},
        withStyles = _ref5.withStyles,
        curveStyle = _ref5.curveStyle,
        _ref5$nodeColors = _ref5.nodeColors,
        nodeColors = _ref5$nodeColors === void 0 ? {
          "default": "fill:#f2f0ff,line-height:1.2",
          first: "fill-opacity:0",
          last: "fill:#bfb6fc"
        } : _ref5$nodeColors,
        wrapLabelNWords = _ref5.wrapLabelNWords;
      var graph = this.reid();
      var firstNode = graph.firstNode();
      var lastNode = graph.lastNode();
      return (0,_graph_mermaid_js__WEBPACK_IMPORTED_MODULE_2__.drawMermaid)(graph.nodes, graph.edges, {
        firstNode: firstNode === null || firstNode === void 0 ? void 0 : firstNode.id,
        lastNode: lastNode === null || lastNode === void 0 ? void 0 : lastNode.id,
        withStyles: withStyles,
        curveStyle: curveStyle,
        nodeColors: nodeColors,
        wrapLabelNWords: wrapLabelNWords
      });
    }
  }, {
    key: "drawMermaidPng",
    value: function () {
      var _drawMermaidPng2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
        var mermaidSyntax;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              mermaidSyntax = this.drawMermaid(params);
              return _context.abrupt("return", (0,_graph_mermaid_js__WEBPACK_IMPORTED_MODULE_2__.drawMermaidPng)(mermaidSyntax, {
                backgroundColor: params === null || params === void 0 ? void 0 : params.backgroundColor
              }));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function drawMermaidPng(_x) {
        return _drawMermaidPng2.apply(this, arguments);
      }
      return drawMermaidPng;
    }()
  }]);
}();
/**
 * Find the single node that is not a target of any edge.
 * Exclude nodes/sources with ids in the exclude list.
 * If there is no such node, or there are multiple, return undefined.
 * When drawing the graph, this node would be the origin.
 */
function _firstNode(graph) {
  var exclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var targets = new Set(graph.edges.filter(function (edge) {
    return !exclude.includes(edge.source);
  }).map(function (edge) {
    return edge.target;
  }));
  var found = [];
  for (var _i = 0, _Object$values = Object.values(graph.nodes); _i < _Object$values.length; _i++) {
    var node = _Object$values[_i];
    if (!exclude.includes(node.id) && !targets.has(node.id)) {
      found.push(node);
    }
  }
  return found.length === 1 ? found[0] : undefined;
}
/**
 * Find the single node that is not a source of any edge.
 * Exclude nodes/targets with ids in the exclude list.
 * If there is no such node, or there are multiple, return undefined.
 * When drawing the graph, this node would be the destination.
 */
function _lastNode(graph) {
  var exclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var sources = new Set(graph.edges.filter(function (edge) {
    return !exclude.includes(edge.target);
  }).map(function (edge) {
    return edge.source;
  }));
  var found = [];
  for (var _i2 = 0, _Object$values2 = Object.values(graph.nodes); _i2 < _Object$values2.length; _i2++) {
    var node = _Object$values2[_i2];
    if (!exclude.includes(node.id) && !sources.has(node.id)) {
      found.push(node);
    }
  }
  return found.length === 1 ? found[0] : undefined;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/graph_mermaid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph_mermaid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawMermaid: () => (/* binding */ drawMermaid),
/* harmony export */   drawMermaidPng: () => (/* binding */ drawMermaidPng)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _escapeNodeLabel(nodeLabel) {
  // Escapes the node label for Mermaid syntax.
  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
}
var MARKDOWN_SPECIAL_CHARS = ["*", "_", "`"];
function _generateMermaidGraphStyles(nodeColors) {
  var styles = "";
  for (var _i = 0, _Object$entries = Object.entries(nodeColors); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      className = _Object$entries$_i[0],
      color = _Object$entries$_i[1];
    styles += "\tclassDef ".concat(className, " ").concat(color, ";\n");
  }
  return styles;
}
/**
 * Draws a Mermaid graph using the provided graph data
 */
function drawMermaid(nodes, edges, config) {
  var _edgeGroups$;
  var _ref = config !== null && config !== void 0 ? config : {},
    firstNode = _ref.firstNode,
    lastNode = _ref.lastNode,
    nodeColors = _ref.nodeColors,
    _ref$withStyles = _ref.withStyles,
    withStyles = _ref$withStyles === void 0 ? true : _ref$withStyles,
    _ref$curveStyle = _ref.curveStyle,
    curveStyle = _ref$curveStyle === void 0 ? "linear" : _ref$curveStyle,
    _ref$wrapLabelNWords = _ref.wrapLabelNWords,
    wrapLabelNWords = _ref$wrapLabelNWords === void 0 ? 9 : _ref$wrapLabelNWords;
  // Initialize Mermaid graph configuration
  var mermaidGraph = withStyles ? "%%{init: {'flowchart': {'curve': '".concat(curveStyle, "'}}}%%\ngraph TD;\n") : "graph TD;\n";
  if (withStyles) {
    // Node formatting templates
    var defaultClassLabel = "default";
    var formatDict = _defineProperty({}, defaultClassLabel, "{0}({1})");
    if (firstNode !== undefined) {
      formatDict[firstNode] = "{0}([{1}]):::first";
    }
    if (lastNode !== undefined) {
      formatDict[lastNode] = "{0}([{1}]):::last";
    }
    // Add nodes to the graph
    var _loop = function _loop() {
      var _node$name$split$pop, _node$metadata, _formatDict$key;
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        key = _Object$entries2$_i[0],
        node = _Object$entries2$_i[1];
      var nodeName = (_node$name$split$pop = node.name.split(":").pop()) !== null && _node$name$split$pop !== void 0 ? _node$name$split$pop : "";
      var label = MARKDOWN_SPECIAL_CHARS.some(function (_char) {
        return nodeName.startsWith(_char) && nodeName.endsWith(_char);
      }) ? "<p>".concat(nodeName, "</p>") : nodeName;
      var finalLabel = label;
      if (Object.keys((_node$metadata = node.metadata) !== null && _node$metadata !== void 0 ? _node$metadata : {}).length) {
        var _node$metadata2;
        finalLabel += "<hr/><small><em>".concat(Object.entries((_node$metadata2 = node.metadata) !== null && _node$metadata2 !== void 0 ? _node$metadata2 : {}).map(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
            k = _ref3[0],
            v = _ref3[1];
          return "".concat(k, " = ").concat(v);
        }).join("\n"), "</em></small>");
      }
      var nodeLabel = ((_formatDict$key = formatDict[key]) !== null && _formatDict$key !== void 0 ? _formatDict$key : formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
      mermaidGraph += "\t".concat(nodeLabel, "\n");
    };
    for (var _i2 = 0, _Object$entries2 = Object.entries(nodes); _i2 < _Object$entries2.length; _i2++) {
      _loop();
    }
  }
  // Group edges by their common prefixes
  var edgeGroups = {};
  var _iterator = _createForOfIteratorHelper(edges),
    _step;
  try {
    var _loop3 = function _loop3() {
      var edge = _step.value;
      var srcParts = edge.source.split(":");
      var tgtParts = edge.target.split(":");
      var commonPrefix = srcParts.filter(function (src, i) {
        return src === tgtParts[i];
      }).join(":");
      if (!edgeGroups[commonPrefix]) {
        edgeGroups[commonPrefix] = [];
      }
      edgeGroups[commonPrefix].push(edge);
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop3();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var seenSubgraphs = new Set();
  function addSubgraph(edges, prefix) {
    var selfLoop = edges.length === 1 && edges[0].source === edges[0].target;
    if (prefix && !selfLoop) {
      var subgraph = prefix.split(":").pop();
      if (seenSubgraphs.has(subgraph)) {
        throw new Error("Found duplicate subgraph '".concat(subgraph, "' -- this likely means that ") + "you're reusing a subgraph node with the same name. " + "Please adjust your graph to have subgraph nodes with unique names.");
      }
      seenSubgraphs.add(subgraph);
      mermaidGraph += "\tsubgraph ".concat(subgraph, "\n");
    }
    var _iterator2 = _createForOfIteratorHelper(edges),
      _step2;
    try {
      var _loop2 = function _loop2() {
        var edge = _step2.value;
        var source = edge.source,
          target = edge.target,
          data = edge.data,
          conditional = edge.conditional;
        var edgeLabel = "";
        if (data !== undefined) {
          var edgeData = data;
          var words = edgeData.split(" ");
          if (words.length > wrapLabelNWords) {
            edgeData = Array.from({
              length: Math.ceil(words.length / wrapLabelNWords)
            }, function (_, i) {
              return words.slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords).join(" ");
            }).join("&nbsp;<br>&nbsp;");
          }
          edgeLabel = conditional ? " -. &nbsp;".concat(edgeData, "&nbsp; .-> ") : " -- &nbsp;".concat(edgeData, "&nbsp; --> ");
        } else {
          edgeLabel = conditional ? " -.-> " : " --> ";
        }
        mermaidGraph += "\t".concat(_escapeNodeLabel(source)).concat(edgeLabel).concat(_escapeNodeLabel(target), ";\n");
      };
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        _loop2();
      }
      // Recursively add nested subgraphs
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    for (var nestedPrefix in edgeGroups) {
      if (nestedPrefix.startsWith("".concat(prefix, ":")) && nestedPrefix !== prefix) {
        addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
      }
    }
    if (prefix && !selfLoop) {
      mermaidGraph += "\tend\n";
    }
  }
  // Start with the top-level edges (no common prefix)
  addSubgraph((_edgeGroups$ = edgeGroups[""]) !== null && _edgeGroups$ !== void 0 ? _edgeGroups$ : [], "");
  // Add remaining subgraphs
  for (var prefix in edgeGroups) {
    if (!prefix.includes(":") && prefix !== "") {
      addSubgraph(edgeGroups[prefix], prefix);
    }
  }
  // Add custom styles for nodes
  if (withStyles) {
    mermaidGraph += _generateMermaidGraphStyles(nodeColors !== null && nodeColors !== void 0 ? nodeColors : {});
  }
  return mermaidGraph;
}
/**
 * Renders Mermaid graph using the Mermaid.INK API.
 */
function drawMermaidPng(_x, _x2) {
  return _drawMermaidPng.apply(this, arguments);
}
function _drawMermaidPng() {
  _drawMermaidPng = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(mermaidSyntax, config) {
    var _ref4, _ref4$backgroundColor, backgroundColor, mermaidSyntaxEncoded, hexColorPattern, imageUrl, res, content;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _ref4 = config !== null && config !== void 0 ? config : {}, _ref4$backgroundColor = _ref4.backgroundColor, backgroundColor = _ref4$backgroundColor === void 0 ? "white" : _ref4$backgroundColor; // Use btoa for compatibility, assume ASCII
          mermaidSyntaxEncoded = btoa(mermaidSyntax); // Check if the background color is a hexadecimal color code using regex
          if (backgroundColor !== undefined) {
            hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
            if (!hexColorPattern.test(backgroundColor)) {
              backgroundColor = "!".concat(backgroundColor);
            }
          }
          imageUrl = "https://mermaid.ink/img/".concat(mermaidSyntaxEncoded, "?bgColor=").concat(backgroundColor);
          _context.next = 6;
          return fetch(imageUrl);
        case 6:
          res = _context.sent;
          if (res.ok) {
            _context.next = 9;
            break;
          }
          throw new Error(["Failed to render the graph using the Mermaid.INK API.", "Status code: ".concat(res.status), "Status text: ".concat(res.statusText)].join("\n"));
        case 9:
          _context.next = 11;
          return res.blob();
        case 11:
          content = _context.sent;
          return _context.abrupt("return", content);
        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _drawMermaidPng.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/iter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/iter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   consumeAsyncIterableInContext: () => (/* binding */ consumeAsyncIterableInContext),
/* harmony export */   consumeIteratorInContext: () => (/* binding */ consumeIteratorInContext),
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),
/* harmony export */   isIterableIterator: () => (/* binding */ isIterableIterator),
/* harmony export */   isIterator: () => (/* binding */ isIterator)
/* harmony export */ });
/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/index.js */ "./node_modules/@langchain/core/dist/singletons/index.js");
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var _marked = /*#__PURE__*/_regeneratorRuntime().mark(consumeIteratorInContext);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _OverloadYield(e, d) { this.v = e, this.k = d; }

function isIterableIterator(thing) {
  return _typeof(thing) === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" &&
  // avoid detecting array/set as iterator
  typeof thing.next === "function";
}
var isIterator = function isIterator(x) {
  return x != null && _typeof(x) === "object" && "next" in x && typeof x.next === "function";
};
function isAsyncIterable(thing) {
  return _typeof(thing) === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
}
function consumeIteratorInContext(context, iter) {
  var _AsyncLocalStoragePro, value, done;
  return _regeneratorRuntime().wrap(function consumeIteratorInContext$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        if (false) {}
        _AsyncLocalStoragePro = _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(context, iter.next.bind(iter), true), value = _AsyncLocalStoragePro.value, done = _AsyncLocalStoragePro.done;
        if (!done) {
          _context.next = 6;
          break;
        }
        return _context.abrupt("break", 10);
      case 6:
        _context.next = 8;
        return value;
      case 8:
        _context.next = 0;
        break;
      case 10:
      case "end":
        return _context.stop();
    }
  }, _marked);
}
function consumeAsyncIterableInContext(_x, _x2) {
  return _consumeAsyncIterableInContext.apply(this, arguments);
}
function _consumeAsyncIterableInContext() {
  _consumeAsyncIterableInContext = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, iter) {
    var iterator, _yield$_awaitAsyncGen, value, done;
    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          iterator = iter[Symbol.asyncIterator]();
        case 1:
          if (false) {}
          _context2.next = 4;
          return _awaitAsyncGenerator(_singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(context, iterator.next.bind(iter), true));
        case 4:
          _yield$_awaitAsyncGen = _context2.sent;
          value = _yield$_awaitAsyncGen.value;
          done = _yield$_awaitAsyncGen.done;
          if (!done) {
            _context2.next = 11;
            break;
          }
          return _context2.abrupt("break", 15);
        case 11:
          _context2.next = 13;
          return value;
        case 13:
          _context2.next = 1;
          break;
        case 15:
        case "end":
          return _context2.stop();
      }
    }, _callee);
  }));
  return _consumeAsyncIterableInContext.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _RootEventFilter: () => (/* binding */ _RootEventFilter),
/* harmony export */   isRunnableInterface: () => (/* binding */ isRunnableInterface)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isRunnableInterface(thing) {
  return thing ? thing.lc_runnable : false;
}
/**
 * Utility to filter the root event in the streamEvents implementation.
 * This is simply binding the arguments to the namespace to make save on
 * a bit of typing in the streamEvents implementation.
 *
 * TODO: Refactor and remove.
 */
var _RootEventFilter = /*#__PURE__*/function () {
  function _RootEventFilter(fields) {
    _classCallCheck(this, _RootEventFilter);
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.includeNames = fields.includeNames;
    this.includeTypes = fields.includeTypes;
    this.includeTags = fields.includeTags;
    this.excludeNames = fields.excludeNames;
    this.excludeTypes = fields.excludeTypes;
    this.excludeTags = fields.excludeTags;
  }
  return _createClass(_RootEventFilter, [{
    key: "includeEvent",
    value: function includeEvent(event, rootType) {
      var _event$tags,
        _this = this;
      var include = this.includeNames === undefined && this.includeTypes === undefined && this.includeTags === undefined;
      var eventTags = (_event$tags = event.tags) !== null && _event$tags !== void 0 ? _event$tags : [];
      if (this.includeNames !== undefined) {
        include = include || this.includeNames.includes(event.name);
      }
      if (this.includeTypes !== undefined) {
        include = include || this.includeTypes.includes(rootType);
      }
      if (this.includeTags !== undefined) {
        include = include || eventTags.some(function (tag) {
          var _this$includeTags;
          return (_this$includeTags = _this.includeTags) === null || _this$includeTags === void 0 ? void 0 : _this$includeTags.includes(tag);
        });
      }
      if (this.excludeNames !== undefined) {
        include = include && !this.excludeNames.includes(event.name);
      }
      if (this.excludeTypes !== undefined) {
        include = include && !this.excludeTypes.includes(rootType);
      }
      if (this.excludeTags !== undefined) {
        include = include && eventTags.every(function (tag) {
          var _this$excludeTags;
          return !((_this$excludeTags = _this.excludeTags) !== null && _this$excludeTags !== void 0 && _this$excludeTags.includes(tag));
        });
      }
      return include;
    }
  }]);
}();

/***/ }),

/***/ "./node_modules/@langchain/core/dist/runnables/wrappers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/wrappers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertToHttpEventStream: () => (/* binding */ convertToHttpEventStream)
/* harmony export */ });
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/@langchain/core/dist/utils/stream.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(r) { var n = this.s["return"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, "throw": function _throw(r) { var n = this.s["return"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }

function convertToHttpEventStream(stream) {
  var encoder = new TextEncoder();
  var finalStream = new ReadableStream({
    start: function start(controller) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context.prev = 2;
              _iterator = _asyncIterator(stream);
            case 4:
              _context.next = 6;
              return _iterator.next();
            case 6:
              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
                _context.next = 12;
                break;
              }
              chunk = _step.value;
              controller.enqueue(encoder.encode("event: data\ndata: ".concat(JSON.stringify(chunk), "\n\n")));
            case 9:
              _iteratorAbruptCompletion = false;
              _context.next = 4;
              break;
            case 12:
              _context.next = 18;
              break;
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](2);
              _didIteratorError = true;
              _iteratorError = _context.t0;
            case 18:
              _context.prev = 18;
              _context.prev = 19;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context.next = 23;
                break;
              }
              _context.next = 23;
              return _iterator["return"]();
            case 23:
              _context.prev = 23;
              if (!_didIteratorError) {
                _context.next = 26;
                break;
              }
              throw _iteratorError;
            case 26:
              return _context.finish(23);
            case 27:
              return _context.finish(18);
            case 28:
              controller.enqueue(encoder.encode("event: end\n\n"));
              controller.close();
            case 30:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 14, 18, 28], [19,, 23, 27]]);
      }))();
    }
  });
  return _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream.fromReadableStream(finalStream);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TRACING_ALS_KEY: () => (/* binding */ TRACING_ALS_KEY),
/* harmony export */   getGlobalAsyncLocalStorageInstance: () => (/* binding */ getGlobalAsyncLocalStorageInstance),
/* harmony export */   setGlobalAsyncLocalStorageInstance: () => (/* binding */ setGlobalAsyncLocalStorageInstance)
/* harmony export */ });
var TRACING_ALS_KEY = Symbol["for"]("ls:tracing_async_local_storage");
var setGlobalAsyncLocalStorageInstance = function setGlobalAsyncLocalStorageInstance(instance) {
  globalThis[TRACING_ALS_KEY] = instance;
};
var getGlobalAsyncLocalStorageInstance = function getGlobalAsyncLocalStorageInstance() {
  return globalThis[TRACING_ALS_KEY];
};

/***/ }),

/***/ "./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),
/* harmony export */   MockAsyncLocalStorage: () => (/* binding */ MockAsyncLocalStorage),
/* harmony export */   _CONTEXT_VARIABLES_KEY: () => (/* binding */ _CONTEXT_VARIABLES_KEY)
/* harmony export */ });
/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ "./node_modules/langsmith/index.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ "./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js");
/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../callbacks/manager.js */ "./node_modules/@langchain/core/dist/callbacks/manager.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/* eslint-disable @typescript-eslint/no-explicit-any */



var MockAsyncLocalStorage = /*#__PURE__*/function () {
  function MockAsyncLocalStorage() {
    _classCallCheck(this, MockAsyncLocalStorage);
  }
  return _createClass(MockAsyncLocalStorage, [{
    key: "getStore",
    value: function getStore() {
      return undefined;
    }
  }, {
    key: "run",
    value: function run(_store, callback) {
      return callback();
    }
  }, {
    key: "enterWith",
    value: function enterWith(_store) {
      return undefined;
    }
  }]);
}();
var mockAsyncLocalStorage = new MockAsyncLocalStorage();
var LC_CHILD_KEY = Symbol["for"]("lc:child_config");
var _CONTEXT_VARIABLES_KEY = Symbol["for"]("lc:context_variables");
var AsyncLocalStorageProvider = /*#__PURE__*/function () {
  function AsyncLocalStorageProvider() {
    _classCallCheck(this, AsyncLocalStorageProvider);
  }
  return _createClass(AsyncLocalStorageProvider, [{
    key: "getInstance",
    value: function getInstance() {
      var _getGlobalAsyncLocalS;
      return (_getGlobalAsyncLocalS = (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)()) !== null && _getGlobalAsyncLocalS !== void 0 ? _getGlobalAsyncLocalS : mockAsyncLocalStorage;
    }
  }, {
    key: "getRunnableConfig",
    value: function getRunnableConfig() {
      var _storage$getStore;
      var storage = this.getInstance();
      // this has the runnable config
      // which means that we should also have an instance of a LangChainTracer
      // with the run map prepopulated
      return (_storage$getStore = storage.getStore()) === null || _storage$getStore === void 0 || (_storage$getStore = _storage$getStore.extra) === null || _storage$getStore === void 0 ? void 0 : _storage$getStore[LC_CHILD_KEY];
    }
  }, {
    key: "runWithConfig",
    value: function runWithConfig(config, callback, avoidCreatingRootRunTree) {
      var _callbackManager$hand;
      var callbackManager = _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__.CallbackManager._configureSync(config === null || config === void 0 ? void 0 : config.callbacks, undefined, config === null || config === void 0 ? void 0 : config.tags, undefined, config === null || config === void 0 ? void 0 : config.metadata);
      var storage = this.getInstance();
      var previousValue = storage.getStore();
      var parentRunId = callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.getParentRunId();
      var langChainTracer = callbackManager === null || callbackManager === void 0 || (_callbackManager$hand = callbackManager.handlers) === null || _callbackManager$hand === void 0 ? void 0 : _callbackManager$hand.find(function (handler) {
        return (handler === null || handler === void 0 ? void 0 : handler.name) === "langchain_tracer";
      });
      var runTree;
      if (langChainTracer && parentRunId) {
        runTree = langChainTracer.convertToRunTree(parentRunId);
      } else if (!avoidCreatingRootRunTree) {
        runTree = new langsmith__WEBPACK_IMPORTED_MODULE_0__.RunTree({
          name: "<runnable_lambda>",
          tracingEnabled: false
        });
      }
      if (runTree) {
        runTree.extra = _objectSpread(_objectSpread({}, runTree.extra), {}, _defineProperty({}, LC_CHILD_KEY, config));
      }
      if (previousValue !== undefined && previousValue[_CONTEXT_VARIABLES_KEY] !== undefined) {
        runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
      }
      return storage.run(runTree, callback);
    }
  }, {
    key: "initializeGlobalInstance",
    value: function initializeGlobalInstance(instance) {
      if ((0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)() === undefined) {
        (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.setGlobalAsyncLocalStorageInstance)(instance);
      }
    }
  }]);
}();
var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();


/***/ }),

/***/ "./node_modules/@langchain/core/dist/singletons/callbacks.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/callbacks.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   awaitAllCallbacks: () => (/* binding */ awaitAllCallbacks),
/* harmony export */   consumeCallback: () => (/* binding */ consumeCallback),
/* harmony export */   getQueue: () => (/* binding */ getQueue)
/* harmony export */ });
/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-queue */ "./node_modules/@langchain/core/node_modules/p-queue/dist/index.js");
/* harmony import */ var _async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async_local_storage/globals.js */ "./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/* eslint-disable @typescript-eslint/no-explicit-any */


var queue;
/**
 * Creates a queue using the p-queue library. The queue is configured to
 * auto-start and has a concurrency of 1, meaning it will process tasks
 * one at a time.
 */
function createQueue() {
  var PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_0__["default"] : p_queue__WEBPACK_IMPORTED_MODULE_0__;
  return new PQueue({
    autoStart: true,
    concurrency: 1
  });
}
function getQueue() {
  if (typeof queue === "undefined") {
    queue = createQueue();
  }
  return queue;
}
/**
 * Consume a promise, either adding it to the queue or waiting for it to resolve
 * @param promiseFn Promise to consume
 * @param wait Whether to wait for the promise to resolve or resolve immediately
 */
function consumeCallback(_x, _x2) {
  return _consumeCallback.apply(this, arguments);
}
/**
 * Waits for all promises in the queue to resolve. If the queue is
 * undefined, it immediately resolves a promise.
 */
function _consumeCallback() {
  _consumeCallback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(promiseFn, wait) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          if (!(wait === true)) {
            _context4.next = 10;
            break;
          }
          if (!((0,_async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)() !== undefined)) {
            _context4.next = 6;
            break;
          }
          _context4.next = 4;
          return (0,_async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)().run(undefined, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", promiseFn());
                case 1:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          })));
        case 4:
          _context4.next = 8;
          break;
        case 6:
          _context4.next = 8;
          return promiseFn();
        case 8:
          _context4.next = 12;
          break;
        case 10:
          queue = getQueue();
          void queue.add(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  if (!((0,_async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)() !== undefined)) {
                    _context3.next = 5;
                    break;
                  }
                  _context3.next = 3;
                  return (0,_async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)().run(undefined, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          return _context2.abrupt("return", promiseFn());
                        case 1:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  })));
                case 3:
                  _context3.next = 7;
                  break;
                case 5:
                  _context3.next = 7;
                  return promiseFn();
                case 7:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          })));
        case 12:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _consumeCallback.apply(this, arguments);
}
function awaitAllCallbacks() {
  return typeof queue !== "undefined" ? queue.onIdle() : Promise.resolve();
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/singletons/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),
/* harmony export */   MockAsyncLocalStorage: () => (/* reexport safe */ _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__.MockAsyncLocalStorage),
/* harmony export */   _CONTEXT_VARIABLES_KEY: () => (/* reexport safe */ _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__._CONTEXT_VARIABLES_KEY)
/* harmony export */ });
/* harmony import */ var _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async_local_storage/index.js */ "./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js");
/* eslint-disable @typescript-eslint/no-explicit-any */



/***/ }),

/***/ "./node_modules/@langchain/core/dist/singletons/tracer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/tracer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLangChainClientSingleton: () => (/* binding */ getDefaultLangChainClientSingleton),
/* harmony export */   setDefaultLangChainClientSingleton: () => (/* binding */ setDefaultLangChainClientSingleton)
/* harmony export */ });
/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ "./node_modules/langsmith/index.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ "./node_modules/@langchain/core/dist/utils/env.js");


var client;
var getDefaultLangChainClientSingleton = function getDefaultLangChainClientSingleton() {
  if (client === undefined) {
    var clientParams = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
      // LangSmith has its own backgrounding system
      blockOnRootRunFinalization: true
    } : {};
    client = new langsmith__WEBPACK_IMPORTED_MODULE_0__.Client(clientParams);
  }
  return client;
};
var setDefaultLangChainClientSingleton = function setDefaultLangChainClientSingleton(newClient) {
  client = newClient;
};

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tools/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToolInputParsingException: () => (/* binding */ ToolInputParsingException),
/* harmony export */   _isToolCall: () => (/* binding */ _isToolCall)
/* harmony export */ });
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _isToolCall(toolCall) {
  return !!(toolCall && _typeof(toolCall) === "object" && "type" in toolCall && toolCall.type === "tool_call");
}
/**
 * Custom error class used to handle exceptions related to tool input parsing.
 * It extends the built-in `Error` class and adds an optional `output`
 * property that can hold the output that caused the exception.
 */
var ToolInputParsingException = /*#__PURE__*/function (_Error) {
  function ToolInputParsingException(message, output) {
    var _this;
    _classCallCheck(this, ToolInputParsingException);
    _this = _callSuper(this, ToolInputParsingException, [message]);
    Object.defineProperty(_this, "output", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.output = output;
    return _this;
  }
  _inherits(ToolInputParsingException, _Error);
  return _createClass(ToolInputParsingException);
}(/*#__PURE__*/_wrapNativeSuper(Error));

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tracers/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/base.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTracer: () => (/* binding */ BaseTracer),
/* harmony export */   isBaseTracer: () => (/* binding */ isBaseTracer)
/* harmony export */ });
/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/base.js */ "./node_modules/@langchain/core/dist/callbacks/base.js");
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && _typeof(value) === "object" ? value : _defineProperty({}, defaultKey, value);
}
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat(epoch, runId, executionOrder) {
  var paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return stripNonAlphanumeric("".concat(new Date(epoch).toISOString().slice(0, -1)).concat(paddedOrder, "Z")) + runId;
}
function isBaseTracer(x) {
  return typeof x._addRunToRunMap === "function";
}
var BaseTracer = /*#__PURE__*/function (_BaseCallbackHandler) {
  function BaseTracer(_fields) {
    var _this;
    _classCallCheck(this, BaseTracer);
    _this = _callSuper(this, BaseTracer, arguments);
    Object.defineProperty(_this, "runMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Map()
    });
    return _this;
  }
  _inherits(BaseTracer, _BaseCallbackHandler);
  return _createClass(BaseTracer, [{
    key: "copy",
    value: function copy() {
      return this;
    }
  }, {
    key: "stringifyError",
    value: function stringifyError(error) {
      // eslint-disable-next-line no-instanceof/no-instanceof
      if (error instanceof Error) {
        return error.message + (error !== null && error !== void 0 && error.stack ? "\n\n".concat(error.stack) : "");
      }
      if (typeof error === "string") {
        return error;
      }
      return "".concat(error);
    }
  }, {
    key: "_addChildRun",
    value: function _addChildRun(parentRun, childRun) {
      parentRun.child_runs.push(childRun);
    }
  }, {
    key: "_addRunToRunMap",
    value: function _addRunToRunMap(run) {
      var currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);
      var storedRun = _objectSpread({}, run);
      if (storedRun.parent_run_id !== undefined) {
        var parentRun = this.runMap.get(storedRun.parent_run_id);
        if (parentRun) {
          this._addChildRun(parentRun, storedRun);
          parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
          storedRun.trace_id = parentRun.trace_id;
          if (parentRun.dotted_order !== undefined) {
            storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(".");
          } else {
            // This can happen naturally for callbacks added within a run
            // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);
          }
        } else {
          // This can happen naturally for callbacks added within a run
          // console.debug(
          //   `Parent run with UUID ${storedRun.parent_run_id} not found.`
          // );
        }
      } else {
        storedRun.trace_id = storedRun.id;
        storedRun.dotted_order = currentDottedOrder;
      }
      this.runMap.set(storedRun.id, storedRun);
      return storedRun;
    }
  }, {
    key: "_endTrace",
    value: function () {
      var _endTrace2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(run) {
        var _this$onRunUpdate;
        var parentRun;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);
              if (!parentRun) {
                _context.next = 5;
                break;
              }
              parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
              _context.next = 7;
              break;
            case 5:
              _context.next = 7;
              return this.persistRun(run);
            case 7:
              this.runMap["delete"](run.id);
              _context.next = 10;
              return (_this$onRunUpdate = this.onRunUpdate) === null || _this$onRunUpdate === void 0 ? void 0 : _this$onRunUpdate.call(this, run);
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _endTrace(_x) {
        return _endTrace2.apply(this, arguments);
      }
      return _endTrace;
    }()
  }, {
    key: "_getExecutionOrder",
    value: function _getExecutionOrder(parentRunId) {
      var parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);
      // If a run has no parent then execution order is 1
      if (!parentRun) {
        return 1;
      }
      return parentRun.child_execution_order + 1;
    }
    /**
     * Create and add a run to the run map for LLM start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
  }, {
    key: "_createRunForLLMStart",
    value: function _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
      var execution_order = this._getExecutionOrder(parentRunId);
      var start_time = Date.now();
      var finalExtraParams = metadata ? _objectSpread(_objectSpread({}, extraParams), {}, {
        metadata: metadata
      }) : extraParams;
      var run = {
        id: runId,
        name: name !== null && name !== void 0 ? name : llm.id[llm.id.length - 1],
        parent_run_id: parentRunId,
        start_time: start_time,
        serialized: llm,
        events: [{
          name: "start",
          time: new Date(start_time).toISOString()
        }],
        inputs: {
          prompts: prompts
        },
        execution_order: execution_order,
        child_runs: [],
        child_execution_order: execution_order,
        run_type: "llm",
        extra: finalExtraParams !== null && finalExtraParams !== void 0 ? finalExtraParams : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
  }, {
    key: "handleLLMStart",
    value: function () {
      var _handleLLMStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
        var _this$runMap$get, _this$onRunCreate, _this$onLLMStart;
        var run;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              run = (_this$runMap$get = this.runMap.get(runId)) !== null && _this$runMap$get !== void 0 ? _this$runMap$get : this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
              _context2.next = 3;
              return (_this$onRunCreate = this.onRunCreate) === null || _this$onRunCreate === void 0 ? void 0 : _this$onRunCreate.call(this, run);
            case 3:
              _context2.next = 5;
              return (_this$onLLMStart = this.onLLMStart) === null || _this$onLLMStart === void 0 ? void 0 : _this$onLLMStart.call(this, run);
            case 5:
              return _context2.abrupt("return", run);
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function handleLLMStart(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {
        return _handleLLMStart.apply(this, arguments);
      }
      return handleLLMStart;
    }()
    /**
     * Create and add a run to the run map for chat model start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
  }, {
    key: "_createRunForChatModelStart",
    value: function _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
      var execution_order = this._getExecutionOrder(parentRunId);
      var start_time = Date.now();
      var finalExtraParams = metadata ? _objectSpread(_objectSpread({}, extraParams), {}, {
        metadata: metadata
      }) : extraParams;
      var run = {
        id: runId,
        name: name !== null && name !== void 0 ? name : llm.id[llm.id.length - 1],
        parent_run_id: parentRunId,
        start_time: start_time,
        serialized: llm,
        events: [{
          name: "start",
          time: new Date(start_time).toISOString()
        }],
        inputs: {
          messages: messages
        },
        execution_order: execution_order,
        child_runs: [],
        child_execution_order: execution_order,
        run_type: "llm",
        extra: finalExtraParams !== null && finalExtraParams !== void 0 ? finalExtraParams : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
  }, {
    key: "handleChatModelStart",
    value: function () {
      var _handleChatModelStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        var _this$runMap$get2, _this$onRunCreate2, _this$onLLMStart2;
        var run;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              run = (_this$runMap$get2 = this.runMap.get(runId)) !== null && _this$runMap$get2 !== void 0 ? _this$runMap$get2 : this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
              _context3.next = 3;
              return (_this$onRunCreate2 = this.onRunCreate) === null || _this$onRunCreate2 === void 0 ? void 0 : _this$onRunCreate2.call(this, run);
            case 3:
              _context3.next = 5;
              return (_this$onLLMStart2 = this.onLLMStart) === null || _this$onLLMStart2 === void 0 ? void 0 : _this$onLLMStart2.call(this, run);
            case 5:
              return _context3.abrupt("return", run);
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function handleChatModelStart(_x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17) {
        return _handleChatModelStart.apply(this, arguments);
      }
      return handleChatModelStart;
    }()
  }, {
    key: "handleLLMEnd",
    value: function () {
      var _handleLLMEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(output, runId) {
        var _this$onLLMEnd;
        var run;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "llm")) {
                _context4.next = 3;
                break;
              }
              throw new Error("No LLM run to end.");
            case 3:
              run.end_time = Date.now();
              run.outputs = output;
              run.events.push({
                name: "end",
                time: new Date(run.end_time).toISOString()
              });
              _context4.next = 8;
              return (_this$onLLMEnd = this.onLLMEnd) === null || _this$onLLMEnd === void 0 ? void 0 : _this$onLLMEnd.call(this, run);
            case 8:
              _context4.next = 10;
              return this._endTrace(run);
            case 10:
              return _context4.abrupt("return", run);
            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function handleLLMEnd(_x18, _x19) {
        return _handleLLMEnd.apply(this, arguments);
      }
      return handleLLMEnd;
    }()
  }, {
    key: "handleLLMError",
    value: function () {
      var _handleLLMError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(error, runId) {
        var _this$onLLMError;
        var run;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "llm")) {
                _context5.next = 3;
                break;
              }
              throw new Error("No LLM run to end.");
            case 3:
              run.end_time = Date.now();
              run.error = this.stringifyError(error);
              run.events.push({
                name: "error",
                time: new Date(run.end_time).toISOString()
              });
              _context5.next = 8;
              return (_this$onLLMError = this.onLLMError) === null || _this$onLLMError === void 0 ? void 0 : _this$onLLMError.call(this, run);
            case 8:
              _context5.next = 10;
              return this._endTrace(run);
            case 10:
              return _context5.abrupt("return", run);
            case 11:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function handleLLMError(_x20, _x21) {
        return _handleLLMError.apply(this, arguments);
      }
      return handleLLMError;
    }()
    /**
     * Create and add a run to the run map for chain start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
  }, {
    key: "_createRunForChainStart",
    value: function _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
      var execution_order = this._getExecutionOrder(parentRunId);
      var start_time = Date.now();
      var run = {
        id: runId,
        name: name !== null && name !== void 0 ? name : chain.id[chain.id.length - 1],
        parent_run_id: parentRunId,
        start_time: start_time,
        serialized: chain,
        events: [{
          name: "start",
          time: new Date(start_time).toISOString()
        }],
        inputs: inputs,
        execution_order: execution_order,
        child_execution_order: execution_order,
        run_type: runType !== null && runType !== void 0 ? runType : "chain",
        child_runs: [],
        extra: metadata ? {
          metadata: metadata
        } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
  }, {
    key: "handleChainStart",
    value: function () {
      var _handleChainStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
        var _this$runMap$get3, _this$onRunCreate3, _this$onChainStart;
        var run;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              run = (_this$runMap$get3 = this.runMap.get(runId)) !== null && _this$runMap$get3 !== void 0 ? _this$runMap$get3 : this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
              _context6.next = 3;
              return (_this$onRunCreate3 = this.onRunCreate) === null || _this$onRunCreate3 === void 0 ? void 0 : _this$onRunCreate3.call(this, run);
            case 3:
              _context6.next = 5;
              return (_this$onChainStart = this.onChainStart) === null || _this$onChainStart === void 0 ? void 0 : _this$onChainStart.call(this, run);
            case 5:
              return _context6.abrupt("return", run);
            case 6:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function handleChainStart(_x22, _x23, _x24, _x25, _x26, _x27, _x28, _x29) {
        return _handleChainStart.apply(this, arguments);
      }
      return handleChainStart;
    }()
  }, {
    key: "handleChainEnd",
    value: function () {
      var _handleChainEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(outputs, runId, _parentRunId, _tags, kwargs) {
        var _this$onChainEnd;
        var run;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              run = this.runMap.get(runId);
              if (run) {
                _context7.next = 3;
                break;
              }
              throw new Error("No chain run to end.");
            case 3:
              run.end_time = Date.now();
              run.outputs = _coerceToDict(outputs, "output");
              run.events.push({
                name: "end",
                time: new Date(run.end_time).toISOString()
              });
              if ((kwargs === null || kwargs === void 0 ? void 0 : kwargs.inputs) !== undefined) {
                run.inputs = _coerceToDict(kwargs.inputs, "input");
              }
              _context7.next = 9;
              return (_this$onChainEnd = this.onChainEnd) === null || _this$onChainEnd === void 0 ? void 0 : _this$onChainEnd.call(this, run);
            case 9:
              _context7.next = 11;
              return this._endTrace(run);
            case 11:
              return _context7.abrupt("return", run);
            case 12:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function handleChainEnd(_x30, _x31, _x32, _x33, _x34) {
        return _handleChainEnd.apply(this, arguments);
      }
      return handleChainEnd;
    }()
  }, {
    key: "handleChainError",
    value: function () {
      var _handleChainError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(error, runId, _parentRunId, _tags, kwargs) {
        var _this$onChainError;
        var run;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              run = this.runMap.get(runId);
              if (run) {
                _context8.next = 3;
                break;
              }
              throw new Error("No chain run to end.");
            case 3:
              run.end_time = Date.now();
              run.error = this.stringifyError(error);
              run.events.push({
                name: "error",
                time: new Date(run.end_time).toISOString()
              });
              if ((kwargs === null || kwargs === void 0 ? void 0 : kwargs.inputs) !== undefined) {
                run.inputs = _coerceToDict(kwargs.inputs, "input");
              }
              _context8.next = 9;
              return (_this$onChainError = this.onChainError) === null || _this$onChainError === void 0 ? void 0 : _this$onChainError.call(this, run);
            case 9:
              _context8.next = 11;
              return this._endTrace(run);
            case 11:
              return _context8.abrupt("return", run);
            case 12:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function handleChainError(_x35, _x36, _x37, _x38, _x39) {
        return _handleChainError.apply(this, arguments);
      }
      return handleChainError;
    }()
    /**
     * Create and add a run to the run map for tool start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
  }, {
    key: "_createRunForToolStart",
    value: function _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
      var execution_order = this._getExecutionOrder(parentRunId);
      var start_time = Date.now();
      var run = {
        id: runId,
        name: name !== null && name !== void 0 ? name : tool.id[tool.id.length - 1],
        parent_run_id: parentRunId,
        start_time: start_time,
        serialized: tool,
        events: [{
          name: "start",
          time: new Date(start_time).toISOString()
        }],
        inputs: {
          input: input
        },
        execution_order: execution_order,
        child_execution_order: execution_order,
        run_type: "tool",
        child_runs: [],
        extra: metadata ? {
          metadata: metadata
        } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
  }, {
    key: "handleToolStart",
    value: function () {
      var _handleToolStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(tool, input, runId, parentRunId, tags, metadata, name) {
        var _this$runMap$get4, _this$onRunCreate4, _this$onToolStart;
        var run;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              run = (_this$runMap$get4 = this.runMap.get(runId)) !== null && _this$runMap$get4 !== void 0 ? _this$runMap$get4 : this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
              _context9.next = 3;
              return (_this$onRunCreate4 = this.onRunCreate) === null || _this$onRunCreate4 === void 0 ? void 0 : _this$onRunCreate4.call(this, run);
            case 3:
              _context9.next = 5;
              return (_this$onToolStart = this.onToolStart) === null || _this$onToolStart === void 0 ? void 0 : _this$onToolStart.call(this, run);
            case 5:
              return _context9.abrupt("return", run);
            case 6:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function handleToolStart(_x40, _x41, _x42, _x43, _x44, _x45, _x46) {
        return _handleToolStart.apply(this, arguments);
      }
      return handleToolStart;
    }() // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "handleToolEnd",
    value: function () {
      var _handleToolEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(output, runId) {
        var _this$onToolEnd;
        var run;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "tool")) {
                _context10.next = 3;
                break;
              }
              throw new Error("No tool run to end");
            case 3:
              run.end_time = Date.now();
              run.outputs = {
                output: output
              };
              run.events.push({
                name: "end",
                time: new Date(run.end_time).toISOString()
              });
              _context10.next = 8;
              return (_this$onToolEnd = this.onToolEnd) === null || _this$onToolEnd === void 0 ? void 0 : _this$onToolEnd.call(this, run);
            case 8:
              _context10.next = 10;
              return this._endTrace(run);
            case 10:
              return _context10.abrupt("return", run);
            case 11:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function handleToolEnd(_x47, _x48) {
        return _handleToolEnd.apply(this, arguments);
      }
      return handleToolEnd;
    }()
  }, {
    key: "handleToolError",
    value: function () {
      var _handleToolError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(error, runId) {
        var _this$onToolError;
        var run;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "tool")) {
                _context11.next = 3;
                break;
              }
              throw new Error("No tool run to end");
            case 3:
              run.end_time = Date.now();
              run.error = this.stringifyError(error);
              run.events.push({
                name: "error",
                time: new Date(run.end_time).toISOString()
              });
              _context11.next = 8;
              return (_this$onToolError = this.onToolError) === null || _this$onToolError === void 0 ? void 0 : _this$onToolError.call(this, run);
            case 8:
              _context11.next = 10;
              return this._endTrace(run);
            case 10:
              return _context11.abrupt("return", run);
            case 11:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function handleToolError(_x49, _x50) {
        return _handleToolError.apply(this, arguments);
      }
      return handleToolError;
    }()
  }, {
    key: "handleAgentAction",
    value: function () {
      var _handleAgentAction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(action, runId) {
        var _this$onAgentAction;
        var run, agentRun;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "chain")) {
                _context12.next = 3;
                break;
              }
              return _context12.abrupt("return");
            case 3:
              agentRun = run;
              agentRun.actions = agentRun.actions || [];
              agentRun.actions.push(action);
              agentRun.events.push({
                name: "agent_action",
                time: new Date().toISOString(),
                kwargs: {
                  action: action
                }
              });
              _context12.next = 9;
              return (_this$onAgentAction = this.onAgentAction) === null || _this$onAgentAction === void 0 ? void 0 : _this$onAgentAction.call(this, run);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function handleAgentAction(_x51, _x52) {
        return _handleAgentAction.apply(this, arguments);
      }
      return handleAgentAction;
    }()
  }, {
    key: "handleAgentEnd",
    value: function () {
      var _handleAgentEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(action, runId) {
        var _this$onAgentEnd;
        var run;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "chain")) {
                _context13.next = 3;
                break;
              }
              return _context13.abrupt("return");
            case 3:
              run.events.push({
                name: "agent_end",
                time: new Date().toISOString(),
                kwargs: {
                  action: action
                }
              });
              _context13.next = 6;
              return (_this$onAgentEnd = this.onAgentEnd) === null || _this$onAgentEnd === void 0 ? void 0 : _this$onAgentEnd.call(this, run);
            case 6:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function handleAgentEnd(_x53, _x54) {
        return _handleAgentEnd.apply(this, arguments);
      }
      return handleAgentEnd;
    }()
    /**
     * Create and add a run to the run map for retriever start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
  }, {
    key: "_createRunForRetrieverStart",
    value: function _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
      var execution_order = this._getExecutionOrder(parentRunId);
      var start_time = Date.now();
      var run = {
        id: runId,
        name: name !== null && name !== void 0 ? name : retriever.id[retriever.id.length - 1],
        parent_run_id: parentRunId,
        start_time: start_time,
        serialized: retriever,
        events: [{
          name: "start",
          time: new Date(start_time).toISOString()
        }],
        inputs: {
          query: query
        },
        execution_order: execution_order,
        child_execution_order: execution_order,
        run_type: "retriever",
        child_runs: [],
        extra: metadata ? {
          metadata: metadata
        } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
  }, {
    key: "handleRetrieverStart",
    value: function () {
      var _handleRetrieverStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(retriever, query, runId, parentRunId, tags, metadata, name) {
        var _this$runMap$get5, _this$onRunCreate5, _this$onRetrieverStar;
        var run;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              run = (_this$runMap$get5 = this.runMap.get(runId)) !== null && _this$runMap$get5 !== void 0 ? _this$runMap$get5 : this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
              _context14.next = 3;
              return (_this$onRunCreate5 = this.onRunCreate) === null || _this$onRunCreate5 === void 0 ? void 0 : _this$onRunCreate5.call(this, run);
            case 3:
              _context14.next = 5;
              return (_this$onRetrieverStar = this.onRetrieverStart) === null || _this$onRetrieverStar === void 0 ? void 0 : _this$onRetrieverStar.call(this, run);
            case 5:
              return _context14.abrupt("return", run);
            case 6:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function handleRetrieverStart(_x55, _x56, _x57, _x58, _x59, _x60, _x61) {
        return _handleRetrieverStart.apply(this, arguments);
      }
      return handleRetrieverStart;
    }()
  }, {
    key: "handleRetrieverEnd",
    value: function () {
      var _handleRetrieverEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(documents, runId) {
        var _this$onRetrieverEnd;
        var run;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "retriever")) {
                _context15.next = 3;
                break;
              }
              throw new Error("No retriever run to end");
            case 3:
              run.end_time = Date.now();
              run.outputs = {
                documents: documents
              };
              run.events.push({
                name: "end",
                time: new Date(run.end_time).toISOString()
              });
              _context15.next = 8;
              return (_this$onRetrieverEnd = this.onRetrieverEnd) === null || _this$onRetrieverEnd === void 0 ? void 0 : _this$onRetrieverEnd.call(this, run);
            case 8:
              _context15.next = 10;
              return this._endTrace(run);
            case 10:
              return _context15.abrupt("return", run);
            case 11:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function handleRetrieverEnd(_x62, _x63) {
        return _handleRetrieverEnd.apply(this, arguments);
      }
      return handleRetrieverEnd;
    }()
  }, {
    key: "handleRetrieverError",
    value: function () {
      var _handleRetrieverError = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(error, runId) {
        var _this$onRetrieverErro;
        var run;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "retriever")) {
                _context16.next = 3;
                break;
              }
              throw new Error("No retriever run to end");
            case 3:
              run.end_time = Date.now();
              run.error = this.stringifyError(error);
              run.events.push({
                name: "error",
                time: new Date(run.end_time).toISOString()
              });
              _context16.next = 8;
              return (_this$onRetrieverErro = this.onRetrieverError) === null || _this$onRetrieverErro === void 0 ? void 0 : _this$onRetrieverErro.call(this, run);
            case 8:
              _context16.next = 10;
              return this._endTrace(run);
            case 10:
              return _context16.abrupt("return", run);
            case 11:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function handleRetrieverError(_x64, _x65) {
        return _handleRetrieverError.apply(this, arguments);
      }
      return handleRetrieverError;
    }()
  }, {
    key: "handleText",
    value: function () {
      var _handleText = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(text, runId) {
        var _this$onText;
        var run;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "chain")) {
                _context17.next = 3;
                break;
              }
              return _context17.abrupt("return");
            case 3:
              run.events.push({
                name: "text",
                time: new Date().toISOString(),
                kwargs: {
                  text: text
                }
              });
              _context17.next = 6;
              return (_this$onText = this.onText) === null || _this$onText === void 0 ? void 0 : _this$onText.call(this, run);
            case 6:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function handleText(_x66, _x67) {
        return _handleText.apply(this, arguments);
      }
      return handleText;
    }()
  }, {
    key: "handleLLMNewToken",
    value: function () {
      var _handleLLMNewToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(token, idx, runId, _parentRunId, _tags, fields) {
        var _this$onLLMNewToken;
        var run;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              run = this.runMap.get(runId);
              if (!(!run || (run === null || run === void 0 ? void 0 : run.run_type) !== "llm")) {
                _context18.next = 3;
                break;
              }
              throw new Error("Invalid \"runId\" provided to \"handleLLMNewToken\" callback.");
            case 3:
              run.events.push({
                name: "new_token",
                time: new Date().toISOString(),
                kwargs: {
                  token: token,
                  idx: idx,
                  chunk: fields === null || fields === void 0 ? void 0 : fields.chunk
                }
              });
              _context18.next = 6;
              return (_this$onLLMNewToken = this.onLLMNewToken) === null || _this$onLLMNewToken === void 0 ? void 0 : _this$onLLMNewToken.call(this, run, token, {
                chunk: fields === null || fields === void 0 ? void 0 : fields.chunk
              });
            case 6:
              return _context18.abrupt("return", run);
            case 7:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function handleLLMNewToken(_x68, _x69, _x70, _x71, _x72, _x73) {
        return _handleLLMNewToken.apply(this, arguments);
      }
      return handleLLMNewToken;
    }()
  }]);
}(_callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tracers/console.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/console.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConsoleCallbackHandler: () => (/* binding */ ConsoleCallbackHandler)
/* harmony export */ });
/* harmony import */ var ansi_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-styles */ "./node_modules/@langchain/core/node_modules/ansi-styles/index.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/tracers/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


function wrap(style, text) {
  return "".concat(style.open).concat(text).concat(style.close);
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch (err) {
    return fallback;
  }
}
function formatKVMapItem(value) {
  if (typeof value === "string") {
    return value.trim();
  }
  if (value === null || value === undefined) {
    return value;
  }
  return tryJsonStringify(value, value.toString());
}
function elapsed(run) {
  if (!run.end_time) return "";
  var elapsed = run.end_time - run.start_time;
  if (elapsed < 1000) {
    return "".concat(elapsed, "ms");
  }
  return "".concat((elapsed / 1000).toFixed(2), "s");
}
var color = ansi_styles__WEBPACK_IMPORTED_MODULE_0__.color;
/**
 * A tracer that logs all events to the console. It extends from the
 * `BaseTracer` class and overrides its methods to provide custom logging
 * functionality.
 * @example
 * ```typescript
 *
 * const llm = new ChatAnthropic({
 *   temperature: 0,
 *   tags: ["example", "callbacks", "constructor"],
 *   callbacks: [new ConsoleCallbackHandler()],
 * });
 *
 * ```
 */
var ConsoleCallbackHandler = /*#__PURE__*/function (_BaseTracer) {
  function ConsoleCallbackHandler() {
    var _this;
    _classCallCheck(this, ConsoleCallbackHandler);
    _this = _callSuper(this, ConsoleCallbackHandler, arguments);
    Object.defineProperty(_this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "console_callback_handler"
    });
    return _this;
  }
  /**
   * Method used to persist the run. In this case, it simply returns a
   * resolved promise as there's no persistence logic.
   * @param _run The run to persist.
   * @returns A resolved promise.
   */
  _inherits(ConsoleCallbackHandler, _BaseTracer);
  return _createClass(ConsoleCallbackHandler, [{
    key: "persistRun",
    value: function persistRun(_run) {
      return Promise.resolve();
    }
    // utility methods
    /**
     * Method used to get all the parent runs of a given run.
     * @param run The run whose parents are to be retrieved.
     * @returns An array of parent runs.
     */
  }, {
    key: "getParents",
    value: function getParents(run) {
      var parents = [];
      var currentRun = run;
      while (currentRun.parent_run_id) {
        var parent = this.runMap.get(currentRun.parent_run_id);
        if (parent) {
          parents.push(parent);
          currentRun = parent;
        } else {
          break;
        }
      }
      return parents;
    }
    /**
     * Method used to get a string representation of the run's lineage, which
     * is used in logging.
     * @param run The run whose lineage is to be retrieved.
     * @returns A string representation of the run's lineage.
     */
  }, {
    key: "getBreadcrumbs",
    value: function getBreadcrumbs(run) {
      var parents = this.getParents(run).reverse();
      var string = [].concat(_toConsumableArray(parents), [run]).map(function (parent, i, arr) {
        var name = "".concat(parent.execution_order, ":").concat(parent.run_type, ":").concat(parent.name);
        return i === arr.length - 1 ? wrap(ansi_styles__WEBPACK_IMPORTED_MODULE_0__.bold, name) : name;
      }).join(" > ");
      return wrap(color.grey, string);
    }
    // logging methods
    /**
     * Method used to log the start of a chain run.
     * @param run The chain run that has started.
     * @returns void
     */
  }, {
    key: "onChainStart",
    value: function onChainStart(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.green, "[chain/start]"), " [").concat(crumbs, "] Entering Chain run with input: ").concat(tryJsonStringify(run.inputs, "[inputs]")));
    }
    /**
     * Method used to log the end of a chain run.
     * @param run The chain run that has ended.
     * @returns void
     */
  }, {
    key: "onChainEnd",
    value: function onChainEnd(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.cyan, "[chain/end]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Exiting Chain run with output: ").concat(tryJsonStringify(run.outputs, "[outputs]")));
    }
    /**
     * Method used to log any errors of a chain run.
     * @param run The chain run that has errored.
     * @returns void
     */
  }, {
    key: "onChainError",
    value: function onChainError(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.red, "[chain/error]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Chain run errored with error: ").concat(tryJsonStringify(run.error, "[error]")));
    }
    /**
     * Method used to log the start of an LLM run.
     * @param run The LLM run that has started.
     * @returns void
     */
  }, {
    key: "onLLMStart",
    value: function onLLMStart(run) {
      var crumbs = this.getBreadcrumbs(run);
      var inputs = "prompts" in run.inputs ? {
        prompts: run.inputs.prompts.map(function (p) {
          return p.trim();
        })
      } : run.inputs;
      console.log("".concat(wrap(color.green, "[llm/start]"), " [").concat(crumbs, "] Entering LLM run with input: ").concat(tryJsonStringify(inputs, "[inputs]")));
    }
    /**
     * Method used to log the end of an LLM run.
     * @param run The LLM run that has ended.
     * @returns void
     */
  }, {
    key: "onLLMEnd",
    value: function onLLMEnd(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.cyan, "[llm/end]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Exiting LLM run with output: ").concat(tryJsonStringify(run.outputs, "[response]")));
    }
    /**
     * Method used to log any errors of an LLM run.
     * @param run The LLM run that has errored.
     * @returns void
     */
  }, {
    key: "onLLMError",
    value: function onLLMError(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.red, "[llm/error]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] LLM run errored with error: ").concat(tryJsonStringify(run.error, "[error]")));
    }
    /**
     * Method used to log the start of a tool run.
     * @param run The tool run that has started.
     * @returns void
     */
  }, {
    key: "onToolStart",
    value: function onToolStart(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.green, "[tool/start]"), " [").concat(crumbs, "] Entering Tool run with input: \"").concat(formatKVMapItem(run.inputs.input), "\""));
    }
    /**
     * Method used to log the end of a tool run.
     * @param run The tool run that has ended.
     * @returns void
     */
  }, {
    key: "onToolEnd",
    value: function onToolEnd(run) {
      var _run$outputs;
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.cyan, "[tool/end]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Exiting Tool run with output: \"").concat(formatKVMapItem((_run$outputs = run.outputs) === null || _run$outputs === void 0 ? void 0 : _run$outputs.output), "\""));
    }
    /**
     * Method used to log any errors of a tool run.
     * @param run The tool run that has errored.
     * @returns void
     */
  }, {
    key: "onToolError",
    value: function onToolError(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.red, "[tool/error]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Tool run errored with error: ").concat(tryJsonStringify(run.error, "[error]")));
    }
    /**
     * Method used to log the start of a retriever run.
     * @param run The retriever run that has started.
     * @returns void
     */
  }, {
    key: "onRetrieverStart",
    value: function onRetrieverStart(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.green, "[retriever/start]"), " [").concat(crumbs, "] Entering Retriever run with input: ").concat(tryJsonStringify(run.inputs, "[inputs]")));
    }
    /**
     * Method used to log the end of a retriever run.
     * @param run The retriever run that has ended.
     * @returns void
     */
  }, {
    key: "onRetrieverEnd",
    value: function onRetrieverEnd(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.cyan, "[retriever/end]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Exiting Retriever run with output: ").concat(tryJsonStringify(run.outputs, "[outputs]")));
    }
    /**
     * Method used to log any errors of a retriever run.
     * @param run The retriever run that has errored.
     * @returns void
     */
  }, {
    key: "onRetrieverError",
    value: function onRetrieverError(run) {
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.red, "[retriever/error]"), " [").concat(crumbs, "] [").concat(elapsed(run), "] Retriever run errored with error: ").concat(tryJsonStringify(run.error, "[error]")));
    }
    /**
     * Method used to log the action selected by the agent.
     * @param run The run in which the agent action occurred.
     * @returns void
     */
  }, {
    key: "onAgentAction",
    value: function onAgentAction(run) {
      var agentRun = run;
      var crumbs = this.getBreadcrumbs(run);
      console.log("".concat(wrap(color.blue, "[agent/action]"), " [").concat(crumbs, "] Agent selected action: ").concat(tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")));
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tracers/event_stream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/event_stream.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventStreamCallbackHandler: () => (/* binding */ EventStreamCallbackHandler),
/* harmony export */   isStreamEventsHandler: () => (/* binding */ isStreamEventsHandler)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/tracers/base.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/@langchain/core/dist/utils/stream.js");
/* harmony import */ var _messages_ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/ai.js */ "./node_modules/@langchain/core/dist/messages/ai.js");
/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../outputs.js */ "./node_modules/@langchain/core/dist/outputs.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _OverloadYield(e, d) { this.v = e, this.k = d; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(r) { var n = this.s["return"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, "throw": function _throw(r) { var n = this.s["return"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }




function assignName(_ref) {
  var name = _ref.name,
    serialized = _ref.serialized;
  if (name !== undefined) {
    return name;
  }
  if ((serialized === null || serialized === void 0 ? void 0 : serialized.name) !== undefined) {
    return serialized.name;
  } else if ((serialized === null || serialized === void 0 ? void 0 : serialized.id) !== undefined && Array.isArray(serialized === null || serialized === void 0 ? void 0 : serialized.id)) {
    return serialized.id[serialized.id.length - 1];
  }
  return "Unnamed";
}
var isStreamEventsHandler = function isStreamEventsHandler(handler) {
  return handler.name === "event_stream_tracer";
};
/**
 * Class that extends the `BaseTracer` class from the
 * `langchain.callbacks.tracers.base` module. It represents a callback
 * handler that logs the execution of runs and emits `RunLog` instances to a
 * `RunLogStream`.
 */
var EventStreamCallbackHandler = /*#__PURE__*/function (_BaseTracer) {
  function EventStreamCallbackHandler(fields) {
    var _fields$autoClose;
    var _this2;
    _classCallCheck(this, EventStreamCallbackHandler);
    _this2 = _callSuper(this, EventStreamCallbackHandler, [_objectSpread({
      _awaitHandler: true
    }, fields)]);
    Object.defineProperty(_this2, "autoClose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this2, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "runInfoMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Map()
    });
    Object.defineProperty(_this2, "tappedPromises", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Map()
    });
    Object.defineProperty(_this2, "transformStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "writer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "receiveStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this2, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "event_stream_tracer"
    });
    _this2.autoClose = (_fields$autoClose = fields === null || fields === void 0 ? void 0 : fields.autoClose) !== null && _fields$autoClose !== void 0 ? _fields$autoClose : true;
    _this2.includeNames = fields === null || fields === void 0 ? void 0 : fields.includeNames;
    _this2.includeTypes = fields === null || fields === void 0 ? void 0 : fields.includeTypes;
    _this2.includeTags = fields === null || fields === void 0 ? void 0 : fields.includeTags;
    _this2.excludeNames = fields === null || fields === void 0 ? void 0 : fields.excludeNames;
    _this2.excludeTypes = fields === null || fields === void 0 ? void 0 : fields.excludeTypes;
    _this2.excludeTags = fields === null || fields === void 0 ? void 0 : fields.excludeTags;
    _this2.transformStream = new TransformStream();
    _this2.writer = _this2.transformStream.writable.getWriter();
    _this2.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__.IterableReadableStream.fromReadableStream(_this2.transformStream.readable);
    return _this2;
  }
  _inherits(EventStreamCallbackHandler, _BaseTracer);
  return _createClass(EventStreamCallbackHandler, [{
    key: Symbol.asyncIterator,
    value: function value() {
      return this.receiveStream;
    }
  }, {
    key: "persistRun",
    value: function () {
      var _persistRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_run) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function persistRun(_x) {
        return _persistRun.apply(this, arguments);
      }
      return persistRun;
    }()
  }, {
    key: "_includeRun",
    value: function _includeRun(run) {
      var _run$tags,
        _this3 = this;
      var runTags = (_run$tags = run.tags) !== null && _run$tags !== void 0 ? _run$tags : [];
      var include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;
      if (this.includeNames !== undefined) {
        include = include || this.includeNames.includes(run.name);
      }
      if (this.includeTypes !== undefined) {
        include = include || this.includeTypes.includes(run.runType);
      }
      if (this.includeTags !== undefined) {
        include = include || runTags.find(function (tag) {
          var _this3$includeTags;
          return (_this3$includeTags = _this3.includeTags) === null || _this3$includeTags === void 0 ? void 0 : _this3$includeTags.includes(tag);
        }) !== undefined;
      }
      if (this.excludeNames !== undefined) {
        include = include && !this.excludeNames.includes(run.name);
      }
      if (this.excludeTypes !== undefined) {
        include = include && !this.excludeTypes.includes(run.runType);
      }
      if (this.excludeTags !== undefined) {
        include = include && runTags.every(function (tag) {
          var _this3$excludeTags;
          return !((_this3$excludeTags = _this3.excludeTags) !== null && _this3$excludeTags !== void 0 && _this3$excludeTags.includes(tag));
        });
      }
      return include;
    }
  }, {
    key: "tapOutputIterable",
    value: function tapOutputIterable(runId, outputStream) {
      var _this = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var firstChunk, runInfo, _formatOutputChunk, tappedPromise, tappedPromiseResolver, event, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _chunk;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _formatOutputChunk = function _formatOutputChunk2(eventType, data) {
                if (eventType === "llm" && typeof data === "string") {
                  return new _outputs_js__WEBPACK_IMPORTED_MODULE_3__.GenerationChunk({
                    text: data
                  });
                }
                return data;
              };
              _context2.next = 3;
              return _awaitAsyncGenerator(outputStream.next());
            case 3:
              firstChunk = _context2.sent;
              if (!firstChunk.done) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return");
            case 6:
              runInfo = _this.runInfoMap.get(runId); // Run has finished, don't issue any stream events.
              // An example of this is for runnables that use the default
              // implementation of .stream(), which delegates to .invoke()
              // and calls .onChainEnd() before passing it to the iterator.
              if (!(runInfo === undefined)) {
                _context2.next = 11;
                break;
              }
              _context2.next = 10;
              return firstChunk.value;
            case 10:
              return _context2.abrupt("return");
            case 11:
              tappedPromise = _this.tappedPromises.get(runId); // if we are the first to tap, issue stream events
              if (!(tappedPromise === undefined)) {
                _context2.next = 58;
                break;
              }
              tappedPromise = new Promise(function (resolve) {
                tappedPromiseResolver = resolve;
              });
              _this.tappedPromises.set(runId, tappedPromise);
              _context2.prev = 15;
              event = {
                event: "on_".concat(runInfo.runType, "_stream"),
                run_id: runId,
                name: runInfo.name,
                tags: runInfo.tags,
                metadata: runInfo.metadata,
                data: {}
              };
              _context2.next = 19;
              return _awaitAsyncGenerator(_this.send(_objectSpread(_objectSpread({}, event), {}, {
                data: {
                  chunk: _formatOutputChunk(runInfo.runType, firstChunk.value)
                }
              }), runInfo));
            case 19:
              _context2.next = 21;
              return firstChunk.value;
            case 21:
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context2.prev = 23;
              _iterator = _asyncIterator(outputStream);
            case 25:
              _context2.next = 27;
              return _awaitAsyncGenerator(_iterator.next());
            case 27:
              if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                _context2.next = 37;
                break;
              }
              chunk = _step.value;
              if (!(runInfo.runType !== "tool" && runInfo.runType !== "retriever")) {
                _context2.next = 32;
                break;
              }
              _context2.next = 32;
              return _awaitAsyncGenerator(_this.send(_objectSpread(_objectSpread({}, event), {}, {
                data: {
                  chunk: _formatOutputChunk(runInfo.runType, chunk)
                }
              }), runInfo));
            case 32:
              _context2.next = 34;
              return chunk;
            case 34:
              _iteratorAbruptCompletion = false;
              _context2.next = 25;
              break;
            case 37:
              _context2.next = 43;
              break;
            case 39:
              _context2.prev = 39;
              _context2.t0 = _context2["catch"](23);
              _didIteratorError = true;
              _iteratorError = _context2.t0;
            case 43:
              _context2.prev = 43;
              _context2.prev = 44;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context2.next = 48;
                break;
              }
              _context2.next = 48;
              return _awaitAsyncGenerator(_iterator["return"]());
            case 48:
              _context2.prev = 48;
              if (!_didIteratorError) {
                _context2.next = 51;
                break;
              }
              throw _iteratorError;
            case 51:
              return _context2.finish(48);
            case 52:
              return _context2.finish(43);
            case 53:
              _context2.prev = 53;
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              tappedPromiseResolver();
              // Don't delete from the promises map to keep track of which runs have been tapped.
              return _context2.finish(53);
            case 56:
              _context2.next = 89;
              break;
            case 58:
              _context2.next = 60;
              return firstChunk.value;
            case 60:
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context2.prev = 62;
              _iterator2 = _asyncIterator(outputStream);
            case 64:
              _context2.next = 66;
              return _awaitAsyncGenerator(_iterator2.next());
            case 66:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {
                _context2.next = 73;
                break;
              }
              _chunk = _step2.value;
              _context2.next = 70;
              return _chunk;
            case 70:
              _iteratorAbruptCompletion2 = false;
              _context2.next = 64;
              break;
            case 73:
              _context2.next = 79;
              break;
            case 75:
              _context2.prev = 75;
              _context2.t1 = _context2["catch"](62);
              _didIteratorError2 = true;
              _iteratorError2 = _context2.t1;
            case 79:
              _context2.prev = 79;
              _context2.prev = 80;
              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context2.next = 84;
                break;
              }
              _context2.next = 84;
              return _awaitAsyncGenerator(_iterator2["return"]());
            case 84:
              _context2.prev = 84;
              if (!_didIteratorError2) {
                _context2.next = 87;
                break;
              }
              throw _iteratorError2;
            case 87:
              return _context2.finish(84);
            case 88:
              return _context2.finish(79);
            case 89:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[15,, 53, 56], [23, 39, 43, 53], [44,, 48, 52], [62, 75, 79, 89], [80,, 84, 88]]);
      }))();
    }
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload, run) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!this._includeRun(run)) {
                _context3.next = 3;
                break;
              }
              _context3.next = 3;
              return this.writer.write(payload);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function send(_x2, _x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "sendEndEvent",
    value: function () {
      var _sendEndEvent = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(payload, run) {
        var _this4 = this;
        var tappedPromise;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              tappedPromise = this.tappedPromises.get(payload.run_id);
              if (!(tappedPromise !== undefined)) {
                _context4.next = 5;
                break;
              }
              void tappedPromise.then(function () {
                void _this4.send(payload, run);
              });
              _context4.next = 7;
              break;
            case 5:
              _context4.next = 7;
              return this.send(payload, run);
            case 7:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function sendEndEvent(_x4, _x5) {
        return _sendEndEvent.apply(this, arguments);
      }
      return sendEndEvent;
    }()
  }, {
    key: "onLLMStart",
    value: function () {
      var _onLLMStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(run) {
        var _run$tags2, _run$extra$metadata, _run$extra, _run$tags3, _run$extra$metadata2, _run$extra2;
        var runName, runType, runInfo, eventName;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              runName = assignName(run);
              runType = run.inputs.messages !== undefined ? "chat_model" : "llm";
              runInfo = {
                tags: (_run$tags2 = run.tags) !== null && _run$tags2 !== void 0 ? _run$tags2 : [],
                metadata: (_run$extra$metadata = (_run$extra = run.extra) === null || _run$extra === void 0 ? void 0 : _run$extra.metadata) !== null && _run$extra$metadata !== void 0 ? _run$extra$metadata : {},
                name: runName,
                runType: runType,
                inputs: run.inputs
              };
              this.runInfoMap.set(run.id, runInfo);
              eventName = "on_".concat(runType, "_start");
              _context5.next = 7;
              return this.send({
                event: eventName,
                data: {
                  input: run.inputs
                },
                name: runName,
                tags: (_run$tags3 = run.tags) !== null && _run$tags3 !== void 0 ? _run$tags3 : [],
                run_id: run.id,
                metadata: (_run$extra$metadata2 = (_run$extra2 = run.extra) === null || _run$extra2 === void 0 ? void 0 : _run$extra2.metadata) !== null && _run$extra$metadata2 !== void 0 ? _run$extra$metadata2 : {}
              }, runInfo);
            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function onLLMStart(_x6) {
        return _onLLMStart.apply(this, arguments);
      }
      return onLLMStart;
    }()
  }, {
    key: "onLLMNewToken",
    value: function () {
      var _onLLMNewToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(run, token,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      kwargs) {
        var runInfo, chunk, eventName;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              runInfo = this.runInfoMap.get(run.id);
              if (!(runInfo === undefined)) {
                _context6.next = 3;
                break;
              }
              throw new Error("onLLMNewToken: Run ID ".concat(run.id, " not found in run map."));
            case 3:
              if (!(this.runInfoMap.size === 1)) {
                _context6.next = 5;
                break;
              }
              return _context6.abrupt("return");
            case 5:
              if (!(runInfo.runType === "chat_model")) {
                _context6.next = 10;
                break;
              }
              eventName = "on_chat_model_stream";
              if ((kwargs === null || kwargs === void 0 ? void 0 : kwargs.chunk) === undefined) {
                chunk = new _messages_ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessageChunk({
                  content: token,
                  id: "run-".concat(run.id)
                });
              } else {
                chunk = kwargs.chunk.message;
              }
              _context6.next = 16;
              break;
            case 10:
              if (!(runInfo.runType === "llm")) {
                _context6.next = 15;
                break;
              }
              eventName = "on_llm_stream";
              if ((kwargs === null || kwargs === void 0 ? void 0 : kwargs.chunk) === undefined) {
                chunk = new _outputs_js__WEBPACK_IMPORTED_MODULE_3__.GenerationChunk({
                  text: token
                });
              } else {
                chunk = kwargs.chunk;
              }
              _context6.next = 16;
              break;
            case 15:
              throw new Error("Unexpected run type ".concat(runInfo.runType));
            case 16:
              _context6.next = 18;
              return this.send({
                event: eventName,
                data: {
                  chunk: chunk
                },
                run_id: run.id,
                name: runInfo.name,
                tags: runInfo.tags,
                metadata: runInfo.metadata
              }, runInfo);
            case 18:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function onLLMNewToken(_x7, _x8, _x9) {
        return _onLLMNewToken.apply(this, arguments);
      }
      return onLLMNewToken;
    }()
  }, {
    key: "onLLMEnd",
    value: function () {
      var _onLLMEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(run) {
        var _run$outputs;
        var runInfo, eventName, generations, output, _iterator3, _step3, _generation$, generation, _run$outputs$llmOutpu, _run$outputs2;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              runInfo = this.runInfoMap.get(run.id);
              this.runInfoMap["delete"](run.id);
              if (!(runInfo === undefined)) {
                _context7.next = 4;
                break;
              }
              throw new Error("onLLMEnd: Run ID ".concat(run.id, " not found in run map."));
            case 4:
              generations = (_run$outputs = run.outputs) === null || _run$outputs === void 0 ? void 0 : _run$outputs.generations; // eslint-disable-next-line @typescript-eslint/no-explicit-any
              if (!(runInfo.runType === "chat_model")) {
                _context7.next = 27;
                break;
              }
              _iterator3 = _createForOfIteratorHelper(generations !== null && generations !== void 0 ? generations : []);
              _context7.prev = 7;
              _iterator3.s();
            case 9:
              if ((_step3 = _iterator3.n()).done) {
                _context7.next = 16;
                break;
              }
              generation = _step3.value;
              if (!(output !== undefined)) {
                _context7.next = 13;
                break;
              }
              return _context7.abrupt("break", 16);
            case 13:
              output = (_generation$ = generation[0]) === null || _generation$ === void 0 ? void 0 : _generation$.message;
            case 14:
              _context7.next = 9;
              break;
            case 16:
              _context7.next = 21;
              break;
            case 18:
              _context7.prev = 18;
              _context7.t0 = _context7["catch"](7);
              _iterator3.e(_context7.t0);
            case 21:
              _context7.prev = 21;
              _iterator3.f();
              return _context7.finish(21);
            case 24:
              eventName = "on_chat_model_end";
              _context7.next = 33;
              break;
            case 27:
              if (!(runInfo.runType === "llm")) {
                _context7.next = 32;
                break;
              }
              output = {
                generations: generations === null || generations === void 0 ? void 0 : generations.map(function (generation) {
                  return generation.map(function (chunk) {
                    return {
                      text: chunk.text,
                      generationInfo: chunk.generationInfo
                    };
                  });
                }),
                llmOutput: (_run$outputs$llmOutpu = (_run$outputs2 = run.outputs) === null || _run$outputs2 === void 0 ? void 0 : _run$outputs2.llmOutput) !== null && _run$outputs$llmOutpu !== void 0 ? _run$outputs$llmOutpu : {}
              };
              eventName = "on_llm_end";
              _context7.next = 33;
              break;
            case 32:
              throw new Error("onLLMEnd: Unexpected run type: ".concat(runInfo.runType));
            case 33:
              _context7.next = 35;
              return this.sendEndEvent({
                event: eventName,
                data: {
                  output: output,
                  input: runInfo.inputs
                },
                run_id: run.id,
                name: runInfo.name,
                tags: runInfo.tags,
                metadata: runInfo.metadata
              }, runInfo);
            case 35:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[7, 18, 21, 24]]);
      }));
      function onLLMEnd(_x10) {
        return _onLLMEnd.apply(this, arguments);
      }
      return onLLMEnd;
    }()
  }, {
    key: "onChainStart",
    value: function () {
      var _onChainStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(run) {
        var _run$run_type, _run$tags4, _run$extra$metadata3, _run$extra3, _run$tags5, _run$extra$metadata4, _run$extra4;
        var runName, runType, runInfo, eventData;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              runName = assignName(run);
              runType = (_run$run_type = run.run_type) !== null && _run$run_type !== void 0 ? _run$run_type : "chain";
              runInfo = {
                tags: (_run$tags4 = run.tags) !== null && _run$tags4 !== void 0 ? _run$tags4 : [],
                metadata: (_run$extra$metadata3 = (_run$extra3 = run.extra) === null || _run$extra3 === void 0 ? void 0 : _run$extra3.metadata) !== null && _run$extra$metadata3 !== void 0 ? _run$extra$metadata3 : {},
                name: runName,
                runType: run.run_type
              };
              eventData = {}; // Workaround Runnable core code not sending input when transform streaming.
              if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
                eventData = {};
                runInfo.inputs = {};
              } else if (run.inputs.input !== undefined) {
                eventData.input = run.inputs.input;
                runInfo.inputs = run.inputs.input;
              } else {
                eventData.input = run.inputs;
                runInfo.inputs = run.inputs;
              }
              this.runInfoMap.set(run.id, runInfo);
              _context8.next = 8;
              return this.send({
                event: "on_".concat(runType, "_start"),
                data: eventData,
                name: runName,
                tags: (_run$tags5 = run.tags) !== null && _run$tags5 !== void 0 ? _run$tags5 : [],
                run_id: run.id,
                metadata: (_run$extra$metadata4 = (_run$extra4 = run.extra) === null || _run$extra4 === void 0 ? void 0 : _run$extra4.metadata) !== null && _run$extra$metadata4 !== void 0 ? _run$extra$metadata4 : {}
              }, runInfo);
            case 8:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function onChainStart(_x11) {
        return _onChainStart.apply(this, arguments);
      }
      return onChainStart;
    }()
  }, {
    key: "onChainEnd",
    value: function () {
      var _onChainEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(run) {
        var _ref2, _run$inputs, _run$outputs$output, _run$outputs3, _runInfo$metadata;
        var runInfo, eventName, inputs, outputs, data;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              runInfo = this.runInfoMap.get(run.id);
              this.runInfoMap["delete"](run.id);
              if (!(runInfo === undefined)) {
                _context9.next = 4;
                break;
              }
              throw new Error("onChainEnd: Run ID ".concat(run.id, " not found in run map."));
            case 4:
              eventName = "on_".concat(run.run_type, "_end");
              inputs = (_ref2 = (_run$inputs = run.inputs) !== null && _run$inputs !== void 0 ? _run$inputs : runInfo.inputs) !== null && _ref2 !== void 0 ? _ref2 : {};
              outputs = (_run$outputs$output = (_run$outputs3 = run.outputs) === null || _run$outputs3 === void 0 ? void 0 : _run$outputs3.output) !== null && _run$outputs$output !== void 0 ? _run$outputs$output : run.outputs;
              data = {
                output: outputs,
                input: inputs
              };
              if (inputs.input && Object.keys(inputs).length === 1) {
                data.input = inputs.input;
                runInfo.inputs = inputs.input;
              }
              _context9.next = 11;
              return this.sendEndEvent({
                event: eventName,
                data: data,
                run_id: run.id,
                name: runInfo.name,
                tags: runInfo.tags,
                metadata: (_runInfo$metadata = runInfo.metadata) !== null && _runInfo$metadata !== void 0 ? _runInfo$metadata : {}
              }, runInfo);
            case 11:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function onChainEnd(_x12) {
        return _onChainEnd.apply(this, arguments);
      }
      return onChainEnd;
    }()
  }, {
    key: "onToolStart",
    value: function () {
      var _onToolStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(run) {
        var _run$tags6, _run$extra$metadata5, _run$extra5, _run$inputs2, _run$inputs3, _run$tags7, _run$extra$metadata6, _run$extra6;
        var runName, runInfo;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              runName = assignName(run);
              runInfo = {
                tags: (_run$tags6 = run.tags) !== null && _run$tags6 !== void 0 ? _run$tags6 : [],
                metadata: (_run$extra$metadata5 = (_run$extra5 = run.extra) === null || _run$extra5 === void 0 ? void 0 : _run$extra5.metadata) !== null && _run$extra$metadata5 !== void 0 ? _run$extra$metadata5 : {},
                name: runName,
                runType: "tool",
                inputs: (_run$inputs2 = run.inputs) !== null && _run$inputs2 !== void 0 ? _run$inputs2 : {}
              };
              this.runInfoMap.set(run.id, runInfo);
              _context10.next = 5;
              return this.send({
                event: "on_tool_start",
                data: {
                  input: (_run$inputs3 = run.inputs) !== null && _run$inputs3 !== void 0 ? _run$inputs3 : {}
                },
                name: runName,
                run_id: run.id,
                tags: (_run$tags7 = run.tags) !== null && _run$tags7 !== void 0 ? _run$tags7 : [],
                metadata: (_run$extra$metadata6 = (_run$extra6 = run.extra) === null || _run$extra6 === void 0 ? void 0 : _run$extra6.metadata) !== null && _run$extra$metadata6 !== void 0 ? _run$extra$metadata6 : {}
              }, runInfo);
            case 5:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function onToolStart(_x13) {
        return _onToolStart.apply(this, arguments);
      }
      return onToolStart;
    }()
  }, {
    key: "onToolEnd",
    value: function () {
      var _onToolEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(run) {
        var _run$outputs4;
        var runInfo, output;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              runInfo = this.runInfoMap.get(run.id);
              this.runInfoMap["delete"](run.id);
              if (!(runInfo === undefined)) {
                _context11.next = 4;
                break;
              }
              throw new Error("onToolEnd: Run ID ".concat(run.id, " not found in run map."));
            case 4:
              if (!(runInfo.inputs === undefined)) {
                _context11.next = 6;
                break;
              }
              throw new Error("onToolEnd: Run ID ".concat(run.id, " is a tool call, and is expected to have traced inputs."));
            case 6:
              output = ((_run$outputs4 = run.outputs) === null || _run$outputs4 === void 0 ? void 0 : _run$outputs4.output) === undefined ? run.outputs : run.outputs.output;
              _context11.next = 9;
              return this.sendEndEvent({
                event: "on_tool_end",
                data: {
                  output: output,
                  input: runInfo.inputs
                },
                run_id: run.id,
                name: runInfo.name,
                tags: runInfo.tags,
                metadata: runInfo.metadata
              }, runInfo);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function onToolEnd(_x14) {
        return _onToolEnd.apply(this, arguments);
      }
      return onToolEnd;
    }()
  }, {
    key: "onRetrieverStart",
    value: function () {
      var _onRetrieverStart = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(run) {
        var _run$tags8, _run$extra$metadata7, _run$extra7, _run$tags9, _run$extra$metadata8, _run$extra8;
        var runName, runType, runInfo;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              runName = assignName(run);
              runType = "retriever";
              runInfo = {
                tags: (_run$tags8 = run.tags) !== null && _run$tags8 !== void 0 ? _run$tags8 : [],
                metadata: (_run$extra$metadata7 = (_run$extra7 = run.extra) === null || _run$extra7 === void 0 ? void 0 : _run$extra7.metadata) !== null && _run$extra$metadata7 !== void 0 ? _run$extra$metadata7 : {},
                name: runName,
                runType: runType,
                inputs: {
                  query: run.inputs.query
                }
              };
              this.runInfoMap.set(run.id, runInfo);
              _context12.next = 6;
              return this.send({
                event: "on_retriever_start",
                data: {
                  input: {
                    query: run.inputs.query
                  }
                },
                name: runName,
                tags: (_run$tags9 = run.tags) !== null && _run$tags9 !== void 0 ? _run$tags9 : [],
                run_id: run.id,
                metadata: (_run$extra$metadata8 = (_run$extra8 = run.extra) === null || _run$extra8 === void 0 ? void 0 : _run$extra8.metadata) !== null && _run$extra$metadata8 !== void 0 ? _run$extra$metadata8 : {}
              }, runInfo);
            case 6:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function onRetrieverStart(_x15) {
        return _onRetrieverStart.apply(this, arguments);
      }
      return onRetrieverStart;
    }()
  }, {
    key: "onRetrieverEnd",
    value: function () {
      var _onRetrieverEnd = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(run) {
        var _run$outputs$document, _run$outputs5;
        var runInfo;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              runInfo = this.runInfoMap.get(run.id);
              this.runInfoMap["delete"](run.id);
              if (!(runInfo === undefined)) {
                _context13.next = 4;
                break;
              }
              throw new Error("onRetrieverEnd: Run ID ".concat(run.id, " not found in run map."));
            case 4:
              _context13.next = 6;
              return this.sendEndEvent({
                event: "on_retriever_end",
                data: {
                  output: (_run$outputs$document = (_run$outputs5 = run.outputs) === null || _run$outputs5 === void 0 ? void 0 : _run$outputs5.documents) !== null && _run$outputs$document !== void 0 ? _run$outputs$document : run.outputs,
                  input: runInfo.inputs
                },
                run_id: run.id,
                name: runInfo.name,
                tags: runInfo.tags,
                metadata: runInfo.metadata
              }, runInfo);
            case 6:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function onRetrieverEnd(_x16) {
        return _onRetrieverEnd.apply(this, arguments);
      }
      return onRetrieverEnd;
    }() // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "handleCustomEvent",
    value: function () {
      var _handleCustomEvent = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(eventName, data, runId) {
        var runInfo;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              runInfo = this.runInfoMap.get(runId);
              if (!(runInfo === undefined)) {
                _context14.next = 3;
                break;
              }
              throw new Error("handleCustomEvent: Run ID ".concat(runId, " not found in run map."));
            case 3:
              _context14.next = 5;
              return this.send({
                event: "on_custom_event",
                run_id: runId,
                name: eventName,
                tags: runInfo.tags,
                metadata: runInfo.metadata,
                data: data
              }, runInfo);
            case 5:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function handleCustomEvent(_x17, _x18, _x19) {
        return _handleCustomEvent.apply(this, arguments);
      }
      return handleCustomEvent;
    }()
  }, {
    key: "finish",
    value: function () {
      var _finish = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var _this5 = this;
        var pendingPromises;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              pendingPromises = _toConsumableArray(this.tappedPromises.values());
              void Promise.all(pendingPromises)["finally"](function () {
                void _this5.writer.close();
              });
            case 2:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function finish() {
        return _finish.apply(this, arguments);
      }
      return finish;
    }()
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tracers/log_stream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/log_stream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogStreamCallbackHandler: () => (/* binding */ LogStreamCallbackHandler),
/* harmony export */   RunLog: () => (/* binding */ RunLog),
/* harmony export */   RunLogPatch: () => (/* binding */ RunLogPatch),
/* harmony export */   isLogStreamHandler: () => (/* binding */ isLogStreamHandler)
/* harmony export */ });
/* harmony import */ var _utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/fast-json-patch/index.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/tracers/base.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/@langchain/core/dist/utils/stream.js");
/* harmony import */ var _messages_ai_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../messages/ai.js */ "./node_modules/@langchain/core/dist/messages/ai.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _OverloadYield(e, d) { this.v = e, this.k = d; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(r) { var n = this.s["return"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, "throw": function _throw(r) { var n = this.s["return"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }




/**
 * List of jsonpatch JSONPatchOperations, which describe how to create the run state
 * from an empty dict. This is the minimal representation of the log, designed to
 * be serialized as JSON and sent over the wire to reconstruct the log on the other
 * side. Reconstruction of the state can be done with any jsonpatch-compliant library,
 * see https://jsonpatch.com for more information.
 */
var RunLogPatch = /*#__PURE__*/function () {
  function RunLogPatch(fields) {
    var _fields$ops;
    _classCallCheck(this, RunLogPatch);
    Object.defineProperty(this, "ops", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.ops = (_fields$ops = fields.ops) !== null && _fields$ops !== void 0 ? _fields$ops : [];
  }
  return _createClass(RunLogPatch, [{
    key: "concat",
    value: function concat(other) {
      var ops = this.ops.concat(other.ops);
      var states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, ops);
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunLog({
        ops: ops,
        state: states[states.length - 1].newDocument
      });
    }
  }]);
}();
var RunLog = /*#__PURE__*/function (_RunLogPatch) {
  function RunLog(fields) {
    var _this2;
    _classCallCheck(this, RunLog);
    _this2 = _callSuper(this, RunLog, [fields]);
    Object.defineProperty(_this2, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this2.state = fields.state;
    return _this2;
  }
  _inherits(RunLog, _RunLogPatch);
  return _createClass(RunLog, [{
    key: "concat",
    value: function concat(other) {
      var ops = this.ops.concat(other.ops);
      var states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)(this.state, other.ops);
      return new RunLog({
        ops: ops,
        state: states[states.length - 1].newDocument
      });
    }
  }], [{
    key: "fromRunLogPatch",
    value: function fromRunLogPatch(patch) {
      var states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, patch.ops);
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return new RunLog({
        ops: patch.ops,
        state: states[states.length - 1].newDocument
      });
    }
  }]);
}(RunLogPatch);
var isLogStreamHandler = function isLogStreamHandler(handler) {
  return handler.name === "log_stream_tracer";
};
/**
 * Extract standardized inputs from a run.
 *
 * Standardizes the inputs based on the type of the runnable used.
 *
 * @param run - Run object
 * @param schemaFormat - The schema format to use.
 *
 * @returns Valid inputs are only dict. By conventions, inputs always represented
 * invocation using named arguments.
 * A null means that the input is not yet known!
 */
function _getStandardizedInputs(_x, _x2) {
  return _getStandardizedInputs2.apply(this, arguments);
}
function _getStandardizedInputs2() {
  _getStandardizedInputs2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(run, schemaFormat) {
    var inputs;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          if (!(schemaFormat === "original")) {
            _context6.next = 2;
            break;
          }
          throw new Error("Do not assign inputs with original schema drop the key for now. " + "When inputs are added to streamLog they should be added with " + "standardized schema for streaming events.");
        case 2:
          inputs = run.inputs;
          if (!["retriever", "llm", "prompt"].includes(run.run_type)) {
            _context6.next = 5;
            break;
          }
          return _context6.abrupt("return", inputs);
        case 5:
          if (!(Object.keys(inputs).length === 1 && (inputs === null || inputs === void 0 ? void 0 : inputs.input) === "")) {
            _context6.next = 7;
            break;
          }
          return _context6.abrupt("return", undefined);
        case 7:
          return _context6.abrupt("return", inputs.input);
        case 8:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _getStandardizedInputs2.apply(this, arguments);
}
function _getStandardizedOutputs(_x3, _x4) {
  return _getStandardizedOutputs2.apply(this, arguments);
}
function _getStandardizedOutputs2() {
  _getStandardizedOutputs2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(run, schemaFormat) {
    var outputs;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          outputs = run.outputs;
          if (!(schemaFormat === "original")) {
            _context7.next = 3;
            break;
          }
          return _context7.abrupt("return", outputs);
        case 3:
          if (!["retriever", "llm", "prompt"].includes(run.run_type)) {
            _context7.next = 5;
            break;
          }
          return _context7.abrupt("return", outputs);
        case 5:
          if (!(outputs !== undefined && Object.keys(outputs).length === 1 && (outputs === null || outputs === void 0 ? void 0 : outputs.output) !== undefined)) {
            _context7.next = 7;
            break;
          }
          return _context7.abrupt("return", outputs.output);
        case 7:
          return _context7.abrupt("return", outputs);
        case 8:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _getStandardizedOutputs2.apply(this, arguments);
}
function isChatGenerationChunk(x) {
  return x !== undefined && x.message !== undefined;
}
/**
 * Class that extends the `BaseTracer` class from the
 * `langchain.callbacks.tracers.base` module. It represents a callback
 * handler that logs the execution of runs and emits `RunLog` instances to a
 * `RunLogStream`.
 */
var LogStreamCallbackHandler = /*#__PURE__*/function (_BaseTracer) {
  function LogStreamCallbackHandler(fields) {
    var _fields$autoClose, _fields$_schemaFormat;
    var _this3;
    _classCallCheck(this, LogStreamCallbackHandler);
    _this3 = _callSuper(this, LogStreamCallbackHandler, [_objectSpread({
      _awaitHandler: true
    }, fields)]);
    Object.defineProperty(_this3, "autoClose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this3, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "_schemaFormat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "original"
    });
    Object.defineProperty(_this3, "rootId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "keyMapByRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(_this3, "counterMapByRunName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(_this3, "transformStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "writer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "receiveStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this3, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "log_stream_tracer"
    });
    _this3.autoClose = (_fields$autoClose = fields === null || fields === void 0 ? void 0 : fields.autoClose) !== null && _fields$autoClose !== void 0 ? _fields$autoClose : true;
    _this3.includeNames = fields === null || fields === void 0 ? void 0 : fields.includeNames;
    _this3.includeTypes = fields === null || fields === void 0 ? void 0 : fields.includeTypes;
    _this3.includeTags = fields === null || fields === void 0 ? void 0 : fields.includeTags;
    _this3.excludeNames = fields === null || fields === void 0 ? void 0 : fields.excludeNames;
    _this3.excludeTypes = fields === null || fields === void 0 ? void 0 : fields.excludeTypes;
    _this3.excludeTags = fields === null || fields === void 0 ? void 0 : fields.excludeTags;
    _this3._schemaFormat = (_fields$_schemaFormat = fields === null || fields === void 0 ? void 0 : fields._schemaFormat) !== null && _fields$_schemaFormat !== void 0 ? _fields$_schemaFormat : _this3._schemaFormat;
    _this3.transformStream = new TransformStream();
    _this3.writer = _this3.transformStream.writable.getWriter();
    _this3.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.IterableReadableStream.fromReadableStream(_this3.transformStream.readable);
    return _this3;
  }
  _inherits(LogStreamCallbackHandler, _BaseTracer);
  return _createClass(LogStreamCallbackHandler, [{
    key: Symbol.asyncIterator,
    value: function value() {
      return this.receiveStream;
    }
  }, {
    key: "persistRun",
    value: function () {
      var _persistRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_run) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function persistRun(_x5) {
        return _persistRun.apply(this, arguments);
      }
      return persistRun;
    }()
  }, {
    key: "_includeRun",
    value: function _includeRun(run) {
      var _run$tags,
        _this4 = this;
      if (run.id === this.rootId) {
        return false;
      }
      var runTags = (_run$tags = run.tags) !== null && _run$tags !== void 0 ? _run$tags : [];
      var include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;
      if (this.includeNames !== undefined) {
        include = include || this.includeNames.includes(run.name);
      }
      if (this.includeTypes !== undefined) {
        include = include || this.includeTypes.includes(run.run_type);
      }
      if (this.includeTags !== undefined) {
        include = include || runTags.find(function (tag) {
          var _this4$includeTags;
          return (_this4$includeTags = _this4.includeTags) === null || _this4$includeTags === void 0 ? void 0 : _this4$includeTags.includes(tag);
        }) !== undefined;
      }
      if (this.excludeNames !== undefined) {
        include = include && !this.excludeNames.includes(run.name);
      }
      if (this.excludeTypes !== undefined) {
        include = include && !this.excludeTypes.includes(run.run_type);
      }
      if (this.excludeTags !== undefined) {
        include = include && runTags.every(function (tag) {
          var _this4$excludeTags;
          return !((_this4$excludeTags = _this4.excludeTags) !== null && _this4$excludeTags !== void 0 && _this4$excludeTags.includes(tag));
        });
      }
      return include;
    }
  }, {
    key: "tapOutputIterable",
    value: function tapOutputIterable(runId, output) {
      var _this = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, key;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // Tap an output async iterator to stream its values to the log.
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context2.prev = 2;
              _iterator = _asyncIterator(output);
            case 4:
              _context2.next = 6;
              return _awaitAsyncGenerator(_iterator.next());
            case 6:
              if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                _context2.next = 18;
                break;
              }
              chunk = _step.value;
              if (!(runId !== _this.rootId)) {
                _context2.next = 13;
                break;
              }
              // if we can't find the run silently ignore
              // eg. because this run wasn't included in the log
              key = _this.keyMapByRunId[runId];
              if (!key) {
                _context2.next = 13;
                break;
              }
              _context2.next = 13;
              return _awaitAsyncGenerator(_this.writer.write(new RunLogPatch({
                ops: [{
                  op: "add",
                  path: "/logs/".concat(key, "/streamed_output/-"),
                  value: chunk
                }]
              })));
            case 13:
              _context2.next = 15;
              return chunk;
            case 15:
              _iteratorAbruptCompletion = false;
              _context2.next = 4;
              break;
            case 18:
              _context2.next = 24;
              break;
            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](2);
              _didIteratorError = true;
              _iteratorError = _context2.t0;
            case 24:
              _context2.prev = 24;
              _context2.prev = 25;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context2.next = 29;
                break;
              }
              _context2.next = 29;
              return _awaitAsyncGenerator(_iterator["return"]());
            case 29:
              _context2.prev = 29;
              if (!_didIteratorError) {
                _context2.next = 32;
                break;
              }
              throw _iteratorError;
            case 32:
              return _context2.finish(29);
            case 33:
              return _context2.finish(24);
            case 34:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
      }))();
    }
  }, {
    key: "onRunCreate",
    value: function () {
      var _onRunCreate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(run) {
        var _run$tags2, _run$extra$metadata, _run$extra;
        var count, logEntry;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.rootId === undefined)) {
                _context3.next = 4;
                break;
              }
              this.rootId = run.id;
              _context3.next = 4;
              return this.writer.write(new RunLogPatch({
                ops: [{
                  op: "replace",
                  path: "",
                  value: {
                    id: run.id,
                    name: run.name,
                    type: run.run_type,
                    streamed_output: [],
                    final_output: undefined,
                    logs: {}
                  }
                }]
              }));
            case 4:
              if (this._includeRun(run)) {
                _context3.next = 6;
                break;
              }
              return _context3.abrupt("return");
            case 6:
              if (this.counterMapByRunName[run.name] === undefined) {
                this.counterMapByRunName[run.name] = 0;
              }
              this.counterMapByRunName[run.name] += 1;
              count = this.counterMapByRunName[run.name];
              this.keyMapByRunId[run.id] = count === 1 ? run.name : "".concat(run.name, ":").concat(count);
              logEntry = {
                id: run.id,
                name: run.name,
                type: run.run_type,
                tags: (_run$tags2 = run.tags) !== null && _run$tags2 !== void 0 ? _run$tags2 : [],
                metadata: (_run$extra$metadata = (_run$extra = run.extra) === null || _run$extra === void 0 ? void 0 : _run$extra.metadata) !== null && _run$extra$metadata !== void 0 ? _run$extra$metadata : {},
                start_time: new Date(run.start_time).toISOString(),
                streamed_output: [],
                streamed_output_str: [],
                final_output: undefined,
                end_time: undefined
              };
              if (!(this._schemaFormat === "streaming_events")) {
                _context3.next = 15;
                break;
              }
              _context3.next = 14;
              return _getStandardizedInputs(run, this._schemaFormat);
            case 14:
              logEntry.inputs = _context3.sent;
            case 15:
              _context3.next = 17;
              return this.writer.write(new RunLogPatch({
                ops: [{
                  op: "add",
                  path: "/logs/".concat(this.keyMapByRunId[run.id]),
                  value: logEntry
                }]
              }));
            case 17:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function onRunCreate(_x6) {
        return _onRunCreate.apply(this, arguments);
      }
      return onRunCreate;
    }()
  }, {
    key: "onRunUpdate",
    value: function () {
      var _onRunUpdate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(run) {
        var runName, ops, patch, _patch;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              runName = this.keyMapByRunId[run.id];
              if (!(runName === undefined)) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              ops = [];
              if (!(this._schemaFormat === "streaming_events")) {
                _context4.next = 13;
                break;
              }
              _context4.t0 = ops;
              _context4.t1 = "/logs/".concat(runName, "/inputs");
              _context4.next = 10;
              return _getStandardizedInputs(run, this._schemaFormat);
            case 10:
              _context4.t2 = _context4.sent;
              _context4.t3 = {
                op: "replace",
                path: _context4.t1,
                value: _context4.t2
              };
              _context4.t0.push.call(_context4.t0, _context4.t3);
            case 13:
              _context4.t4 = ops;
              _context4.t5 = "/logs/".concat(runName, "/final_output");
              _context4.next = 17;
              return _getStandardizedOutputs(run, this._schemaFormat);
            case 17:
              _context4.t6 = _context4.sent;
              _context4.t7 = {
                op: "add",
                path: _context4.t5,
                value: _context4.t6
              };
              _context4.t4.push.call(_context4.t4, _context4.t7);
              if (run.end_time !== undefined) {
                ops.push({
                  op: "add",
                  path: "/logs/".concat(runName, "/end_time"),
                  value: new Date(run.end_time).toISOString()
                });
              }
              patch = new RunLogPatch({
                ops: ops
              });
              _context4.next = 24;
              return this.writer.write(patch);
            case 24:
              _context4.prev = 24;
              if (!(run.id === this.rootId)) {
                _context4.next = 39;
                break;
              }
              _context4.t8 = RunLogPatch;
              _context4.next = 29;
              return _getStandardizedOutputs(run, this._schemaFormat);
            case 29:
              _context4.t9 = _context4.sent;
              _context4.t10 = {
                op: "replace",
                path: "/final_output",
                value: _context4.t9
              };
              _context4.t11 = [_context4.t10];
              _context4.t12 = {
                ops: _context4.t11
              };
              _patch = new _context4.t8(_context4.t12);
              _context4.next = 36;
              return this.writer.write(_patch);
            case 36:
              if (!this.autoClose) {
                _context4.next = 39;
                break;
              }
              _context4.next = 39;
              return this.writer.close();
            case 39:
              return _context4.finish(24);
            case 40:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0,, 24, 40]]);
      }));
      function onRunUpdate(_x7) {
        return _onRunUpdate.apply(this, arguments);
      }
      return onRunUpdate;
    }()
  }, {
    key: "onLLMNewToken",
    value: function () {
      var _onLLMNewToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(run, token, kwargs) {
        var runName, isChatModel, streamedOutputValue, patch;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              runName = this.keyMapByRunId[run.id];
              if (!(runName === undefined)) {
                _context5.next = 3;
                break;
              }
              return _context5.abrupt("return");
            case 3:
              // TODO: Remove hack
              isChatModel = run.inputs.messages !== undefined;
              if (isChatModel) {
                if (isChatGenerationChunk(kwargs === null || kwargs === void 0 ? void 0 : kwargs.chunk)) {
                  streamedOutputValue = kwargs === null || kwargs === void 0 ? void 0 : kwargs.chunk;
                } else {
                  streamedOutputValue = new _messages_ai_js__WEBPACK_IMPORTED_MODULE_3__.AIMessageChunk({
                    id: "run-".concat(run.id),
                    content: token
                  });
                }
              } else {
                streamedOutputValue = token;
              }
              patch = new RunLogPatch({
                ops: [{
                  op: "add",
                  path: "/logs/".concat(runName, "/streamed_output_str/-"),
                  value: token
                }, {
                  op: "add",
                  path: "/logs/".concat(runName, "/streamed_output/-"),
                  value: streamedOutputValue
                }]
              });
              _context5.next = 8;
              return this.writer.write(patch);
            case 8:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function onLLMNewToken(_x8, _x9, _x10) {
        return _onLLMNewToken.apply(this, arguments);
      }
      return onLLMNewToken;
    }()
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tracers/root_listener.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/root_listener.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RootListenersTracer: () => (/* binding */ RootListenersTracer)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/tracers/base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var RootListenersTracer = /*#__PURE__*/function (_BaseTracer) {
  function RootListenersTracer(_ref) {
    var _this;
    var config = _ref.config,
      onStart = _ref.onStart,
      onEnd = _ref.onEnd,
      onError = _ref.onError;
    _classCallCheck(this, RootListenersTracer);
    _this = _callSuper(this, RootListenersTracer, [{
      _awaitHandler: true
    }]);
    Object.defineProperty(_this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RootListenersTracer"
    });
    /** The Run's ID. Type UUID */
    Object.defineProperty(_this, "rootId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "argOnStart", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "argOnEnd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "argOnError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.config = config;
    _this.argOnStart = onStart;
    _this.argOnEnd = onEnd;
    _this.argOnError = onError;
    return _this;
  }
  /**
   * This is a legacy method only called once for an entire run tree
   * therefore not useful here
   * @param {Run} _ Not used
   */
  _inherits(RootListenersTracer, _BaseTracer);
  return _createClass(RootListenersTracer, [{
    key: "persistRun",
    value: function persistRun(_) {
      return Promise.resolve();
    }
  }, {
    key: "onRunCreate",
    value: function () {
      var _onRunCreate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(run) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.rootId) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              this.rootId = run.id;
              if (!this.argOnStart) {
                _context.next = 6;
                break;
              }
              _context.next = 6;
              return this.argOnStart(run, this.config);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function onRunCreate(_x) {
        return _onRunCreate.apply(this, arguments);
      }
      return onRunCreate;
    }()
  }, {
    key: "onRunUpdate",
    value: function () {
      var _onRunUpdate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(run) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(run.id !== this.rootId)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return");
            case 2:
              if (run.error) {
                _context2.next = 8;
                break;
              }
              if (!this.argOnEnd) {
                _context2.next = 6;
                break;
              }
              _context2.next = 6;
              return this.argOnEnd(run, this.config);
            case 6:
              _context2.next = 11;
              break;
            case 8:
              if (!this.argOnError) {
                _context2.next = 11;
                break;
              }
              _context2.next = 11;
              return this.argOnError(run, this.config);
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function onRunUpdate(_x2) {
        return _onRunUpdate.apply(this, arguments);
      }
      return onRunUpdate;
    }()
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/tracers/tracer_langchain.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LangChainTracer: () => (/* binding */ LangChainTracer)
/* harmony export */ });
/* harmony import */ var langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith/run_trees */ "./node_modules/langsmith/run_trees.js");
/* harmony import */ var langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langsmith/singletons/traceable */ "./node_modules/langsmith/singletons/traceable.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/env.js */ "./node_modules/@langchain/core/dist/utils/env.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ "./node_modules/@langchain/core/dist/tracers/base.js");
/* harmony import */ var _singletons_tracer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../singletons/tracer.js */ "./node_modules/@langchain/core/dist/singletons/tracer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }





var LangChainTracer = /*#__PURE__*/function (_BaseTracer) {
  function LangChainTracer() {
    var _ref;
    var _this;
    var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, LangChainTracer);
    _this = _callSuper(this, LangChainTracer, [fields]);
    Object.defineProperty(_this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "langchain_tracer"
    });
    Object.defineProperty(_this, "projectName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "exampleId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    var exampleId = fields.exampleId,
      projectName = fields.projectName,
      client = fields.client;
    _this.projectName = (_ref = projectName !== null && projectName !== void 0 ? projectName : (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)("LANGCHAIN_PROJECT")) !== null && _ref !== void 0 ? _ref : (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)("LANGCHAIN_SESSION");
    _this.exampleId = exampleId;
    _this.client = client !== null && client !== void 0 ? client : (0,_singletons_tracer_js__WEBPACK_IMPORTED_MODULE_4__.getDefaultLangChainClientSingleton)();
    var traceableTree = LangChainTracer.getTraceableRunTree();
    if (traceableTree) {
      _this.updateFromRunTree(traceableTree);
    }
    return _this;
  }
  _inherits(LangChainTracer, _BaseTracer);
  return _createClass(LangChainTracer, [{
    key: "_convertToCreate",
    value: function () {
      var _convertToCreate2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(run) {
        var example_id,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              example_id = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;
              _context.t0 = _objectSpread;
              _context.t1 = _objectSpread({}, run);
              _context.t2 = {};
              _context.t3 = _objectSpread;
              _context.t4 = _objectSpread({}, run.extra);
              _context.t5 = {};
              _context.next = 9;
              return (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();
            case 9:
              _context.t6 = _context.sent;
              _context.t7 = {
                runtime: _context.t6
              };
              _context.t8 = (0, _context.t3)(_context.t4, _context.t5, _context.t7);
              _context.t9 = undefined;
              _context.t10 = this.projectName;
              _context.t11 = run.parent_run_id ? undefined : example_id;
              _context.t12 = {
                extra: _context.t8,
                child_runs: _context.t9,
                session_name: _context.t10,
                reference_example_id: _context.t11
              };
              return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2, _context.t12));
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _convertToCreate(_x) {
        return _convertToCreate2.apply(this, arguments);
      }
      return _convertToCreate;
    }()
  }, {
    key: "persistRun",
    value: function () {
      var _persistRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_run) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function persistRun(_x2) {
        return _persistRun.apply(this, arguments);
      }
      return persistRun;
    }()
  }, {
    key: "onRunCreate",
    value: function () {
      var _onRunCreate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(run) {
        var persistedRun;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this._convertToCreate(run, this.exampleId);
            case 2:
              persistedRun = _context3.sent;
              _context3.next = 5;
              return this.client.createRun(persistedRun);
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function onRunCreate(_x3) {
        return _onRunCreate.apply(this, arguments);
      }
      return onRunCreate;
    }()
  }, {
    key: "onRunUpdate",
    value: function () {
      var _onRunUpdate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(run) {
        var runUpdate;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              runUpdate = {
                end_time: run.end_time,
                error: run.error,
                outputs: run.outputs,
                events: run.events,
                inputs: run.inputs,
                trace_id: run.trace_id,
                dotted_order: run.dotted_order,
                parent_run_id: run.parent_run_id
              };
              _context4.next = 3;
              return this.client.updateRun(run.id, runUpdate);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function onRunUpdate(_x4) {
        return _onRunUpdate.apply(this, arguments);
      }
      return onRunUpdate;
    }()
  }, {
    key: "getRun",
    value: function getRun(id) {
      return this.runMap.get(id);
    }
  }, {
    key: "updateFromRunTree",
    value: function updateFromRunTree(runTree) {
      var _runTree$client, _runTree$project_name, _runTree$reference_ex;
      var rootRun = runTree;
      var visited = new Set();
      while (rootRun.parent_run) {
        if (visited.has(rootRun.id)) break;
        visited.add(rootRun.id);
        if (!rootRun.parent_run) break;
        rootRun = rootRun.parent_run;
      }
      visited.clear();
      var queue = [rootRun];
      while (queue.length > 0) {
        var current = queue.shift();
        if (!current || visited.has(current.id)) continue;
        visited.add(current.id);
        // @ts-expect-error Types of property 'events' are incompatible.
        this.runMap.set(current.id, current);
        if (current.child_runs) {
          queue.push.apply(queue, _toConsumableArray(current.child_runs));
        }
      }
      this.client = (_runTree$client = runTree.client) !== null && _runTree$client !== void 0 ? _runTree$client : this.client;
      this.projectName = (_runTree$project_name = runTree.project_name) !== null && _runTree$project_name !== void 0 ? _runTree$project_name : this.projectName;
      this.exampleId = (_runTree$reference_ex = runTree.reference_example_id) !== null && _runTree$reference_ex !== void 0 ? _runTree$reference_ex : this.exampleId;
    }
  }, {
    key: "convertToRunTree",
    value: function convertToRunTree(id) {
      var runTreeMap = {};
      var runTreeList = [];
      var _iterator = _createForOfIteratorHelper(this.runMap),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            _id2 = _step$value[0],
            _run2 = _step$value[1];
          // by converting the run map to a run tree, we are doing a copy
          // thus, any mutation performed on the run tree will not be reflected
          // back in the run map
          // TODO: Stop using `this.runMap` in favour of LangSmith's `RunTree`
          var _runTree = new langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__.RunTree(_objectSpread(_objectSpread({}, _run2), {}, {
            child_runs: [],
            parent_run: undefined,
            // inherited properties
            client: this.client,
            project_name: this.projectName,
            reference_example_id: this.exampleId,
            tracingEnabled: true
          }));
          runTreeMap[_id2] = _runTree;
          runTreeList.push([_id2, _run2.dotted_order]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      runTreeList.sort(function (a, b) {
        if (!a[1] || !b[1]) return 0;
        return a[1].localeCompare(b[1]);
      });
      for (var _i = 0, _runTreeList = runTreeList; _i < _runTreeList.length; _i++) {
        var _runTreeList$_i = _slicedToArray(_runTreeList[_i], 1),
          _id = _runTreeList$_i[0];
        var run = this.runMap.get(_id);
        var runTree = runTreeMap[_id];
        if (!run || !runTree) continue;
        if (run.parent_run_id) {
          var parentRunTree = runTreeMap[run.parent_run_id];
          if (parentRunTree) {
            parentRunTree.child_runs.push(runTree);
            runTree.parent_run = parentRunTree;
          }
        }
      }
      return runTreeMap[id];
    }
  }], [{
    key: "getTraceableRunTree",
    value: function getTraceableRunTree() {
      try {
        return (0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.getCurrentRunTree)();
      } catch (_unused) {
        return undefined;
      }
    }
  }]);
}(_base_js__WEBPACK_IMPORTED_MODULE_3__.BaseTracer);

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/async_caller.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/async_caller.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)
/* harmony export */ });
/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ "./node_modules/@langchain/core/node_modules/p-retry/index.js");
/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ "./node_modules/@langchain/core/node_modules/p-queue/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var STATUS_NO_RETRY = [400, 401, 402, 403, 404, 405, 406, 407, 409 // Conflict
];
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var defaultFailedAttemptHandler = function defaultFailedAttemptHandler(error) {
  var _error$response$statu, _error$response, _error$error;
  if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") {
    throw error;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((error === null || error === void 0 ? void 0 : error.code) === "ECONNABORTED") {
    throw error;
  }
  var status = // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (_error$response$statu = error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) !== null && _error$response$statu !== void 0 ? _error$response$statu : error === null || error === void 0 ? void 0 : error.status;
  if (status && STATUS_NO_RETRY.includes(+status)) {
    throw error;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((error === null || error === void 0 || (_error$error = error.error) === null || _error$error === void 0 ? void 0 : _error$error.code) === "insufficient_quota") {
    var err = new Error(error === null || error === void 0 ? void 0 : error.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
/**
 * A class that can be used to make async calls with concurrency and retry logic.
 *
 * This is useful for making calls to any kind of "expensive" external resource,
 * be it because it's rate-limited, subject to network issues, etc.
 *
 * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults
 * to `Infinity`. This means that by default, all calls will be made in parallel.
 *
 * Retries are limited by the `maxRetries` parameter, which defaults to 6. This
 * means that by default, each call will be retried up to 6 times, with an
 * exponential backoff between each attempt.
 */
var AsyncCaller = /*#__PURE__*/function () {
  function AsyncCaller(params) {
    var _params$maxConcurrenc, _params$maxRetries, _params$onFailedAttem;
    _classCallCheck(this, AsyncCaller);
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = (_params$maxConcurrenc = params.maxConcurrency) !== null && _params$maxConcurrenc !== void 0 ? _params$maxConcurrenc : Infinity;
    this.maxRetries = (_params$maxRetries = params.maxRetries) !== null && _params$maxRetries !== void 0 ? _params$maxRetries : 6;
    this.onFailedAttempt = (_params$onFailedAttem = params.onFailedAttempt) !== null && _params$onFailedAttem !== void 0 ? _params$onFailedAttem : defaultFailedAttemptHandler;
    var PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__["default"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;
    this.queue = new PQueue({
      concurrency: this.maxConcurrency
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return _createClass(AsyncCaller, [{
    key: "call",
    value: function call(callable) {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return this.queue.add(function () {
        return p_retry__WEBPACK_IMPORTED_MODULE_0__(function () {
          return callable.apply(void 0, args)["catch"](function (error) {
            // eslint-disable-next-line no-instanceof/no-instanceof
            if (error instanceof Error) {
              throw error;
            } else {
              throw new Error(error);
            }
          });
        }, {
          onFailedAttempt: _this.onFailedAttempt,
          retries: _this.maxRetries,
          randomize: true
          // If needed we can change some of the defaults here,
          // but they're quite sensible.
        });
      }, {
        throwOnTimeout: true
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "callWithOptions",
    value: function callWithOptions(options, callable) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      // Note this doesn't cancel the underlying request,
      // when available prefer to use the signal option of the underlying call
      if (options.signal) {
        return Promise.race([this.call.apply(this, [callable].concat(args)), new Promise(function (_, reject) {
          var _options$signal;
          (_options$signal = options.signal) === null || _options$signal === void 0 || _options$signal.addEventListener("abort", function () {
            reject(new Error("AbortError"));
          });
        })]);
      }
      return this.call.apply(this, [callable].concat(args));
    }
  }, {
    key: "fetch",
    value: function (_fetch) {
      function fetch() {
        return _fetch.apply(this, arguments);
      }
      fetch.toString = function () {
        return _fetch.toString();
      };
      return fetch;
    }(function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.call(function () {
        return fetch.apply(void 0, args).then(function (res) {
          return res.ok ? res : Promise.reject(res);
        });
      });
    })
  }]);
}();

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/callbacks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)
/* harmony export */ });
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ "./node_modules/@langchain/core/dist/utils/env.js");

var isTracingEnabled = function isTracingEnabled(tracingEnabled) {
  if (tracingEnabled !== undefined) {
    return tracingEnabled;
  }
  var envVars = ["LANGSMITH_TRACING_V2", "LANGCHAIN_TRACING_V2", "LANGSMITH_TRACING", "LANGCHAIN_TRACING"];
  return !!envVars.find(function (envVar) {
    return (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(envVar) === "true";
  });
};

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/env.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/env.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEnv: () => (/* binding */ getEnv),
/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),
/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isDeno: () => (/* binding */ isDeno),
/* harmony export */   isJsDom: () => (/* binding */ isJsDom),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker)
/* harmony export */ });
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var isBrowser = function isBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
};
var isWebWorker = function isWebWorker() {
  return (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
};
var isJsDom = function isJsDom() {
  return typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
};
// Supabase Edge Function provides a `Deno` global object
// without `version` property
var isDeno = function isDeno() {
  return typeof Deno !== "undefined";
};
// Mark not-as-node if in Supabase Edge Function
var isNode = function isNode() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
};
var getEnv = function getEnv() {
  var env;
  if (isBrowser()) {
    env = "browser";
  } else if (isNode()) {
    env = "node";
  } else if (isWebWorker()) {
    env = "webworker";
  } else if (isJsDom()) {
    env = "jsdom";
  } else if (isDeno()) {
    env = "deno";
  } else {
    env = "other";
  }
  return env;
};
var runtimeEnvironment;
function getRuntimeEnvironment() {
  return _getRuntimeEnvironment.apply(this, arguments);
}
function _getRuntimeEnvironment() {
  _getRuntimeEnvironment = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var env;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (runtimeEnvironment === undefined) {
            env = getEnv();
            runtimeEnvironment = {
              library: "langchain-js",
              runtime: env
            };
          }
          return _context.abrupt("return", runtimeEnvironment);
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getRuntimeEnvironment.apply(this, arguments);
}
function getEnvironmentVariable(name) {
  // Certain Deno setups will throw an error if you try to access environment variables
  // https://github.com/langchain-ai/langchainjs/issues/1412
  try {
    var _process$env;
    return typeof process !== "undefined" ? // eslint-disable-next-line no-process-env
    (_process$env = process.env) === null || _process$env === void 0 ? void 0 : _process$env[name] : undefined;
  } catch (e) {
    return undefined;
  }
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonPatchError: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError),
/* harmony export */   _areEquals: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__._areEquals),
/* harmony export */   applyOperation: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyOperation),
/* harmony export */   applyPatch: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch),
/* harmony export */   applyReducer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyReducer),
/* harmony export */   compare: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.compare),
/* harmony export */   deepClone: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   escapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),
/* harmony export */   generate: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.generate),
/* harmony export */   getValueByPointer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),
/* harmony export */   observe: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.observe),
/* harmony export */   unescapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),
/* harmony export */   unobserve: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.unobserve),
/* harmony export */   validate: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validate),
/* harmony export */   validator: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validator)
/* harmony export */ });
/* harmony import */ var _src_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/core.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js");
/* harmony import */ var _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/duplex.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js");
/* harmony import */ var _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/helpers.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



/**
 * Default export for backwards compat
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_objectSpread(_objectSpread({}, _src_core_js__WEBPACK_IMPORTED_MODULE_0__), {}, {
  // ...duplex,
  JsonPatchError: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError,
  deepClone: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone,
  escapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,
  unescapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent
}));

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonPatchError: () => (/* binding */ JsonPatchError),
/* harmony export */   _areEquals: () => (/* binding */ _areEquals),
/* harmony export */   applyOperation: () => (/* binding */ applyOperation),
/* harmony export */   applyPatch: () => (/* binding */ applyPatch),
/* harmony export */   applyReducer: () => (/* binding */ applyReducer),
/* harmony export */   deepClone: () => (/* binding */ deepClone),
/* harmony export */   getValueByPointer: () => (/* binding */ getValueByPointer),
/* harmony export */   validate: () => (/* binding */ validate),
/* harmony export */   validator: () => (/* binding */ validator)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// @ts-nocheck

var JsonPatchError = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.PatchError;
var deepClone = _helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
  add: function add(obj, key, document) {
    obj[key] = this.value;
    return {
      newDocument: document
    };
  },
  remove: function remove(obj, key, document) {
    var removed = obj[key];
    delete obj[key];
    return {
      newDocument: document,
      removed: removed
    };
  },
  replace: function replace(obj, key, document) {
    var removed = obj[key];
    obj[key] = this.value;
    return {
      newDocument: document,
      removed: removed
    };
  },
  move: function move(obj, key, document) {
    /* in case move target overwrites an existing value,
    return the removed value, this can be taxing performance-wise,
    and is potentially unneeded */
    var removed = getValueByPointer(document, this.path);
    if (removed) {
      removed = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);
    }
    var originalValue = applyOperation(document, {
      op: "remove",
      path: this.from
    }).removed;
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: originalValue
    });
    return {
      newDocument: document,
      removed: removed
    };
  },
  copy: function copy(obj, key, document) {
    var valueToCopy = getValueByPointer(document, this.from);
    // enforce copy by value so further operations don't affect source (see issue #177)
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy)
    });
    return {
      newDocument: document
    };
  },
  test: function test(obj, key, document) {
    return {
      newDocument: document,
      test: _areEquals(obj[key], this.value)
    };
  },
  _get: function _get(obj, key, document) {
    this.value = obj[key];
    return {
      newDocument: document
    };
  }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
  add: function add(arr, i, document) {
    if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {
      arr.splice(i, 0, this.value);
    } else {
      // array props
      arr[i] = this.value;
    }
    // this may be needed when using '-' in an array
    return {
      newDocument: document,
      index: i
    };
  },
  remove: function remove(arr, i, document) {
    var removedList = arr.splice(i, 1);
    return {
      newDocument: document,
      removed: removedList[0]
    };
  },
  replace: function replace(arr, i, document) {
    var removed = arr[i];
    arr[i] = this.value;
    return {
      newDocument: document,
      removed: removed
    };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
  if (pointer == "") {
    return document;
  }
  var getOriginalDestination = {
    op: "_get",
    path: pointer
  };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation) {
  var validateOperation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var mutateDocument = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var banPrototypeModifications = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var index = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  /* ROOT OPERATIONS */
  if (operation.path === "") {
    var returnValue = {
      newDocument: document
    };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document; //document we removed
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      // it's a move or copy to root
      returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
      if (operation.op === "move") {
        // report removed item
        returnValue.removed = document;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
      }
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      // a remove on root
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else {
      /* bad operation */
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
      } else {
        return returnValue;
      }
    }
  } /* END ROOT OPERATIONS */else {
    if (!mutateDocument) {
      document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
    }
    var path = operation.path || "";
    var keys = path.split("/");
    var obj = document;
    var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
    var len = keys.length;
    var existingPathFragment = undefined;
    var key;
    var validateFunction;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);
      }
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === undefined) {
          if (obj[key] === undefined) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== undefined) {
            validateFunction(operation, 0, document, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
          } // only parse key when it's an integer for `arr.prop` to work
          else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
          }
          var _returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
          if (_returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return _returnValue;
        }
      } else {
        if (t >= len) {
          var _returnValue2 = objOps[operation.op].call(operation, obj, key, document); // Apply patch
          if (_returnValue2.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return _returnValue2;
        }
      }
      obj = obj[key];
      // If we have more keys in the path, but the next value isn't a non-null object,
      // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.
      if (validateOperation && t < len && (!obj || _typeof(obj) !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation) {
  var mutateDocument = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var banPrototypeModifications = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
  }
  var results = new Array(patch.length);
  for (var i = 0, length = patch.length; i < length; i++) {
    // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
    results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
    document = results[i].newDocument; // in case root was replaced
  }
  results.newDocument = document;
  return results;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
  var operationResult = applyOperation(document, operation);
  if (operationResult.test === false) {
    // failed test
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
  }
  return operationResult.newDocument;
}
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
  if (_typeof(operation) !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    // paths that aren't empty string should start with "/"
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === undefined) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document);
  } else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: undefined
      };
      var error = validate([existingValue], document);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document) {
      //clone document and sequence so that we can safely try applying operations
      applyPatch((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document, undefined);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
// based on https://github.com/epoberezkin/fast-deep-equal
// MIT License
// Copyright (c) 2017 Evgeny Poberezkin
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
function _areEquals(a, b) {
  if (a === b) return true;
  if (a && b && _typeof(a) == "object" && _typeof(b) == "object") {
    var arrA = Array.isArray(a),
      arrB = Array.isArray(b),
      i,
      length,
      key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;) if (!_areEquals(a[i], b[i])) return false;
      return true;
    }
    if (arrA != arrB) return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0;) if (!b.hasOwnProperty(keys[i])) return false;
    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!_areEquals(a[key], b[key])) return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   generate: () => (/* binding */ generate),
/* harmony export */   observe: () => (/* binding */ observe),
/* harmony export */   unobserve: () => (/* binding */ unobserve)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js");
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
// @ts-nocheck
// Inlined because of ESM import issues
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */


var beforeDict = new WeakMap();
var Mirror = /*#__PURE__*/_createClass(function Mirror(obj) {
  _classCallCheck(this, Mirror);
  Object.defineProperty(this, "obj", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  Object.defineProperty(this, "observers", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map()
  });
  Object.defineProperty(this, "value", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  this.obj = obj;
});
var ObserverInfo = /*#__PURE__*/_createClass(function ObserverInfo(callback, observer) {
  _classCallCheck(this, ObserverInfo);
  Object.defineProperty(this, "callback", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  Object.defineProperty(this, "observer", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
  });
  this.callback = callback;
  this.observer = observer;
});
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers["delete"](observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
  observer.unobserve();
}
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function dirtyCheck() {
      generate(observer);
    };
    var fastCheck = function fastCheck() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      //not Node
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function () {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
/**
 * Generate an array of patches from an observer
 */
function generate(observer) {
  var invertible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);
  var oldKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);
  var changed = false;
  var deleted = false;
  //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key = oldKeys[t];
    var oldVal = mirror[key];
    if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (_typeof(oldVal) == "object" && oldVal != null && _typeof(newVal) == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({
              op: "test",
              path: path + "/" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),
              value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal)
            });
          }
          patches.push({
            op: "replace",
            path: path + "/" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),
            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal)
          });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({
          op: "test",
          path: path + "/" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),
          value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal)
        });
      }
      patches.push({
        op: "remove",
        path: path + "/" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key)
      });
      deleted = true; // property has been deleted
    } else {
      if (invertible) {
        patches.push({
          op: "test",
          path: path,
          value: mirror
        });
      }
      patches.push({
        op: "replace",
        path: path,
        value: obj
      });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key = newKeys[t];
    if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {
      patches.push({
        op: "add",
        path: path + "/" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),
        value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key])
      });
    }
  }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2) {
  var invertible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PatchError: () => (/* binding */ PatchError),
/* harmony export */   _deepClone: () => (/* binding */ _deepClone),
/* harmony export */   _getPathRecursive: () => (/* binding */ _getPathRecursive),
/* harmony export */   _objectKeys: () => (/* binding */ _objectKeys),
/* harmony export */   escapePathComponent: () => (/* binding */ escapePathComponent),
/* harmony export */   getPath: () => (/* binding */ getPath),
/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),
/* harmony export */   hasUndefined: () => (/* binding */ hasUndefined),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   unescapePathComponent: () => (/* binding */ unescapePathComponent)
/* harmony export */ });
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// @ts-nocheck
// Inlined because of ESM import issues
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var _keys = new Array(obj.length);
    for (var k = 0; k < _keys.length; k++) {
      _keys[k] = "" + k;
    }
    return _keys;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
/**
 * Deeply clone the object.
 * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
 * @param  {any} obj value to clone
 * @return {any} cloned obj
 */
function _deepClone(obj) {
  switch (_typeof(obj)) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
    case "undefined":
      return null;
    //this is how JSON.stringify behaves for array items
    default:
      return obj;
    //no need to clone primitives
  }
}
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
/**
 * Escapes a json pointer path
 * @param path The raw pointer
 * @return the Escaped path
 */
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1) return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function _getPathRecursive(root, obj) {
  var found;
  for (var key in root) {
    if (hasOwnProperty(root, key)) {
      if (root[key] === obj) {
        return escapePathComponent(key) + "/";
      } else if (_typeof(root[key]) === "object") {
        found = _getPathRecursive(root[key], obj);
        if (found != "") {
          return escapePathComponent(key) + "/" + found;
        }
      }
    }
  }
  return "";
}
function getPath(root, obj) {
  if (root === obj) {
    return "/";
  }
  var path = _getPathRecursive(root, obj);
  if (path === "") {
    throw new Error("Object not found in root");
  }
  return "/".concat(path);
}
/**
 * Recursively checks whether an object has any undefined values inside.
 */
function hasUndefined(obj) {
  if (obj === undefined) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var _i = 0, len = obj.length; _i < len; _i++) {
        if (hasUndefined(obj[_i])) {
          return true;
        }
      }
    } else if (_typeof(obj) === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key in args) {
    var value = _typeof(args[key]) === "object" ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
    if (typeof value !== "undefined") {
      messageParts.push("".concat(key, ": ").concat(value));
    }
  }
  return messageParts.join("\n");
}
var PatchError = /*#__PURE__*/function (_Error) {
  function PatchError(message, name, index, operation, tree) {
    var _this;
    _classCallCheck(this, PatchError);
    _this = _callSuper(this, PatchError, [patchErrorMessageFormatter(message, {
      name: name,
      index: index,
      operation: operation,
      tree: tree
    })]);
    Object.defineProperty(_this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: name
    });
    Object.defineProperty(_this, "index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: index
    });
    Object.defineProperty(_this, "operation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: operation
    });
    Object.defineProperty(_this, "tree", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tree
    });
    Object.setPrototypeOf(_this, (this instanceof PatchError ? this.constructor : void 0).prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
    _this.message = patchErrorMessageFormatter(message, {
      name: name,
      index: index,
      operation: operation,
      tree: tree
    });
    return _this;
  }
  _inherits(PatchError, _Error);
  return _createClass(PatchError);
}(/*#__PURE__*/_wrapNativeSuper(Error));

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/json.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseJsonMarkdown: () => (/* binding */ parseJsonMarkdown),
/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson)
/* harmony export */ });
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function parseJsonMarkdown(s) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parsePartialJson;
  // eslint-disable-next-line no-param-reassign
  s = s.trim();
  var match = /```(json)?([^]*)```/.exec(s);
  if (!match) {
    return parser(s);
  } else {
    return parser(match[2]);
  }
}
// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py
// MIT License
function parsePartialJson(s) {
  // If the input is undefined, return null to indicate failure.
  if (typeof s === "undefined") {
    return null;
  }
  // Attempt to parse the string as-is.
  try {
    return JSON.parse(s);
  } catch (error) {
    // Pass
  }
  // Initialize variables.
  var new_s = "";
  var stack = [];
  var isInsideString = false;
  var escaped = false;
  // Process each character in the string one at a time.
  var _iterator = _createForOfIteratorHelper(s),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _char = _step.value;
      if (isInsideString) {
        if (_char === '"' && !escaped) {
          isInsideString = false;
        } else if (_char === "\n" && !escaped) {
          _char = "\\n"; // Replace the newline character with the escape sequence.
        } else if (_char === "\\") {
          escaped = !escaped;
        } else {
          escaped = false;
        }
      } else {
        if (_char === '"') {
          isInsideString = true;
          escaped = false;
        } else if (_char === "{") {
          stack.push("}");
        } else if (_char === "[") {
          stack.push("]");
        } else if (_char === "}" || _char === "]") {
          if (stack && stack[stack.length - 1] === _char) {
            stack.pop();
          } else {
            // Mismatched closing character; the input is malformed.
            return null;
          }
        }
      }
      // Append the processed character to the new string.
      new_s += _char;
    }
    // If we're still inside a string at the end of processing,
    // we need to close the string.
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (isInsideString) {
    new_s += '"';
  }
  // Close any remaining open structures in the reverse order that they were opened.
  for (var i = stack.length - 1; i >= 0; i -= 1) {
    new_s += stack[i];
  }
  // Attempt to parse the modified string as JSON.
  try {
    return JSON.parse(new_s);
  } catch (error) {
    // If we still can't parse the string as JSON, return null to indicate failure.
    return null;
  }
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/math.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/math.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),
/* harmony export */   euclideanDistance: () => (/* binding */ euclideanDistance),
/* harmony export */   innerProduct: () => (/* binding */ innerProduct),
/* harmony export */   matrixFunc: () => (/* binding */ matrixFunc),
/* harmony export */   maximalMarginalRelevance: () => (/* binding */ maximalMarginalRelevance),
/* harmony export */   normalize: () => (/* binding */ normalize)
/* harmony export */ });
/* harmony import */ var _ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ml-distance/similarities.js */ "./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js");
/* harmony import */ var _ml_distance_distances_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ml-distance/distances.js */ "./node_modules/@langchain/core/dist/utils/ml-distance/distances.js");
/* harmony import */ var _ml_distance_euclidean_euclidean_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ml-distance-euclidean/euclidean.js */ "./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }



/**
 * Apply a row-wise function between two matrices with the same number of columns.
 *
 * @param {number[][]} X - The first matrix.
 * @param {number[][]} Y - The second matrix.
 * @param {VectorFunction} func - The function to apply.
 *
 * @throws {Error} If the number of columns in X and Y are not the same.
 *
 * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.
 */
function matrixFunc(X, Y, func) {
  if (X.length === 0 || X[0].length === 0 || Y.length === 0 || Y[0].length === 0) {
    return [[]];
  }
  if (X[0].length !== Y[0].length) {
    throw new Error("Number of columns in X and Y must be the same. X has shape ".concat([X.length, X[0].length], " and Y has shape ").concat([Y.length, Y[0].length], "."));
  }
  return X.map(function (xVector) {
    return Y.map(function (yVector) {
      return func(xVector, yVector);
    }).map(function (similarity) {
      return Number.isNaN(similarity) ? 0 : similarity;
    });
  });
}
function normalize(M) {
  var similarity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var max = matrixMaxVal(M);
  return M.map(function (row) {
    return row.map(function (val) {
      return similarity ? 1 - val / max : val / max;
    });
  });
}
/**
 * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.
 *
 * @param {number[][]} X - The first matrix.
 * @param {number[][]} Y - The second matrix.
 *
 * @throws {Error} If the number of columns in X and Y are not the same.
 *
 * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.
 */
function cosineSimilarity(X, Y) {
  return matrixFunc(X, Y, _ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_0__.cosine);
}
function innerProduct(X, Y) {
  return matrixFunc(X, Y, _ml_distance_distances_js__WEBPACK_IMPORTED_MODULE_1__.innerProduct);
}
function euclideanDistance(X, Y) {
  return matrixFunc(X, Y, _ml_distance_euclidean_euclidean_js__WEBPACK_IMPORTED_MODULE_2__.euclidean);
}
/**
 * This function implements the Maximal Marginal Relevance algorithm
 * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.
 *
 * @param {number[]|number[][]} queryEmbedding - The query embedding.
 * @param {number[][]} embeddingList - The list of embeddings to select from.
 * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.
 * @param {number} [k=4] - The maximum number of embeddings to select.
 *
 * @returns {number[]} The indexes of the selected embeddings in the embeddingList.
 */
function maximalMarginalRelevance(queryEmbedding, embeddingList) {
  var lambda = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
  var k = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;
  if (Math.min(k, embeddingList.length) <= 0) {
    return [];
  }
  var queryEmbeddingExpanded = Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding];
  var similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];
  var mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;
  var selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];
  var selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];
  var _loop = function _loop() {
    var bestScore = -Infinity;
    var bestIndex = -1;
    var similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);
    similarityToQuery.forEach(function (queryScore, queryScoreIndex) {
      if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {
        return;
      }
      var maxSimilarityToSelected = Math.max.apply(Math, _toConsumableArray(similarityToSelected[queryScoreIndex]));
      var score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;
      if (score > bestScore) {
        bestScore = score;
        bestIndex = queryScoreIndex;
      }
    });
    selectedEmbeddings.push(embeddingList[bestIndex]);
    selectedEmbeddingsIndexes.push(bestIndex);
  };
  while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {
    _loop();
  }
  return selectedEmbeddingsIndexes;
}
/**
 * Finds the index of the maximum value in the given array.
 * @param {number[]} array - The input array.
 *
 * @returns {number} The index of the maximum value in the array. If the array is empty, returns -1.
 */
function argMax(array) {
  if (array.length === 0) {
    return {
      maxIndex: -1,
      maxValue: NaN
    };
  }
  var maxValue = array[0];
  var maxIndex = 0;
  for (var i = 1; i < array.length; i += 1) {
    if (array[i] > maxValue) {
      maxIndex = i;
      maxValue = array[i];
    }
  }
  return {
    maxIndex: maxIndex,
    maxValue: maxValue
  };
}
function matrixMaxVal(arrays) {
  return arrays.reduce(function (acc, array) {
    return Math.max(acc, argMax(array).maxValue);
  }, 0);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   euclidean: () => (/* binding */ euclidean),
/* harmony export */   squaredEuclidean: () => (/* binding */ squaredEuclidean)
/* harmony export */ });
function squaredEuclidean(p, q) {
  var d = 0;
  for (var i = 0; i < p.length; i++) {
    d += (p[i] - q[i]) * (p[i] - q[i]);
  }
  return d;
}
function euclidean(p, q) {
  return Math.sqrt(squaredEuclidean(p, q));
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/ml-distance/distances.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/ml-distance/distances.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   innerProduct: () => (/* binding */ innerProduct)
/* harmony export */ });
/**
 *Returns the Inner Product similarity between vectors a and b
 * @link [Inner Product Similarity algorithm](https://www.naun.org/main/NAUN/ijmmas/mmmas-49.pdf)
 * @param a - first vector
 * @param b - second vector
 *
 */
function innerProduct(a, b) {
  var ans = 0;
  for (var i = 0; i < a.length; i++) {
    ans += a[i] * b[i];
  }
  return ans;
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cosine: () => (/* binding */ cosine)
/* harmony export */ });
/**
 * Returns the average of cosine distances between vectors a and b
 * @param a - first vector
 * @param b - second vector
 *
 */
function cosine(a, b) {
  var p = 0;
  var p2 = 0;
  var q2 = 0;
  for (var i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (Math.sqrt(p2) * Math.sqrt(q2));
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/signal.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/signal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   raceWithSignal: () => (/* binding */ raceWithSignal)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function raceWithSignal(_x, _x2) {
  return _raceWithSignal.apply(this, arguments);
}
function _raceWithSignal() {
  _raceWithSignal = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(promise, signal) {
    var listener;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(signal === undefined)) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return", promise);
        case 2:
          return _context.abrupt("return", Promise.race([promise["catch"](function (err) {
            if (!(signal !== null && signal !== void 0 && signal.aborted)) {
              throw err;
            } else {
              return undefined;
            }
          }), new Promise(function (_, reject) {
            listener = function listener() {
              reject(new Error("Aborted"));
            };
            signal.addEventListener("abort", listener);
            // Must be here inside the promise to avoid a race condition
            if (signal.aborted) {
              reject(new Error("Aborted"));
            }
          })])["finally"](function () {
            return signal.removeEventListener("abort", listener);
          }));
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _raceWithSignal.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/utils/stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/stream.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncGeneratorWithSetup: () => (/* binding */ AsyncGeneratorWithSetup),
/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream),
/* harmony export */   atee: () => (/* binding */ atee),
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   pipeGeneratorWithSetup: () => (/* binding */ pipeGeneratorWithSetup)
/* harmony export */ });
/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/index.js */ "./node_modules/@langchain/core/dist/singletons/index.js");
/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signal.js */ "./node_modules/@langchain/core/dist/utils/signal.js");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _OverloadYield(e, d) { this.v = e, this.k = d; }


/*
 * Support async iterator syntax for ReadableStreams in all environments.
 * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
 */
var IterableReadableStream = /*#__PURE__*/function (_ReadableStream) {
  function IterableReadableStream() {
    var _this;
    _classCallCheck(this, IterableReadableStream);
    _this = _callSuper(this, IterableReadableStream, arguments);
    Object.defineProperty(_this, "reader", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    return _this;
  }
  _inherits(IterableReadableStream, _ReadableStream);
  return _createClass(IterableReadableStream, [{
    key: "ensureReader",
    value: function ensureReader() {
      if (!this.reader) {
        this.reader = this.getReader();
      }
    }
  }, {
    key: "next",
    value: function () {
      var _next2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.ensureReader();
              _context.prev = 1;
              _context.next = 4;
              return this.reader.read();
            case 4:
              result = _context.sent;
              if (!result.done) {
                _context.next = 10;
                break;
              }
              this.reader.releaseLock(); // release lock when stream becomes closed
              return _context.abrupt("return", {
                done: true,
                value: undefined
              });
            case 10:
              return _context.abrupt("return", {
                done: false,
                value: result.value
              });
            case 11:
              _context.next = 17;
              break;
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](1);
              this.reader.releaseLock(); // release lock when stream becomes errored
              throw _context.t0;
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 13]]);
      }));
      function next() {
        return _next2.apply(this, arguments);
      }
      return next;
    }()
  }, {
    key: "return",
    value: function () {
      var _return2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var cancelPromise;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.ensureReader();
              // If wrapped in a Node stream, cancel is already called.
              if (!this.locked) {
                _context2.next = 6;
                break;
              }
              cancelPromise = this.reader.cancel(); // cancel first, but don't await yet
              this.reader.releaseLock(); // release lock first
              _context2.next = 6;
              return cancelPromise;
            case 6:
              return _context2.abrupt("return", {
                done: true,
                value: undefined
              });
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _return() {
        return _return2.apply(this, arguments);
      }
      return _return;
    }() // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "throw",
    value: function () {
      var _throw2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(e) {
        var cancelPromise;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              this.ensureReader();
              if (!this.locked) {
                _context3.next = 6;
                break;
              }
              cancelPromise = this.reader.cancel(); // cancel first, but don't await yet
              this.reader.releaseLock(); // release lock first
              _context3.next = 6;
              return cancelPromise;
            case 6:
              throw e;
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _throw(_x2) {
        return _throw2.apply(this, arguments);
      }
      return _throw;
    }()
  }, {
    key: Symbol.asyncIterator,
    value: function value() {
      return this;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Not present in Node 18 types, required in latest Node 22
  }, {
    key: Symbol.asyncDispose,
    value: function () {
      var _value = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this["return"]();
            case 2:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function value() {
        return _value.apply(this, arguments);
      }
      return value;
    }()
  }], [{
    key: "fromReadableStream",
    value: function fromReadableStream(stream) {
      // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream
      var reader = stream.getReader();
      return new IterableReadableStream({
        start: function start(controller) {
          return pump();
          function pump() {
            return reader.read().then(function (_ref) {
              var done = _ref.done,
                value = _ref.value;
              // When no more data needs to be consumed, close the stream
              if (done) {
                controller.close();
                return;
              }
              // Enqueue the next data chunk into our target stream
              controller.enqueue(value);
              return pump();
            });
          }
        },
        cancel: function cancel() {
          reader.releaseLock();
        }
      });
    }
  }, {
    key: "fromAsyncGenerator",
    value: function fromAsyncGenerator(generator) {
      return new IterableReadableStream({
        pull: function pull(controller) {
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
            var _yield$generator$next, value, done;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return generator.next();
                case 2:
                  _yield$generator$next = _context5.sent;
                  value = _yield$generator$next.value;
                  done = _yield$generator$next.done;
                  // When no more data needs to be consumed, close the stream
                  if (done) {
                    controller.close();
                  }
                  // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled
                  controller.enqueue(value);
                case 7:
                case "end":
                  return _context5.stop();
              }
            }, _callee5);
          }))();
        },
        cancel: function cancel(reason) {
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return generator["return"](reason);
                case 2:
                case "end":
                  return _context6.stop();
              }
            }, _callee6);
          }))();
        }
      });
    }
  }]);
}(/*#__PURE__*/_wrapNativeSuper(ReadableStream));
function atee(iter) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var buffers = Array.from({
    length: length
  }, function () {
    return [];
  });
  return buffers.map(/*#__PURE__*/function () {
    var _makeIter = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(buffer) {
      var result, _i, _buffers, _buffer;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (false) {}
            if (!(buffer.length === 0)) {
              _context7.next = 8;
              break;
            }
            _context7.next = 4;
            return _awaitAsyncGenerator(iter.next());
          case 4:
            result = _context7.sent;
            for (_i = 0, _buffers = buffers; _i < _buffers.length; _i++) {
              _buffer = _buffers[_i];
              _buffer.push(result);
            }
            _context7.next = 14;
            break;
          case 8:
            if (!buffer[0].done) {
              _context7.next = 12;
              break;
            }
            return _context7.abrupt("return");
          case 12:
            _context7.next = 14;
            return buffer.shift().value;
          case 14:
            _context7.next = 0;
            break;
          case 16:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    function makeIter(_x) {
      return _makeIter.apply(this, arguments);
    }
    return makeIter;
  }());
}
function concat(first, second) {
  if (Array.isArray(first) && Array.isArray(second)) {
    return first.concat(second);
  } else if (typeof first === "string" && typeof second === "string") {
    return first + second;
  } else if (typeof first === "number" && typeof second === "number") {
    return first + second;
  } else if (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "concat" in first &&
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  typeof first.concat === "function") {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return first.concat(second);
  } else if (_typeof(first) === "object" && _typeof(second) === "object") {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var chunk = _objectSpread({}, first);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    for (var _i2 = 0, _Object$entries = Object.entries(second); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
      if (key in chunk && !Array.isArray(chunk[key])) {
        chunk[key] = concat(chunk[key], value);
      } else {
        chunk[key] = value;
      }
    }
    return chunk;
  } else {
    throw new Error("Cannot concat ".concat(_typeof(first), " and ").concat(_typeof(second)));
  }
}
var AsyncGeneratorWithSetup = /*#__PURE__*/function () {
  function AsyncGeneratorWithSetup(params) {
    var _params$signal,
      _this$config,
      _this2 = this;
    _classCallCheck(this, AsyncGeneratorWithSetup);
    Object.defineProperty(this, "generator", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "setup", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signal", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstResult", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstResultUsed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    this.generator = params.generator;
    this.config = params.config;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.signal = (_params$signal = params.signal) !== null && _params$signal !== void 0 ? _params$signal : (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.signal;
    // setup is a promise that resolves only after the first iterator value
    // is available. this is useful when setup of several piped generators
    // needs to happen in logical order, ie. in the order in which input to
    // to each generator is available.
    this.setup = new Promise(function (resolve, reject) {
      void _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(params.config, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _this2.firstResult = params.generator.next();
              if (params.startSetup) {
                _this2.firstResult.then(params.startSetup).then(resolve, reject);
              } else {
                _this2.firstResult.then(function (_result) {
                  return resolve(undefined);
                }, reject);
              }
            case 2:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      })), true);
    });
  }
  return _createClass(AsyncGeneratorWithSetup, [{
    key: "next",
    value: function () {
      var _next3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var _this$signal,
          _this3 = this;
        var _len,
          args,
          _key,
          _args11 = arguments;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              for (_len = _args11.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = _args11[_key];
              }
              (_this$signal = this.signal) === null || _this$signal === void 0 || _this$signal.throwIfAborted();
              if (this.firstResultUsed) {
                _context11.next = 5;
                break;
              }
              this.firstResultUsed = true;
              return _context11.abrupt("return", this.firstResult);
            case 5:
              return _context11.abrupt("return", _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(this.config, this.signal ? /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                var _this3$generator;
                return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                  while (1) switch (_context9.prev = _context9.next) {
                    case 0:
                      return _context9.abrupt("return", (0,_signal_js__WEBPACK_IMPORTED_MODULE_1__.raceWithSignal)((_this3$generator = _this3.generator).next.apply(_this3$generator, args), _this3.signal));
                    case 1:
                    case "end":
                      return _context9.stop();
                  }
                }, _callee9);
              })) : /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                var _this3$generator2;
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) switch (_context10.prev = _context10.next) {
                    case 0:
                      return _context10.abrupt("return", (_this3$generator2 = _this3.generator).next.apply(_this3$generator2, args));
                    case 1:
                    case "end":
                      return _context10.stop();
                  }
                }, _callee10);
              })), true));
            case 6:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function next() {
        return _next3.apply(this, arguments);
      }
      return next;
    }()
  }, {
    key: "return",
    value: function () {
      var _return3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(value) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.abrupt("return", this.generator["return"](value));
            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function _return(_x3) {
        return _return3.apply(this, arguments);
      }
      return _return;
    }()
  }, {
    key: "throw",
    value: function () {
      var _throw3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(e) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.abrupt("return", this.generator["throw"](e));
            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function _throw(_x4) {
        return _throw3.apply(this, arguments);
      }
      return _throw;
    }()
  }, {
    key: Symbol.asyncIterator,
    value: function value() {
      return this;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Not present in Node 18 types, required in latest Node 22
  }, {
    key: Symbol.asyncDispose,
    value: function () {
      var _value2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this["return"]();
            case 2:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function value() {
        return _value2.apply(this, arguments);
      }
      return value;
    }()
  }]);
}();
function pipeGeneratorWithSetup(_x5, _x6, _x7, _x8) {
  return _pipeGeneratorWithSetup.apply(this, arguments);
}
function _pipeGeneratorWithSetup() {
  _pipeGeneratorWithSetup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(to, generator, startSetup, signal) {
    var gen,
      setup,
      _len2,
      args,
      _key2,
      _args15 = arguments;
    return _regeneratorRuntime().wrap(function _callee15$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          gen = new AsyncGeneratorWithSetup({
            generator: generator,
            startSetup: startSetup,
            signal: signal
          });
          _context15.next = 3;
          return gen.setup;
        case 3:
          setup = _context15.sent;
          for (_len2 = _args15.length, args = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
            args[_key2 - 4] = _args15[_key2];
          }
          return _context15.abrupt("return", {
            output: to.apply(void 0, [gen, setup].concat(args)),
            setup: setup
          });
        case 6:
        case "end":
          return _context15.stop();
      }
    }, _callee15);
  }));
  return _pipeGeneratorWithSetup.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@langchain/core/dist/vectorstores.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/vectorstores.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SaveableVectorStore: () => (/* binding */ SaveableVectorStore),
/* harmony export */   VectorStore: () => (/* binding */ VectorStore),
/* harmony export */   VectorStoreRetriever: () => (/* binding */ VectorStoreRetriever)
/* harmony export */ });
/* harmony import */ var _retrievers_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./retrievers/index.js */ "./node_modules/@langchain/core/dist/retrievers/index.js");
/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load/serializable.js */ "./node_modules/@langchain/core/dist/load/serializable.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


/**
 * Class for retrieving documents from a `VectorStore` based on vector similarity
 * or maximal marginal relevance (MMR).
 *
 * `VectorStoreRetriever` extends `BaseRetriever`, implementing methods for
 * adding documents to the underlying vector store and performing document
 * retrieval with optional configurations.
 *
 * @class VectorStoreRetriever
 * @extends BaseRetriever
 * @implements VectorStoreRetrieverInterface
 * @template V - Type of vector store implementing `VectorStoreInterface`.
 */
var VectorStoreRetriever = /*#__PURE__*/function (_BaseRetriever) {
  /**
   * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.
   *
   * This constructor configures the retriever to interact with a given `VectorStore`
   * and supports different retrieval strategies, including similarity search and maximal
   * marginal relevance (MMR) search. Various options allow customization of the number
   * of documents retrieved per query, filtering based on conditions, and fine-tuning
   * MMR-specific parameters.
   *
   * @param fields - Configuration options for setting up the retriever:
   *
   *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`
   *     that will be used to store and retrieve document embeddings. This is the core component
   *     of the retriever, enabling vector-based similarity and MMR searches.
   *
   *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not
   *     provided, defaults to 4. This count determines the number of most relevant documents returned
   *     for each search operation, balancing performance with comprehensiveness.
   *
   *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for
   *     flexibility between two methods:
   *       - `"similarity"` (default): A similarity-based search, retrieving documents with high vector
   *         similarity to the query. This type prioritizes relevance and is often used when diversity
   *         among results is less critical.
   *       - `"mmr"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR
   *         is useful for scenarios where varied content is essential, as it selects results that
   *         both match the query and introduce content diversity.
   *
   *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows
   *     for refined and targeted search results. This filter applies specified conditions to limit
   *     which documents are eligible for retrieval, offering control over the scope of results.
   *
   *   - `searchKwargs` (optional, applicable only if `searchType` is `"mmr"`): Additional settings
   *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR
   *     search process:
   *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR
   *         algorithm is applied. Fetching a larger set enables the algorithm to select a more
   *         diverse subset of documents.
   *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes
   *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,
   *         allowing customization based on the importance of content variety relative to query relevance.
   */
  function VectorStoreRetriever(fields) {
    var _fields$k, _fields$searchType;
    var _this;
    _classCallCheck(this, VectorStoreRetriever);
    _this = _callSuper(this, VectorStoreRetriever, [fields]);
    /**
     * The instance of `VectorStore` used for storing and retrieving document embeddings.
     * This vector store must implement the `VectorStoreInterface` to be compatible
     * with the retrievers operations.
     */
    Object.defineProperty(_this, "vectorStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Specifies the number of documents to retrieve for each search query.
     * Defaults to 4 if not specified, providing a basic result count for similarity or MMR searches.
     */
    Object.defineProperty(_this, "k", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4
    });
    /**
     * Determines the type of search operation to perform on the vector store.
     *
     * - `"similarity"` (default): Conducts a similarity search based purely on vector similarity
     *   to the query.
     * - `"mmr"`: Executes a maximal marginal relevance (MMR) search, balancing relevance and
     *   diversity in the retrieved results.
     */
    Object.defineProperty(_this, "searchType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "similarity"
    });
    /**
     * Additional options specific to maximal marginal relevance (MMR) search, applicable
     * only if `searchType` is set to `"mmr"`.
     *
     * Includes:
     * - `fetchK`: The initial number of documents fetched before applying the MMR algorithm,
     *   allowing for a larger selection from which to choose the most diverse results.
     * - `lambda`: A parameter between 0 and 1 to adjust the relevance-diversity balance,
     *   where 0 prioritizes diversity and 1 prioritizes relevance.
     */
    Object.defineProperty(_this, "searchKwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Optional filter applied to search results, defined by the `FilterType` of the vector store.
     * Allows for refined, targeted results by restricting the returned documents based
     * on specified filter criteria.
     */
    Object.defineProperty(_this, "filter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.vectorStore = fields.vectorStore;
    _this.k = (_fields$k = fields.k) !== null && _fields$k !== void 0 ? _fields$k : _this.k;
    _this.searchType = (_fields$searchType = fields.searchType) !== null && _fields$searchType !== void 0 ? _fields$searchType : _this.searchType;
    _this.filter = fields.filter;
    if (fields.searchType === "mmr") {
      _this.searchKwargs = fields.searchKwargs;
    }
    return _this;
  }
  /**
   * Retrieves relevant documents based on the specified query, using either
   * similarity or maximal marginal relevance (MMR) search.
   *
   * If `searchType` is set to `"mmr"`, performs an MMR search to balance
   * similarity and diversity among results. If `searchType` is `"similarity"`,
   * retrieves results purely based on similarity to the query.
   *
   * @param query - The query string used to find relevant documents.
   * @param runManager - Optional callback manager for tracking retrieval progress.
   * @returns A promise that resolves to an array of `DocumentInterface` instances
   *          representing the most relevant documents to the query.
   * @throws {Error} Throws an error if MMR search is requested but not supported
   *                 by the vector store.
   * @protected
   */
  _inherits(VectorStoreRetriever, _BaseRetriever);
  return _createClass(VectorStoreRetriever, [{
    key: "lc_namespace",
    get: function get() {
      return ["langchain_core", "vectorstores"];
    }
    /**
     * Returns the type of vector store, as defined by the `vectorStore` instance.
     *
     * @returns {string} The vector store type.
     */
  }, {
    key: "_vectorstoreType",
    value: function _vectorstoreType() {
      return this.vectorStore._vectorstoreType();
    }
  }, {
    key: "_getRelevantDocuments",
    value: (function () {
      var _getRelevantDocuments2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(query, runManager) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.searchType === "mmr")) {
                _context.next = 4;
                break;
              }
              if (!(typeof this.vectorStore.maxMarginalRelevanceSearch !== "function")) {
                _context.next = 3;
                break;
              }
              throw new Error("The vector store backing this retriever, ".concat(this._vectorstoreType(), " does not support max marginal relevance search."));
            case 3:
              return _context.abrupt("return", this.vectorStore.maxMarginalRelevanceSearch(query, _objectSpread({
                k: this.k,
                filter: this.filter
              }, this.searchKwargs), runManager === null || runManager === void 0 ? void 0 : runManager.getChild("vectorstore")));
            case 4:
              return _context.abrupt("return", this.vectorStore.similaritySearch(query, this.k, this.filter, runManager === null || runManager === void 0 ? void 0 : runManager.getChild("vectorstore")));
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _getRelevantDocuments(_x, _x2) {
        return _getRelevantDocuments2.apply(this, arguments);
      }
      return _getRelevantDocuments;
    }()
    /**
     * Adds an array of documents to the vector store, embedding them as part of
     * the storage process.
     *
     * This method delegates document embedding and storage to the `addDocuments`
     * method of the underlying vector store.
     *
     * @param documents - An array of documents to embed and add to the vector store.
     * @param options - Optional settings to customize document addition.
     * @returns A promise that resolves to an array of document IDs or `void`,
     *          depending on the vector store's implementation.
     */
    )
  }, {
    key: "addDocuments",
    value: (function () {
      var _addDocuments = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(documents, options) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.vectorStore.addDocuments(documents, options));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function addDocuments(_x3, _x4) {
        return _addDocuments.apply(this, arguments);
      }
      return addDocuments;
    }())
  }], [{
    key: "lc_name",
    value: function lc_name() {
      return "VectorStoreRetriever";
    }
  }]);
}(_retrievers_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseRetriever);
/**
 * Abstract class representing a vector storage system for performing
 * similarity searches on embedded documents.
 *
 * `VectorStore` provides methods for adding precomputed vectors or documents,
 * removing documents based on criteria, and performing similarity searches
 * with optional scoring. Subclasses are responsible for implementing specific
 * storage mechanisms and the exact behavior of certain abstract methods.
 *
 * @abstract
 * @extends Serializable
 * @implements VectorStoreInterface
 */
var VectorStore = /*#__PURE__*/function (_Serializable) {
  /**
   * Initializes a new vector store with embeddings and database configuration.
   *
   * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.
   * @param dbConfig - Configuration settings for the database or storage system.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function VectorStore(embeddings, dbConfig) {
    var _this2;
    _classCallCheck(this, VectorStore);
    _this2 = _callSuper(this, VectorStore, [dbConfig]);
    /**
     * Namespace within LangChain to uniquely identify this vector store's
     * location, based on the vector store type.
     *
     * @internal
     */
    // Only ever instantiated in main LangChain
    Object.defineProperty(_this2, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "vectorstores", _this2._vectorstoreType()]
    });
    /**
     * Embeddings interface for generating vector embeddings from text queries,
     * enabling vector-based similarity searches.
     */
    Object.defineProperty(_this2, "embeddings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this2.embeddings = embeddings;
    return _this2;
  }
  /**
   * Deletes documents from the vector store based on the specified parameters.
   *
   * @param _params - Flexible key-value pairs defining conditions for document deletion.
   * @returns A promise that resolves once the deletion is complete.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _inherits(VectorStore, _Serializable);
  return _createClass(VectorStore, [{
    key: "delete",
    value: (function () {
      var _delete2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_params) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              throw new Error("Not implemented.");
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function _delete(_x5) {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
    /**
     * Searches for documents similar to a text query by embedding the query and
     * performing a similarity search on the resulting vector.
     *
     * @param query - Text query for finding similar documents.
     * @param k - Number of similar results to return. Defaults to 4.
     * @param filter - Optional filter based on `FilterType`.
     * @param _callbacks - Optional callbacks for monitoring search progress
     * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.
     */
    )
  }, {
    key: "similaritySearch",
    value: (function () {
      var _similaritySearch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(query) {
        var k,
          filter,
          _callbacks,
          results,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              k = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 4;
              filter = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : undefined;
              _callbacks = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : undefined;
              _context4.t0 = this;
              _context4.next = 6;
              return this.embeddings.embedQuery(query);
            case 6:
              _context4.t1 = _context4.sent;
              _context4.t2 = k;
              _context4.t3 = filter;
              _context4.next = 11;
              return _context4.t0.similaritySearchVectorWithScore.call(_context4.t0, _context4.t1, _context4.t2, _context4.t3);
            case 11:
              results = _context4.sent;
              return _context4.abrupt("return", results.map(function (result) {
                return result[0];
              }));
            case 13:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function similaritySearch(_x6) {
        return _similaritySearch.apply(this, arguments);
      }
      return similaritySearch;
    }()
    /**
     * Searches for documents similar to a text query by embedding the query,
     * and returns results with similarity scores.
     *
     * @param query - Text query for finding similar documents.
     * @param k - Number of similar results to return. Defaults to 4.
     * @param filter - Optional filter based on `FilterType`.
     * @param _callbacks - Optional callbacks for monitoring search progress
     * @returns A promise resolving to an array of tuples, each containing a
     *          document and its similarity score.
     */
    )
  }, {
    key: "similaritySearchWithScore",
    value: (function () {
      var _similaritySearchWithScore = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(query) {
        var k,
          filter,
          _callbacks,
          _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              k = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 4;
              filter = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : undefined;
              _callbacks = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : undefined;
              _context5.t0 = this;
              _context5.next = 6;
              return this.embeddings.embedQuery(query);
            case 6:
              _context5.t1 = _context5.sent;
              _context5.t2 = k;
              _context5.t3 = filter;
              return _context5.abrupt("return", _context5.t0.similaritySearchVectorWithScore.call(_context5.t0, _context5.t1, _context5.t2, _context5.t3));
            case 10:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function similaritySearchWithScore(_x7) {
        return _similaritySearchWithScore.apply(this, arguments);
      }
      return similaritySearchWithScore;
    }()
    /**
     * Creates a `VectorStore` instance from an array of text strings and optional
     * metadata, using the specified embeddings and database configuration.
     *
     * Subclasses must implement this method to define how text and metadata
     * are embedded and stored in the vector store. Throws an error if not overridden.
     *
     * @param _texts - Array of strings representing the text documents to be stored.
     * @param _metadatas - Metadata for the texts, either as an array (one for each text)
     *                     or a single object (applied to all texts).
     * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.
     * @param _dbConfig - Database configuration settings.
     * @returns A promise that resolves to a new `VectorStore` instance.
     * @throws {Error} Throws an error if this method is not overridden by a subclass.
     */
    )
  }, {
    key: "asRetriever",
    value:
    /**
     * Creates a `VectorStoreRetriever` instance with flexible configuration options.
     *
     * @param kOrFields
     *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).
     *    - If an object is provided, it should contain various configuration options.
     * @param filter
     *    - Optional filter criteria to limit the items retrieved based on the specified filter type.
     * @param callbacks
     *    - Optional callbacks that may be triggered at specific stages of the retrieval process.
     * @param tags
     *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.
     * @param metadata
     *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.
     * @param verbose
     *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.
     *
     * @returns
     *    - A configured `VectorStoreRetriever` instance based on the provided parameters.
     *
     * @example
     * Basic usage with a `k` value:
     * ```typescript
     * const retriever = myVectorStore.asRetriever(5);
     * ```
     *
     * Usage with a configuration object:
     * ```typescript
     * const retriever = myVectorStore.asRetriever({
     *   k: 10,
     *   filter: myFilter,
     *   tags: ['example', 'test'],
     *   verbose: true,
     *   searchType: 'mmr',
     *   searchKwargs: { alpha: 0.5 },
     * });
     * ```
     */
    function asRetriever(kOrFields, filter, callbacks, tags, metadata, verbose) {
      if (typeof kOrFields === "number") {
        return new VectorStoreRetriever({
          vectorStore: this,
          k: kOrFields,
          filter: filter,
          tags: [].concat(_toConsumableArray(tags !== null && tags !== void 0 ? tags : []), [this._vectorstoreType()]),
          metadata: metadata,
          verbose: verbose,
          callbacks: callbacks
        });
      } else {
        var _kOrFields$tags;
        var params = {
          vectorStore: this,
          k: kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.k,
          filter: kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.filter,
          tags: [].concat(_toConsumableArray((_kOrFields$tags = kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.tags) !== null && _kOrFields$tags !== void 0 ? _kOrFields$tags : []), [this._vectorstoreType()]),
          metadata: kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.metadata,
          verbose: kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.verbose,
          callbacks: kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.callbacks,
          searchType: kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.searchType
        };
        if ((kOrFields === null || kOrFields === void 0 ? void 0 : kOrFields.searchType) === "mmr") {
          return new VectorStoreRetriever(_objectSpread(_objectSpread({}, params), {}, {
            searchKwargs: kOrFields.searchKwargs
          }));
        }
        return new VectorStoreRetriever(_objectSpread({}, params));
      }
    }
  }], [{
    key: "fromTexts",
    value: function fromTexts(_texts, _metadatas, _embeddings,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _dbConfig) {
      throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
    }
    /**
     * Creates a `VectorStore` instance from an array of documents, using the specified
     * embeddings and database configuration.
     *
     * Subclasses must implement this method to define how documents are embedded
     * and stored. Throws an error if not overridden.
     *
     * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.
     * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.
     * @param _dbConfig - Database configuration settings.
     * @returns A promise that resolves to a new `VectorStore` instance.
     * @throws {Error} Throws an error if this method is not overridden by a subclass.
     */
  }, {
    key: "fromDocuments",
    value: function fromDocuments(_docs, _embeddings,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _dbConfig) {
      throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
    }
  }]);
}(_load_serializable_js__WEBPACK_IMPORTED_MODULE_1__.Serializable);
/**
 * Abstract class extending `VectorStore` that defines a contract for saving
 * and loading vector store instances.
 *
 * The `SaveableVectorStore` class allows vector store implementations to
 * persist their data and retrieve it when needed.The format for saving and
 * loading data is left to the implementing subclass.
 *
 * Subclasses must implement the `save` method to handle their custom
 * serialization logic, while the `load` method enables reconstruction of a
 * vector store from saved data, requiring compatible embeddings through the
 * `EmbeddingsInterface`.
 *
 * @abstract
 * @extends VectorStore
 */
var SaveableVectorStore = /*#__PURE__*/function (_VectorStore) {
  function SaveableVectorStore() {
    _classCallCheck(this, SaveableVectorStore);
    return _callSuper(this, SaveableVectorStore, arguments);
  }
  _inherits(SaveableVectorStore, _VectorStore);
  return _createClass(SaveableVectorStore, null, [{
    key: "load",
    value:
    /**
     * Loads a vector store instance from the specified directory, using the
     * provided embeddings to ensure compatibility.
     *
     * This static method reconstructs a `SaveableVectorStore` from previously
     * saved data. Implementations should interpret the saved data format to
     * recreate the vector store instance.
     *
     * @param _directory - The directory path from which the vector store
     * data will be loaded.
     * @param _embeddings - An instance of `EmbeddingsInterface` to align
     * the embeddings with the loaded vector data.
     * @returns A promise that resolves to a `SaveableVectorStore` instance
     * constructed from the saved data.
     */
    function load(_directory, _embeddings) {
      throw new Error("Not implemented");
    }
  }]);
}(VectorStore);

/***/ }),

/***/ "./node_modules/@langchain/core/documents.js":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/documents.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseDocumentTransformer),
/* harmony export */   Document: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.Document),
/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.MappingDocumentTransformer)
/* harmony export */ });
/* harmony import */ var _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/documents/index.js */ "./node_modules/@langchain/core/dist/documents/index.js");


/***/ }),

/***/ "./node_modules/@langchain/core/utils/math.js":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/utils/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cosineSimilarity: () => (/* reexport safe */ _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.cosineSimilarity),
/* harmony export */   euclideanDistance: () => (/* reexport safe */ _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.euclideanDistance),
/* harmony export */   innerProduct: () => (/* reexport safe */ _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.innerProduct),
/* harmony export */   matrixFunc: () => (/* reexport safe */ _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.matrixFunc),
/* harmony export */   maximalMarginalRelevance: () => (/* reexport safe */ _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.maximalMarginalRelevance),
/* harmony export */   normalize: () => (/* reexport safe */ _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.normalize)
/* harmony export */ });
/* harmony import */ var _dist_utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/utils/math.js */ "./node_modules/@langchain/core/dist/utils/math.js");


/***/ }),

/***/ "./node_modules/@langchain/core/vectorstores.js":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/vectorstores.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SaveableVectorStore: () => (/* reexport safe */ _dist_vectorstores_js__WEBPACK_IMPORTED_MODULE_0__.SaveableVectorStore),
/* harmony export */   VectorStore: () => (/* reexport safe */ _dist_vectorstores_js__WEBPACK_IMPORTED_MODULE_0__.VectorStore),
/* harmony export */   VectorStoreRetriever: () => (/* reexport safe */ _dist_vectorstores_js__WEBPACK_IMPORTED_MODULE_0__.VectorStoreRetriever)
/* harmony export */ });
/* harmony import */ var _dist_vectorstores_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/vectorstores.js */ "./node_modules/@langchain/core/dist/vectorstores.js");


/***/ }),

/***/ "./node_modules/langchain/dist/util/math.js":
/*!**************************************************!*\
  !*** ./node_modules/langchain/dist/util/math.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cosineSimilarity: () => (/* reexport safe */ _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__.cosineSimilarity),
/* harmony export */   euclideanDistance: () => (/* reexport safe */ _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__.euclideanDistance),
/* harmony export */   innerProduct: () => (/* reexport safe */ _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__.innerProduct),
/* harmony export */   matrixFunc: () => (/* reexport safe */ _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__.matrixFunc),
/* harmony export */   maximalMarginalRelevance: () => (/* reexport safe */ _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__.maximalMarginalRelevance),
/* harmony export */   normalize: () => (/* reexport safe */ _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__.normalize)
/* harmony export */ });
/* harmony import */ var _langchain_core_utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/utils/math */ "./node_modules/@langchain/core/utils/math.js");


/***/ }),

/***/ "./node_modules/langchain/dist/util/ml-distance/similarities.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langchain/dist/util/ml-distance/similarities.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cosine: () => (/* binding */ cosine)
/* harmony export */ });
/**
 * Returns the average of cosine distances between vectors a and b
 * @param a - first vector
 * @param b - second vector
 *
 */
function cosine(a, b) {
  var p = 0;
  var p2 = 0;
  var q2 = 0;
  for (var i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (Math.sqrt(p2) * Math.sqrt(q2));
}

/***/ }),

/***/ "./node_modules/langchain/dist/vectorstores/memory.js":
/*!************************************************************!*\
  !*** ./node_modules/langchain/dist/vectorstores/memory.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MemoryVectorStore: () => (/* binding */ MemoryVectorStore)
/* harmony export */ });
/* harmony import */ var _langchain_core_vectorstores__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/vectorstores */ "./node_modules/@langchain/core/vectorstores.js");
/* harmony import */ var _langchain_core_documents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/documents */ "./node_modules/@langchain/core/documents.js");
/* harmony import */ var _util_ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ml-distance/similarities.js */ "./node_modules/langchain/dist/util/ml-distance/similarities.js");
/* harmony import */ var _util_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/math.js */ "./node_modules/langchain/dist/util/math.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["similarity"];
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }




/**
 * In-memory, ephemeral vector store.
 *
 * Setup:
 * Install `langchain`:
 *
 * ```bash
 * npm install langchain
 * ```
 *
 * ## [Constructor args](https://api.js.langchain.com/classes/langchain.vectorstores_memory.MemoryVectorStore.html#constructor)
 *
 * <details open>
 * <summary><strong>Instantiate</strong></summary>
 *
 * ```typescript
 * import { MemoryVectorStore } from 'langchain/vectorstores/memory';
 * // Or other embeddings
 * import { OpenAIEmbeddings } from '@langchain/openai';
 *
 * const embeddings = new OpenAIEmbeddings({
 *   model: "text-embedding-3-small",
 * });
 *
 * const vectorStore = new MemoryVectorStore(embeddings);
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 * <summary><strong>Add documents</strong></summary>
 *
 * ```typescript
 * import type { Document } from '@langchain/core/documents';
 *
 * const document1 = { pageContent: "foo", metadata: { baz: "bar" } };
 * const document2 = { pageContent: "thud", metadata: { bar: "baz" } };
 * const document3 = { pageContent: "i will be deleted :(", metadata: {} };
 *
 * const documents: Document[] = [document1, document2, document3];
 *
 * await vectorStore.addDocuments(documents);
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 * <summary><strong>Similarity search</strong></summary>
 *
 * ```typescript
 * const results = await vectorStore.similaritySearch("thud", 1);
 * for (const doc of results) {
 *   console.log(`* ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);
 * }
 * // Output: * thud [{"baz":"bar"}]
 * ```
 * </details>
 *
 * <br />
 *
 *
 * <details>
 * <summary><strong>Similarity search with filter</strong></summary>
 *
 * ```typescript
 * const resultsWithFilter = await vectorStore.similaritySearch("thud", 1, { baz: "bar" });
 *
 * for (const doc of resultsWithFilter) {
 *   console.log(`* ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);
 * }
 * // Output: * foo [{"baz":"bar"}]
 * ```
 * </details>
 *
 * <br />
 *
 *
 * <details>
 * <summary><strong>Similarity search with score</strong></summary>
 *
 * ```typescript
 * const resultsWithScore = await vectorStore.similaritySearchWithScore("qux", 1);
 * for (const [doc, score] of resultsWithScore) {
 *   console.log(`* [SIM=${score.toFixed(6)}] ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);
 * }
 * // Output: * [SIM=0.000000] qux [{"bar":"baz","baz":"bar"}]
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 * <summary><strong>As a retriever</strong></summary>
 *
 * ```typescript
 * const retriever = vectorStore.asRetriever({
 *   searchType: "mmr", // Leave blank for standard similarity search
 *   k: 1,
 * });
 * const resultAsRetriever = await retriever.invoke("thud");
 * console.log(resultAsRetriever);
 *
 * // Output: [Document({ metadata: { "baz":"bar" }, pageContent: "thud" })]
 * ```
 * </details>
 *
 * <br />
 */
var MemoryVectorStore = /*#__PURE__*/function (_VectorStore) {
  function MemoryVectorStore(embeddings) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      similarity = _ref.similarity,
      rest = _objectWithoutProperties(_ref, _excluded);
    _classCallCheck(this, MemoryVectorStore);
    _this = _callSuper(this, MemoryVectorStore, [embeddings, rest]);
    Object.defineProperty(_this, "memoryVectors", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(_this, "similarity", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this.similarity = similarity !== null && similarity !== void 0 ? similarity : _util_ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_2__.cosine;
    return _this;
  }
  /**
   * Method to add documents to the memory vector store. It extracts the
   * text from each document, generates embeddings for them, and adds the
   * resulting vectors to the store.
   * @param documents Array of `Document` instances to be added to the store.
   * @returns Promise that resolves when all documents have been added.
   */
  _inherits(MemoryVectorStore, _VectorStore);
  return _createClass(MemoryVectorStore, [{
    key: "_vectorstoreType",
    value: function _vectorstoreType() {
      return "memory";
    }
  }, {
    key: "addDocuments",
    value: (function () {
      var _addDocuments = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(documents) {
        var texts;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              texts = documents.map(function (_ref2) {
                var pageContent = _ref2.pageContent;
                return pageContent;
              });
              _context.t0 = this;
              _context.next = 4;
              return this.embeddings.embedDocuments(texts);
            case 4:
              _context.t1 = _context.sent;
              _context.t2 = documents;
              return _context.abrupt("return", _context.t0.addVectors.call(_context.t0, _context.t1, _context.t2));
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function addDocuments(_x) {
        return _addDocuments.apply(this, arguments);
      }
      return addDocuments;
    }()
    /**
     * Method to add vectors to the memory vector store. It creates
     * `MemoryVector` instances for each vector and document pair and adds
     * them to the store.
     * @param vectors Array of vectors to be added to the store.
     * @param documents Array of `Document` instances corresponding to the vectors.
     * @returns Promise that resolves when all vectors have been added.
     */
    )
  }, {
    key: "addVectors",
    value: (function () {
      var _addVectors = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(vectors, documents) {
        var memoryVectors;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              memoryVectors = vectors.map(function (embedding, idx) {
                return {
                  content: documents[idx].pageContent,
                  embedding: embedding,
                  metadata: documents[idx].metadata,
                  id: documents[idx].id
                };
              });
              this.memoryVectors = this.memoryVectors.concat(memoryVectors);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function addVectors(_x2, _x3) {
        return _addVectors.apply(this, arguments);
      }
      return addVectors;
    }())
  }, {
    key: "_queryVectors",
    value: function () {
      var _queryVectors2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(query, k, filter) {
        var _this2 = this;
        var filterFunction, filteredMemoryVectors;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              filterFunction = function filterFunction(memoryVector) {
                if (!filter) {
                  return true;
                }
                var doc = new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_1__.Document({
                  metadata: memoryVector.metadata,
                  pageContent: memoryVector.content,
                  id: memoryVector.id
                });
                return filter(doc);
              };
              filteredMemoryVectors = this.memoryVectors.filter(filterFunction);
              return _context3.abrupt("return", filteredMemoryVectors.map(function (vector, index) {
                return {
                  similarity: _this2.similarity(query, vector.embedding),
                  index: index,
                  metadata: vector.metadata,
                  content: vector.content,
                  embedding: vector.embedding,
                  id: vector.id
                };
              }).sort(function (a, b) {
                return a.similarity > b.similarity ? -1 : 0;
              }).slice(0, k));
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _queryVectors(_x4, _x5, _x6) {
        return _queryVectors2.apply(this, arguments);
      }
      return _queryVectors;
    }()
    /**
     * Method to perform a similarity search in the memory vector store. It
     * calculates the similarity between the query vector and each vector in
     * the store, sorts the results by similarity, and returns the top `k`
     * results along with their scores.
     * @param query Query vector to compare against the vectors in the store.
     * @param k Number of top results to return.
     * @param filter Optional filter function to apply to the vectors before performing the search.
     * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.
     */
  }, {
    key: "similaritySearchVectorWithScore",
    value: (function () {
      var _similaritySearchVectorWithScore = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(query, k, filter) {
        var searches, result;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this._queryVectors(query, k, filter);
            case 2:
              searches = _context4.sent;
              result = searches.map(function (search) {
                return [new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_1__.Document({
                  metadata: search.metadata,
                  pageContent: search.content,
                  id: search.id
                }), search.similarity];
              });
              return _context4.abrupt("return", result);
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function similaritySearchVectorWithScore(_x7, _x8, _x9) {
        return _similaritySearchVectorWithScore.apply(this, arguments);
      }
      return similaritySearchVectorWithScore;
    }())
  }, {
    key: "maxMarginalRelevanceSearch",
    value: function () {
      var _maxMarginalRelevanceSearch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(query, options) {
        var _options$fetchK;
        var queryEmbedding, searches, embeddingList, mmrIndexes;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.embeddings.embedQuery(query);
            case 2:
              queryEmbedding = _context5.sent;
              _context5.next = 5;
              return this._queryVectors(queryEmbedding, (_options$fetchK = options.fetchK) !== null && _options$fetchK !== void 0 ? _options$fetchK : 20, options.filter);
            case 5:
              searches = _context5.sent;
              embeddingList = searches.map(function (searchResp) {
                return searchResp.embedding;
              });
              mmrIndexes = (0,_util_math_js__WEBPACK_IMPORTED_MODULE_3__.maximalMarginalRelevance)(queryEmbedding, embeddingList, options.lambda, options.k);
              return _context5.abrupt("return", mmrIndexes.map(function (idx) {
                return new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_1__.Document({
                  metadata: searches[idx].metadata,
                  pageContent: searches[idx].content,
                  id: searches[idx].id
                });
              }));
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function maxMarginalRelevanceSearch(_x10, _x11) {
        return _maxMarginalRelevanceSearch.apply(this, arguments);
      }
      return maxMarginalRelevanceSearch;
    }()
    /**
     * Static method to create a `MemoryVectorStore` instance from an array of
     * texts. It creates a `Document` for each text and metadata pair, and
     * adds them to the store.
     * @param texts Array of texts to be added to the store.
     * @param metadatas Array or single object of metadata corresponding to the texts.
     * @param embeddings `Embeddings` instance used to generate embeddings for the texts.
     * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
     * @returns Promise that resolves with a new `MemoryVectorStore` instance.
     */
  }], [{
    key: "fromTexts",
    value: (function () {
      var _fromTexts = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(texts, metadatas, embeddings, dbConfig) {
        var docs, i, metadata, newDoc;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              docs = [];
              for (i = 0; i < texts.length; i += 1) {
                metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
                newDoc = new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_1__.Document({
                  pageContent: texts[i],
                  metadata: metadata
                });
                docs.push(newDoc);
              }
              return _context6.abrupt("return", MemoryVectorStore.fromDocuments(docs, embeddings, dbConfig));
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      function fromTexts(_x12, _x13, _x14, _x15) {
        return _fromTexts.apply(this, arguments);
      }
      return fromTexts;
    }()
    /**
     * Static method to create a `MemoryVectorStore` instance from an array of
     * `Document` instances. It adds the documents to the store.
     * @param docs Array of `Document` instances to be added to the store.
     * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
     * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
     * @returns Promise that resolves with a new `MemoryVectorStore` instance.
     */
    )
  }, {
    key: "fromDocuments",
    value: (function () {
      var _fromDocuments = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(docs, embeddings, dbConfig) {
        var instance;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              instance = new this(embeddings, dbConfig);
              _context7.next = 3;
              return instance.addDocuments(docs);
            case 3:
              return _context7.abrupt("return", instance);
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function fromDocuments(_x16, _x17, _x18) {
        return _fromDocuments.apply(this, arguments);
      }
      return fromDocuments;
    }()
    /**
     * Static method to create a `MemoryVectorStore` instance from an existing
     * index. It creates a new `MemoryVectorStore` instance without adding any
     * documents or vectors.
     * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
     * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
     * @returns Promise that resolves with a new `MemoryVectorStore` instance.
     */
    )
  }, {
    key: "fromExistingIndex",
    value: (function () {
      var _fromExistingIndex = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(embeddings, dbConfig) {
        var instance;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              instance = new this(embeddings, dbConfig);
              return _context8.abrupt("return", instance);
            case 2:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function fromExistingIndex(_x19, _x20) {
        return _fromExistingIndex.apply(this, arguments);
      }
      return fromExistingIndex;
    }())
  }]);
}(_langchain_core_vectorstores__WEBPACK_IMPORTED_MODULE_0__.VectorStore);

/***/ }),

/***/ "./node_modules/langchain/vectorstores/memory.js":
/*!*******************************************************!*\
  !*** ./node_modules/langchain/vectorstores/memory.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MemoryVectorStore: () => (/* reexport safe */ _dist_vectorstores_memory_js__WEBPACK_IMPORTED_MODULE_0__.MemoryVectorStore)
/* harmony export */ });
/* harmony import */ var _dist_vectorstores_memory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/vectorstores/memory.js */ "./node_modules/langchain/dist/vectorstores/memory.js");


/***/ }),

/***/ "./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoBatchQueue: () => (/* binding */ AutoBatchQueue),
/* harmony export */   Client: () => (/* binding */ Client),
/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),
/* harmony export */   mergeRuntimeEnvIntoRunCreate: () => (/* binding */ mergeRuntimeEnvIntoRunCreate)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ "./node_modules/langsmith/dist/utils/async_caller.js");
/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ "./node_modules/langsmith/dist/utils/messages.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ "./node_modules/langsmith/dist/utils/env.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ "./node_modules/langsmith/dist/index.js");
/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/_uuid.js */ "./node_modules/langsmith/dist/utils/_uuid.js");
/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/warn.js */ "./node_modules/langsmith/dist/utils/warn.js");
/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/prompts.js */ "./node_modules/langsmith/dist/utils/prompts.js");
/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/error.js */ "./node_modules/langsmith/dist/utils/error.js");
/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./singletons/fetch.js */ "./node_modules/langsmith/dist/singletons/fetch.js");
/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ "./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js");
var _excluded = ["inputs", "outputs", "events", "attachments"],
  _excluded2 = ["datasetId", "datasetName"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _asyncGeneratorDelegate(t) { var e = {}, n = !1; function pump(e, r) { return n = !0, r = new Promise(function (n) { n(t[e](r)); }), { done: !1, value: new _OverloadYield(r, 1) }; } return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, e.next = function (t) { return n ? (n = !1, t) : pump("next", t); }, "function" == typeof t["throw"] && (e["throw"] = function (t) { if (n) throw n = !1, t; return pump("throw", t); }), "function" == typeof t["return"] && (e["return"] = function (t) { return n ? (n = !1, t) : pump("return", t); }), e; }
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _OverloadYield(e, d) { this.v = e, this.k = d; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(r) { var n = this.s["return"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, "throw": function _throw(r) { var n = this.s["return"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }











function mergeRuntimeEnvIntoRunCreate(run) {
  var _run$extra, _run$revision_id;
  var runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();
  var envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();
  var extra = (_run$extra = run.extra) !== null && _run$extra !== void 0 ? _run$extra : {};
  var metadata = extra.metadata;
  run.extra = _objectSpread(_objectSpread({}, extra), {}, {
    runtime: _objectSpread(_objectSpread({}, runtimeEnv), extra === null || extra === void 0 ? void 0 : extra.runtime),
    metadata: _objectSpread(_objectSpread(_objectSpread({}, envVars), envVars.revision_id || run.revision_id ? {
      revision_id: (_run$revision_id = run.revision_id) !== null && _run$revision_id !== void 0 ? _run$revision_id : envVars.revision_id
    } : {}), metadata)
  });
  return run;
}
var getTracingSamplingRate = function getTracingSamplingRate() {
  var samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)("TRACING_SAMPLING_RATE");
  if (samplingRateStr === undefined) {
    return undefined;
  }
  var samplingRate = parseFloat(samplingRateStr);
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error("LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ".concat(samplingRate));
  }
  return samplingRate;
};
// utility functions
var isLocalhost = function isLocalhost(url) {
  var strippedUrl = url.replace("http://", "").replace("https://", "");
  var hostname = strippedUrl.split("/")[0].split(":")[0];
  return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
};
function toArray(_x) {
  return _toArray.apply(this, arguments);
}
function _toArray() {
  _toArray = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee101(iterable) {
    var result, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;
    return _regeneratorRuntime().wrap(function _callee101$(_context101) {
      while (1) switch (_context101.prev = _context101.next) {
        case 0:
          result = [];
          _iteratorAbruptCompletion = false;
          _didIteratorError = false;
          _context101.prev = 3;
          _iterator = _asyncIterator(iterable);
        case 5:
          _context101.next = 7;
          return _iterator.next();
        case 7:
          if (!(_iteratorAbruptCompletion = !(_step = _context101.sent).done)) {
            _context101.next = 13;
            break;
          }
          item = _step.value;
          result.push(item);
        case 10:
          _iteratorAbruptCompletion = false;
          _context101.next = 5;
          break;
        case 13:
          _context101.next = 19;
          break;
        case 15:
          _context101.prev = 15;
          _context101.t0 = _context101["catch"](3);
          _didIteratorError = true;
          _iteratorError = _context101.t0;
        case 19:
          _context101.prev = 19;
          _context101.prev = 20;
          if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
            _context101.next = 24;
            break;
          }
          _context101.next = 24;
          return _iterator["return"]();
        case 24:
          _context101.prev = 24;
          if (!_didIteratorError) {
            _context101.next = 27;
            break;
          }
          throw _iteratorError;
        case 27:
          return _context101.finish(24);
        case 28:
          return _context101.finish(19);
        case 29:
          return _context101.abrupt("return", result);
        case 30:
        case "end":
          return _context101.stop();
      }
    }, _callee101, null, [[3, 15, 19, 29], [20,, 24, 28]]);
  }));
  return _toArray.apply(this, arguments);
}
function trimQuotes(str) {
  if (str === undefined) {
    return undefined;
  }
  return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
var handle429 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(response) {
    var _response$headers$get, retryAfter;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!((response === null || response === void 0 ? void 0 : response.status) === 429)) {
            _context.next = 6;
            break;
          }
          retryAfter = parseInt((_response$headers$get = response.headers.get("retry-after")) !== null && _response$headers$get !== void 0 ? _response$headers$get : "30", 10) * 1000;
          if (!(retryAfter > 0)) {
            _context.next = 6;
            break;
          }
          _context.next = 5;
          return new Promise(function (resolve) {
            return setTimeout(resolve, retryAfter);
          });
        case 5:
          return _context.abrupt("return", true);
        case 6:
          return _context.abrupt("return", false);
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function handle429(_x2) {
    return _ref.apply(this, arguments);
  };
}();
var AutoBatchQueue = /*#__PURE__*/function () {
  function AutoBatchQueue() {
    _classCallCheck(this, AutoBatchQueue);
    Object.defineProperty(this, "items", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "sizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
  }
  return _createClass(AutoBatchQueue, [{
    key: "peek",
    value: function peek() {
      return this.items[0];
    }
  }, {
    key: "push",
    value: function push(item) {
      var itemPromiseResolve;
      var itemPromise = new Promise(function (resolve) {
        // Setting itemPromiseResolve is synchronous with promise creation:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise
        itemPromiseResolve = resolve;
      });
      var size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(item.item).length;
      this.items.push({
        action: item.action,
        payload: item.item,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        itemPromiseResolve: itemPromiseResolve,
        itemPromise: itemPromise,
        size: size
      });
      this.sizeBytes += size;
      return itemPromise;
    }
  }, {
    key: "pop",
    value: function pop(upToSizeBytes) {
      if (upToSizeBytes < 1) {
        throw new Error("Number of bytes to pop off may not be less than 1.");
      }
      var popped = [];
      var poppedSizeBytes = 0;
      // Pop items until we reach or exceed the size limit
      while (poppedSizeBytes + ((_this$peek$size = (_this$peek = this.peek()) === null || _this$peek === void 0 ? void 0 : _this$peek.size) !== null && _this$peek$size !== void 0 ? _this$peek$size : 0) < upToSizeBytes && this.items.length > 0) {
        var _this$peek$size, _this$peek;
        var item = this.items.shift();
        if (item) {
          popped.push(item);
          poppedSizeBytes += item.size;
          this.sizeBytes -= item.size;
        }
      }
      // If there is an item on the queue we were unable to pop,
      // just return it as a single batch.
      if (popped.length === 0 && this.items.length > 0) {
        var _item = this.items.shift();
        popped.push(_item);
        poppedSizeBytes += _item.size;
        this.sizeBytes -= _item.size;
      }
      return [popped.map(function (it) {
        return {
          action: it.action,
          item: it.payload
        };
      }), function () {
        return popped.forEach(function (it) {
          return it.itemPromiseResolve();
        });
      }];
    }
  }]);
}();
// 20 MB
var DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
var SERVER_INFO_REQUEST_TIMEOUT = 1000;
var Client = /*#__PURE__*/function () {
  function Client() {
    var _trimQuotes, _config$apiUrl, _config$apiKey, _config$webUrl, _this$webUrl, _config$timeout_ms, _config$callerOptions, _config$traceBatchCon, _config$callerOptions2, _ref2, _config$hideInputs, _ref3, _config$hideOutputs, _config$autoBatchTrac, _config$blockOnRootRu;
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Client);
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "batchIngestCaller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "hideInputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hideOutputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingSampleRate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "filteredPostUuids", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Set()
    });
    Object.defineProperty(this, "autoBatchTracing", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "autoBatchQueue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new AutoBatchQueue()
    });
    Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 250
    });
    Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fetchOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "settings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)("LANGSMITH_TRACING_BACKGROUND") === "false"
    });
    Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5
    });
    Object.defineProperty(this, "_serverInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    var defaultConfig = Client.getDefaultClientConfig();
    this.tracingSampleRate = getTracingSamplingRate();
    this.apiUrl = (_trimQuotes = trimQuotes((_config$apiUrl = config.apiUrl) !== null && _config$apiUrl !== void 0 ? _config$apiUrl : defaultConfig.apiUrl)) !== null && _trimQuotes !== void 0 ? _trimQuotes : "";
    if (this.apiUrl.endsWith("/")) {
      this.apiUrl = this.apiUrl.slice(0, -1);
    }
    this.apiKey = trimQuotes((_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : defaultConfig.apiKey);
    this.webUrl = trimQuotes((_config$webUrl = config.webUrl) !== null && _config$webUrl !== void 0 ? _config$webUrl : defaultConfig.webUrl);
    if ((_this$webUrl = this.webUrl) !== null && _this$webUrl !== void 0 && _this$webUrl.endsWith("/")) {
      this.webUrl = this.webUrl.slice(0, -1);
    }
    this.timeout_ms = (_config$timeout_ms = config.timeout_ms) !== null && _config$timeout_ms !== void 0 ? _config$timeout_ms : 90000;
    this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller((_config$callerOptions = config.callerOptions) !== null && _config$callerOptions !== void 0 ? _config$callerOptions : {});
    this.traceBatchConcurrency = (_config$traceBatchCon = config.traceBatchConcurrency) !== null && _config$traceBatchCon !== void 0 ? _config$traceBatchCon : this.traceBatchConcurrency;
    if (this.traceBatchConcurrency < 1) {
      throw new Error("Trace batch concurrency must be positive.");
    }
    this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(_objectSpread(_objectSpread({
      maxRetries: 2,
      maxConcurrency: this.traceBatchConcurrency
    }, (_config$callerOptions2 = config.callerOptions) !== null && _config$callerOptions2 !== void 0 ? _config$callerOptions2 : {}), {}, {
      onFailedResponseHook: handle429
    }));
    this.hideInputs = (_ref2 = (_config$hideInputs = config.hideInputs) !== null && _config$hideInputs !== void 0 ? _config$hideInputs : config.anonymizer) !== null && _ref2 !== void 0 ? _ref2 : defaultConfig.hideInputs;
    this.hideOutputs = (_ref3 = (_config$hideOutputs = config.hideOutputs) !== null && _config$hideOutputs !== void 0 ? _config$hideOutputs : config.anonymizer) !== null && _ref3 !== void 0 ? _ref3 : defaultConfig.hideOutputs;
    this.autoBatchTracing = (_config$autoBatchTrac = config.autoBatchTracing) !== null && _config$autoBatchTrac !== void 0 ? _config$autoBatchTrac : this.autoBatchTracing;
    this.blockOnRootRunFinalization = (_config$blockOnRootRu = config.blockOnRootRunFinalization) !== null && _config$blockOnRootRu !== void 0 ? _config$blockOnRootRu : this.blockOnRootRunFinalization;
    this.batchSizeBytesLimit = config.batchSizeBytesLimit;
    this.fetchOptions = config.fetchOptions || {};
  }
  return _createClass(Client, [{
    key: "getHostUrl",
    value: function getHostUrl() {
      if (this.webUrl) {
        return this.webUrl;
      } else if (isLocalhost(this.apiUrl)) {
        this.webUrl = "http://localhost:3000";
        return this.webUrl;
      } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
        this.webUrl = this.apiUrl.replace("/api", "");
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
        this.webUrl = "https://dev.smith.langchain.com";
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
        this.webUrl = "https://eu.smith.langchain.com";
        return this.webUrl;
      } else {
        this.webUrl = "https://smith.langchain.com";
        return this.webUrl;
      }
    }
  }, {
    key: "headers",
    get: function get() {
      var headers = {
        "User-Agent": "langsmith-js/".concat(_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__)
      };
      if (this.apiKey) {
        headers["x-api-key"] = "".concat(this.apiKey);
      }
      return headers;
    }
  }, {
    key: "processInputs",
    value: function processInputs(inputs) {
      if (this.hideInputs === false) {
        return inputs;
      }
      if (this.hideInputs === true) {
        return {};
      }
      if (typeof this.hideInputs === "function") {
        return this.hideInputs(inputs);
      }
      return inputs;
    }
  }, {
    key: "processOutputs",
    value: function processOutputs(outputs) {
      if (this.hideOutputs === false) {
        return outputs;
      }
      if (this.hideOutputs === true) {
        return {};
      }
      if (typeof this.hideOutputs === "function") {
        return this.hideOutputs(outputs);
      }
      return outputs;
    }
  }, {
    key: "prepareRunCreateOrUpdateInputs",
    value: function prepareRunCreateOrUpdateInputs(run) {
      var runParams = _objectSpread({}, run);
      if (runParams.inputs !== undefined) {
        runParams.inputs = this.processInputs(runParams.inputs);
      }
      if (runParams.outputs !== undefined) {
        runParams.outputs = this.processOutputs(runParams.outputs);
      }
      return runParams;
    }
  }, {
    key: "_getResponse",
    value: function () {
      var _getResponse2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, queryParams) {
        var _queryParams$toString;
        var paramsString, url, response;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              paramsString = (_queryParams$toString = queryParams === null || queryParams === void 0 ? void 0 : queryParams.toString()) !== null && _queryParams$toString !== void 0 ? _queryParams$toString : "";
              url = "".concat(this.apiUrl).concat(path, "?").concat(paramsString);
              _context2.next = 4;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 4:
              response = _context2.sent;
              _context2.next = 7;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "Failed to fetch ".concat(path));
            case 7:
              return _context2.abrupt("return", response);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _getResponse(_x3, _x4) {
        return _getResponse2.apply(this, arguments);
      }
      return _getResponse;
    }()
  }, {
    key: "_get",
    value: function () {
      var _get2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, queryParams) {
        var response;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this._getResponse(path, queryParams);
            case 2:
              response = _context3.sent;
              return _context3.abrupt("return", response.json());
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _get(_x5, _x6) {
        return _get2.apply(this, arguments);
      }
      return _get;
    }()
  }, {
    key: "_getPaginated",
    value: function _getPaginated(path) {
      var _this = this;
      var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();
      var transform = arguments.length > 2 ? arguments[2] : undefined;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var offset, limit, url, response, items;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              offset = Number(queryParams.get("offset")) || 0;
              limit = Number(queryParams.get("limit")) || 100;
            case 2:
              if (false) {}
              queryParams.set("offset", String(offset));
              queryParams.set("limit", String(limit));
              url = "".concat(_this.apiUrl).concat(path, "?").concat(queryParams);
              _context4.next = 8;
              return _awaitAsyncGenerator(_this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, _objectSpread({
                method: "GET",
                headers: _this.headers,
                signal: AbortSignal.timeout(_this.timeout_ms)
              }, _this.fetchOptions)));
            case 8:
              response = _context4.sent;
              _context4.next = 11;
              return _awaitAsyncGenerator((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "Failed to fetch ".concat(path)));
            case 11:
              if (!transform) {
                _context4.next = 19;
                break;
              }
              _context4.t1 = transform;
              _context4.next = 15;
              return _awaitAsyncGenerator(response.json());
            case 15:
              _context4.t2 = _context4.sent;
              _context4.t0 = (0, _context4.t1)(_context4.t2);
              _context4.next = 22;
              break;
            case 19:
              _context4.next = 21;
              return _awaitAsyncGenerator(response.json());
            case 21:
              _context4.t0 = _context4.sent;
            case 22:
              items = _context4.t0;
              if (!(items.length === 0)) {
                _context4.next = 25;
                break;
              }
              return _context4.abrupt("break", 32);
            case 25:
              _context4.next = 27;
              return items;
            case 27:
              if (!(items.length < limit)) {
                _context4.next = 29;
                break;
              }
              return _context4.abrupt("break", 32);
            case 29:
              offset += items.length;
              _context4.next = 2;
              break;
            case 32:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))();
    }
  }, {
    key: "_getCursorPaginatedList",
    value: function _getCursorPaginatedList(path) {
      var _this2 = this;
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var requestMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "POST";
      var dataKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "runs";
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var bodyParams, response, responseBody, cursors;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              bodyParams = body ? _objectSpread({}, body) : {};
            case 1:
              if (false) {}
              _context5.next = 4;
              return _awaitAsyncGenerator(_this2.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(_this2.apiUrl).concat(path), _objectSpread(_objectSpread({
                method: requestMethod,
                headers: _objectSpread(_objectSpread({}, _this2.headers), {}, {
                  "Content-Type": "application/json"
                }),
                signal: AbortSignal.timeout(_this2.timeout_ms)
              }, _this2.fetchOptions), {}, {
                body: JSON.stringify(bodyParams)
              })));
            case 4:
              response = _context5.sent;
              _context5.next = 7;
              return _awaitAsyncGenerator(response.json());
            case 7:
              responseBody = _context5.sent;
              if (responseBody) {
                _context5.next = 10;
                break;
              }
              return _context5.abrupt("break", 22);
            case 10:
              if (responseBody[dataKey]) {
                _context5.next = 12;
                break;
              }
              return _context5.abrupt("break", 22);
            case 12:
              _context5.next = 14;
              return responseBody[dataKey];
            case 14:
              cursors = responseBody.cursors;
              if (cursors) {
                _context5.next = 17;
                break;
              }
              return _context5.abrupt("break", 22);
            case 17:
              if (cursors.next) {
                _context5.next = 19;
                break;
              }
              return _context5.abrupt("break", 22);
            case 19:
              bodyParams.cursor = cursors.next;
              _context5.next = 1;
              break;
            case 22:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }))();
    }
  }, {
    key: "_filterForSampling",
    value: function _filterForSampling(runs) {
      var patch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.tracingSampleRate === undefined) {
        return runs;
      }
      if (patch) {
        var sampled = [];
        var _iterator12 = _createForOfIteratorHelper(runs),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var run = _step12.value;
            if (!this.filteredPostUuids.has(run.id)) {
              sampled.push(run);
            } else {
              this.filteredPostUuids["delete"](run.id);
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        return sampled;
      } else {
        var _sampled = [];
        var _iterator13 = _createForOfIteratorHelper(runs),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _run = _step13.value;
            if (_run.id !== _run.trace_id && !this.filteredPostUuids.has(_run.trace_id) || Math.random() < this.tracingSampleRate) {
              _sampled.push(_run);
            } else {
              this.filteredPostUuids.add(_run.id);
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
        return _sampled;
      }
    }
  }, {
    key: "_getBatchSizeLimitBytes",
    value: function () {
      var _getBatchSizeLimitBytes2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var _ref4, _this$batchSizeBytesL, _serverInfo$batch_ing;
        var serverInfo;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this._ensureServerInfo();
            case 2:
              serverInfo = _context6.sent;
              return _context6.abrupt("return", (_ref4 = (_this$batchSizeBytesL = this.batchSizeBytesLimit) !== null && _this$batchSizeBytesL !== void 0 ? _this$batchSizeBytesL : (_serverInfo$batch_ing = serverInfo.batch_ingest_config) === null || _serverInfo$batch_ing === void 0 ? void 0 : _serverInfo$batch_ing.size_limit_bytes) !== null && _ref4 !== void 0 ? _ref4 : DEFAULT_BATCH_SIZE_LIMIT_BYTES);
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _getBatchSizeLimitBytes() {
        return _getBatchSizeLimitBytes2.apply(this, arguments);
      }
      return _getBatchSizeLimitBytes;
    }()
  }, {
    key: "drainAutoBatchQueue",
    value: function drainAutoBatchQueue(batchSizeLimit) {
      while (this.autoBatchQueue.items.length > 0) {
        var _this$autoBatchQueue$ = this.autoBatchQueue.pop(batchSizeLimit),
          _this$autoBatchQueue$2 = _slicedToArray(_this$autoBatchQueue$, 2),
          batch = _this$autoBatchQueue$2[0],
          done = _this$autoBatchQueue$2[1];
        if (!batch.length) {
          done();
          break;
        }
        void this._processBatch(batch, done)["catch"](console.error);
      }
    }
  }, {
    key: "_processBatch",
    value: function () {
      var _processBatch2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(batch, done) {
        var _serverInfo$batch_ing2, ingestParams, serverInfo;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (batch.length) {
                _context7.next = 3;
                break;
              }
              done();
              return _context7.abrupt("return");
            case 3:
              _context7.prev = 3;
              ingestParams = {
                runCreates: batch.filter(function (item) {
                  return item.action === "create";
                }).map(function (item) {
                  return item.item;
                }),
                runUpdates: batch.filter(function (item) {
                  return item.action === "update";
                }).map(function (item) {
                  return item.item;
                })
              };
              _context7.next = 7;
              return this._ensureServerInfo();
            case 7:
              serverInfo = _context7.sent;
              if (!(serverInfo !== null && serverInfo !== void 0 && (_serverInfo$batch_ing2 = serverInfo.batch_ingest_config) !== null && _serverInfo$batch_ing2 !== void 0 && _serverInfo$batch_ing2.use_multipart_endpoint)) {
                _context7.next = 13;
                break;
              }
              _context7.next = 11;
              return this.multipartIngestRuns(ingestParams);
            case 11:
              _context7.next = 15;
              break;
            case 13:
              _context7.next = 15;
              return this.batchIngestRuns(ingestParams);
            case 15:
              _context7.prev = 15;
              done();
              return _context7.finish(15);
            case 18:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[3,, 15, 18]]);
      }));
      function _processBatch(_x7, _x8) {
        return _processBatch2.apply(this, arguments);
      }
      return _processBatch;
    }()
  }, {
    key: "processRunOperation",
    value: function () {
      var _processRunOperation = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(item) {
        var _this12 = this;
        var itemPromise, sizeLimitBytes;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              clearTimeout(this.autoBatchTimeout);
              this.autoBatchTimeout = undefined;
              if (item.action === "create") {
                item.item = mergeRuntimeEnvIntoRunCreate(item.item);
              }
              itemPromise = this.autoBatchQueue.push(item);
              _context8.next = 6;
              return this._getBatchSizeLimitBytes();
            case 6:
              sizeLimitBytes = _context8.sent;
              if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {
                this.drainAutoBatchQueue(sizeLimitBytes);
              }
              if (this.autoBatchQueue.items.length > 0) {
                this.autoBatchTimeout = setTimeout(function () {
                  _this12.autoBatchTimeout = undefined;
                  _this12.drainAutoBatchQueue(sizeLimitBytes);
                }, this.autoBatchAggregationDelayMs);
              }
              return _context8.abrupt("return", itemPromise);
            case 10:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function processRunOperation(_x9) {
        return _processRunOperation.apply(this, arguments);
      }
      return processRunOperation;
    }()
  }, {
    key: "_getServerInfo",
    value: function () {
      var _getServerInfo2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var response;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)()("".concat(this.apiUrl, "/info"), _objectSpread({
                method: "GET",
                headers: {
                  Accept: "application/json"
                },
                signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT)
              }, this.fetchOptions));
            case 2:
              response = _context9.sent;
              _context9.next = 5;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "get server info");
            case 5:
              return _context9.abrupt("return", response.json());
            case 6:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function _getServerInfo() {
        return _getServerInfo2.apply(this, arguments);
      }
      return _getServerInfo;
    }()
  }, {
    key: "_ensureServerInfo",
    value: function () {
      var _ensureServerInfo2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var _this13 = this;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              if (this._getServerInfoPromise === undefined) {
                this._getServerInfoPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                  var _this13$_serverInfo;
                  return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                    while (1) switch (_context10.prev = _context10.next) {
                      case 0:
                        if (!(_this13._serverInfo === undefined)) {
                          _context10.next = 10;
                          break;
                        }
                        _context10.prev = 1;
                        _context10.next = 4;
                        return _this13._getServerInfo();
                      case 4:
                        _this13._serverInfo = _context10.sent;
                        _context10.next = 10;
                        break;
                      case 7:
                        _context10.prev = 7;
                        _context10.t0 = _context10["catch"](1);
                        console.warn("[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.");
                      case 10:
                        return _context10.abrupt("return", (_this13$_serverInfo = _this13._serverInfo) !== null && _this13$_serverInfo !== void 0 ? _this13$_serverInfo : {});
                      case 11:
                      case "end":
                        return _context10.stop();
                    }
                  }, _callee10, null, [[1, 7]]);
                }))();
              }
              return _context11.abrupt("return", this._getServerInfoPromise.then(function (serverInfo) {
                if (_this13._serverInfo === undefined) {
                  _this13._getServerInfoPromise = undefined;
                }
                return serverInfo;
              }));
            case 2:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function _ensureServerInfo() {
        return _ensureServerInfo2.apply(this, arguments);
      }
      return _ensureServerInfo;
    }()
  }, {
    key: "_getSettings",
    value: function () {
      var _getSettings2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              if (!this.settings) {
                this.settings = this._get("/settings");
              }
              _context12.next = 3;
              return this.settings;
            case 3:
              return _context12.abrupt("return", _context12.sent);
            case 4:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function _getSettings() {
        return _getSettings2.apply(this, arguments);
      }
      return _getSettings;
    }()
  }, {
    key: "createRun",
    value: function () {
      var _createRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(run) {
        var _run$start_time;
        var headers, session_name, runCreate, mergedRunCreateParam, response;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              if (this._filterForSampling([run]).length) {
                _context13.next = 2;
                break;
              }
              return _context13.abrupt("return");
            case 2:
              headers = _objectSpread(_objectSpread({}, this.headers), {}, {
                "Content-Type": "application/json"
              });
              session_name = run.project_name;
              delete run.project_name;
              runCreate = this.prepareRunCreateOrUpdateInputs(_objectSpread(_objectSpread({
                session_name: session_name
              }, run), {}, {
                start_time: (_run$start_time = run.start_time) !== null && _run$start_time !== void 0 ? _run$start_time : Date.now()
              }));
              if (!(this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined)) {
                _context13.next = 9;
                break;
              }
              void this.processRunOperation({
                action: "create",
                item: runCreate
              })["catch"](console.error);
              return _context13.abrupt("return");
            case 9:
              mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);
              _context13.next = 12;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs"), _objectSpread({
                method: "POST",
                headers: headers,
                body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(mergedRunCreateParam),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 12:
              response = _context13.sent;
              _context13.next = 15;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create run", true);
            case 15:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function createRun(_x10) {
        return _createRun.apply(this, arguments);
      }
      return createRun;
    }()
    /**
     * Batch ingest/upsert multiple runs in the Langsmith system.
     * @param runs
     */
  }, {
    key: "batchIngestRuns",
    value: (function () {
      var _batchIngestRuns = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref6) {
        var _runCreates$map,
          _this14 = this,
          _runUpdates$map;
        var runCreates, runUpdates, preparedCreateParams, preparedUpdateParams, createById, standaloneUpdates, _iterator14, _step14, updateParam, rawBatch, batchChunks, _i, _arr, k, key, batchItems, batchItem;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              runCreates = _ref6.runCreates, runUpdates = _ref6.runUpdates;
              if (!(runCreates === undefined && runUpdates === undefined)) {
                _context14.next = 3;
                break;
              }
              return _context14.abrupt("return");
            case 3:
              preparedCreateParams = (_runCreates$map = runCreates === null || runCreates === void 0 ? void 0 : runCreates.map(function (create) {
                return _this14.prepareRunCreateOrUpdateInputs(create);
              })) !== null && _runCreates$map !== void 0 ? _runCreates$map : [];
              preparedUpdateParams = (_runUpdates$map = runUpdates === null || runUpdates === void 0 ? void 0 : runUpdates.map(function (update) {
                return _this14.prepareRunCreateOrUpdateInputs(update);
              })) !== null && _runUpdates$map !== void 0 ? _runUpdates$map : [];
              if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
                createById = preparedCreateParams.reduce(function (params, run) {
                  if (!run.id) {
                    return params;
                  }
                  params[run.id] = run;
                  return params;
                }, {});
                standaloneUpdates = [];
                _iterator14 = _createForOfIteratorHelper(preparedUpdateParams);
                try {
                  for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                    updateParam = _step14.value;
                    if (updateParam.id !== undefined && createById[updateParam.id]) {
                      createById[updateParam.id] = _objectSpread(_objectSpread({}, createById[updateParam.id]), updateParam);
                    } else {
                      standaloneUpdates.push(updateParam);
                    }
                  }
                } catch (err) {
                  _iterator14.e(err);
                } finally {
                  _iterator14.f();
                }
                preparedCreateParams = Object.values(createById);
                preparedUpdateParams = standaloneUpdates;
              }
              rawBatch = {
                post: this._filterForSampling(preparedCreateParams),
                patch: this._filterForSampling(preparedUpdateParams, true)
              };
              if (!(!rawBatch.post.length && !rawBatch.patch.length)) {
                _context14.next = 9;
                break;
              }
              return _context14.abrupt("return");
            case 9:
              batchChunks = {
                post: [],
                patch: []
              };
              for (_i = 0, _arr = ["post", "patch"]; _i < _arr.length; _i++) {
                k = _arr[_i];
                key = k;
                batchItems = rawBatch[key].reverse();
                batchItem = batchItems.pop();
                while (batchItem !== undefined) {
                  batchChunks[key].push(batchItem);
                  batchItem = batchItems.pop();
                }
              }
              if (!(batchChunks.post.length > 0 || batchChunks.patch.length > 0)) {
                _context14.next = 14;
                break;
              }
              _context14.next = 14;
              return this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(batchChunks));
            case 14:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function batchIngestRuns(_x11) {
        return _batchIngestRuns.apply(this, arguments);
      }
      return batchIngestRuns;
    }())
  }, {
    key: "_postBatchIngestRuns",
    value: function () {
      var _postBatchIngestRuns2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(body) {
        var headers, response;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              headers = _objectSpread(_objectSpread({}, this.headers), {}, {
                "Content-Type": "application/json",
                Accept: "application/json"
              });
              _context15.next = 3;
              return this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/batch"), _objectSpread({
                method: "POST",
                headers: headers,
                body: body,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context15.sent;
              _context15.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "batch create run", true);
            case 6:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function _postBatchIngestRuns(_x12) {
        return _postBatchIngestRuns2.apply(this, arguments);
      }
      return _postBatchIngestRuns;
    }()
    /**
     * Batch ingest/upsert multiple runs in the Langsmith system.
     * @param runs
     */
  }, {
    key: "multipartIngestRuns",
    value: (function () {
      var _multipartIngestRuns = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(_ref7) {
        var runCreates, runUpdates, allAttachments, preparedCreateParams, _iterator15, _step15, create, preparedCreate, preparedUpdateParams, _iterator16, _step16, update, invalidRunCreate, invalidRunUpdate, createById, standaloneUpdates, _iterator17, _step17, updateParam, accumulatedContext, accumulatedParts, _i2, _arr2, _arr2$_i, method, payloads, _iterator18, _step18, originalPayload, inputs, outputs, events, attachments, payload, fields, stringifiedPayload, _i3, _Object$entries, _Object$entries$_i, key, value, stringifiedValue, _attachments, _i4, _Object$entries2, _Object$entries2$_i, name, _Object$entries2$_i$, contentType, content;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              runCreates = _ref7.runCreates, runUpdates = _ref7.runUpdates;
              if (!(runCreates === undefined && runUpdates === undefined)) {
                _context16.next = 3;
                break;
              }
              return _context16.abrupt("return");
            case 3:
              // transform and convert to dicts
              allAttachments = {};
              preparedCreateParams = [];
              _iterator15 = _createForOfIteratorHelper(runCreates !== null && runCreates !== void 0 ? runCreates : []);
              try {
                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                  create = _step15.value;
                  preparedCreate = this.prepareRunCreateOrUpdateInputs(create);
                  if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {
                    allAttachments[preparedCreate.id] = preparedCreate.attachments;
                  }
                  delete preparedCreate.attachments;
                  preparedCreateParams.push(preparedCreate);
                }
              } catch (err) {
                _iterator15.e(err);
              } finally {
                _iterator15.f();
              }
              preparedUpdateParams = [];
              _iterator16 = _createForOfIteratorHelper(runUpdates !== null && runUpdates !== void 0 ? runUpdates : []);
              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  update = _step16.value;
                  preparedUpdateParams.push(this.prepareRunCreateOrUpdateInputs(update));
                }
                // require trace_id and dotted_order
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
              invalidRunCreate = preparedCreateParams.find(function (runCreate) {
                return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;
              });
              if (!(invalidRunCreate !== undefined)) {
                _context16.next = 13;
                break;
              }
              throw new Error("Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run");
            case 13:
              invalidRunUpdate = preparedUpdateParams.find(function (runUpdate) {
                return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;
              });
              if (!(invalidRunUpdate !== undefined)) {
                _context16.next = 16;
                break;
              }
              throw new Error("Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run");
            case 16:
              // combine post and patch dicts where possible
              if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
                createById = preparedCreateParams.reduce(function (params, run) {
                  if (!run.id) {
                    return params;
                  }
                  params[run.id] = run;
                  return params;
                }, {});
                standaloneUpdates = [];
                _iterator17 = _createForOfIteratorHelper(preparedUpdateParams);
                try {
                  for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                    updateParam = _step17.value;
                    if (updateParam.id !== undefined && createById[updateParam.id]) {
                      createById[updateParam.id] = _objectSpread(_objectSpread({}, createById[updateParam.id]), updateParam);
                    } else {
                      standaloneUpdates.push(updateParam);
                    }
                  }
                } catch (err) {
                  _iterator17.e(err);
                } finally {
                  _iterator17.f();
                }
                preparedCreateParams = Object.values(createById);
                preparedUpdateParams = standaloneUpdates;
              }
              if (!(preparedCreateParams.length === 0 && preparedUpdateParams.length === 0)) {
                _context16.next = 19;
                break;
              }
              return _context16.abrupt("return");
            case 19:
              // send the runs in multipart requests
              accumulatedContext = [];
              accumulatedParts = [];
              _i2 = 0, _arr2 = [["post", preparedCreateParams], ["patch", preparedUpdateParams]];
            case 22:
              if (!(_i2 < _arr2.length)) {
                _context16.next = 71;
                break;
              }
              _arr2$_i = _slicedToArray(_arr2[_i2], 2), method = _arr2$_i[0], payloads = _arr2$_i[1];
              _iterator18 = _createForOfIteratorHelper(payloads);
              _context16.prev = 25;
              _iterator18.s();
            case 27:
              if ((_step18 = _iterator18.n()).done) {
                _context16.next = 60;
                break;
              }
              originalPayload = _step18.value;
              // collect fields to be sent as separate parts
              inputs = originalPayload.inputs, outputs = originalPayload.outputs, events = originalPayload.events, attachments = originalPayload.attachments, payload = _objectWithoutProperties(originalPayload, _excluded);
              fields = {
                inputs: inputs,
                outputs: outputs,
                events: events
              }; // encode the main run payload
              stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(payload);
              accumulatedParts.push({
                name: "".concat(method, ".").concat(payload.id),
                payload: new Blob([stringifiedPayload], {
                  type: "application/json; length=".concat(stringifiedPayload.length) // encoding=gzip
                })
              });
              // encode the fields we collected
              _i3 = 0, _Object$entries = Object.entries(fields);
            case 34:
              if (!(_i3 < _Object$entries.length)) {
                _context16.next = 43;
                break;
              }
              _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
              if (!(value === undefined)) {
                _context16.next = 38;
                break;
              }
              return _context16.abrupt("continue", 40);
            case 38:
              stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(value);
              accumulatedParts.push({
                name: "".concat(method, ".").concat(payload.id, ".").concat(key),
                payload: new Blob([stringifiedValue], {
                  type: "application/json; length=".concat(stringifiedValue.length)
                })
              });
            case 40:
              _i3++;
              _context16.next = 34;
              break;
            case 43:
              if (!(payload.id !== undefined)) {
                _context16.next = 57;
                break;
              }
              _attachments = allAttachments[payload.id];
              if (!_attachments) {
                _context16.next = 57;
                break;
              }
              delete allAttachments[payload.id];
              _i4 = 0, _Object$entries2 = Object.entries(_attachments);
            case 48:
              if (!(_i4 < _Object$entries2.length)) {
                _context16.next = 57;
                break;
              }
              _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2), name = _Object$entries2$_i[0], _Object$entries2$_i$ = _slicedToArray(_Object$entries2$_i[1], 2), contentType = _Object$entries2$_i$[0], content = _Object$entries2$_i$[1];
              if (!name.includes(".")) {
                _context16.next = 53;
                break;
              }
              console.warn("Skipping attachment '".concat(name, "' for run ").concat(payload.id, ": Invalid attachment name. ") + "Attachment names must not contain periods ('.'). Please rename the attachment and try again.");
              return _context16.abrupt("continue", 54);
            case 53:
              accumulatedParts.push({
                name: "attachment.".concat(payload.id, ".").concat(name),
                payload: new Blob([content], {
                  type: "".concat(contentType, "; length=").concat(content.byteLength)
                })
              });
            case 54:
              _i4++;
              _context16.next = 48;
              break;
            case 57:
              // compute context
              accumulatedContext.push("trace=".concat(payload.trace_id, ",id=").concat(payload.id));
            case 58:
              _context16.next = 27;
              break;
            case 60:
              _context16.next = 65;
              break;
            case 62:
              _context16.prev = 62;
              _context16.t0 = _context16["catch"](25);
              _iterator18.e(_context16.t0);
            case 65:
              _context16.prev = 65;
              _iterator18.f();
              return _context16.finish(65);
            case 68:
              _i2++;
              _context16.next = 22;
              break;
            case 71:
              _context16.next = 73;
              return this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "));
            case 73:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[25, 62, 65, 68]]);
      }));
      function multipartIngestRuns(_x13) {
        return _multipartIngestRuns.apply(this, arguments);
      }
      return multipartIngestRuns;
    }())
  }, {
    key: "_sendMultipartRequest",
    value: function () {
      var _sendMultipartRequest2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(parts, context) {
        var boundary, chunks, _iterator19, _step19, part, body, arrayBuffer, res;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.prev = 0;
              // Create multipart form data manually using Blobs
              boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
              chunks = [];
              _iterator19 = _createForOfIteratorHelper(parts);
              try {
                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                  part = _step19.value;
                  // Add field boundary
                  chunks.push(new Blob(["--".concat(boundary, "\r\n")]));
                  chunks.push(new Blob(["Content-Disposition: form-data; name=\"".concat(part.name, "\"\r\n"), "Content-Type: ".concat(part.payload.type, "\r\n\r\n")]));
                  chunks.push(part.payload);
                  chunks.push(new Blob(["\r\n"]));
                }
                // Add final boundary
              } catch (err) {
                _iterator19.e(err);
              } finally {
                _iterator19.f();
              }
              chunks.push(new Blob(["--".concat(boundary, "--\r\n")]));
              // Combine all chunks into a single Blob
              body = new Blob(chunks); // Convert Blob to ArrayBuffer for compatibility
              _context17.next = 9;
              return body.arrayBuffer();
            case 9:
              arrayBuffer = _context17.sent;
              _context17.next = 12;
              return this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/multipart"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "multipart/form-data; boundary=".concat(boundary)
                }),
                body: arrayBuffer,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 12:
              res = _context17.sent;
              _context17.next = 15;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(res, "ingest multipart runs", true);
            case 15:
              _context17.next = 20;
              break;
            case 17:
              _context17.prev = 17;
              _context17.t0 = _context17["catch"](0);
              console.warn("".concat(_context17.t0.message.trim(), "\n\nContext: ").concat(context));
            case 20:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this, [[0, 17]]);
      }));
      function _sendMultipartRequest(_x14, _x15) {
        return _sendMultipartRequest2.apply(this, arguments);
      }
      return _sendMultipartRequest;
    }()
  }, {
    key: "updateRun",
    value: function () {
      var _updateRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(runId, run) {
        var data, headers, response;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);
              if (run.inputs) {
                run.inputs = this.processInputs(run.inputs);
              }
              if (run.outputs) {
                run.outputs = this.processOutputs(run.outputs);
              }
              // TODO: Untangle types
              data = _objectSpread(_objectSpread({}, run), {}, {
                id: runId
              });
              if (this._filterForSampling([data], true).length) {
                _context18.next = 6;
                break;
              }
              return _context18.abrupt("return");
            case 6:
              if (!(this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined)) {
                _context18.next = 15;
                break;
              }
              if (!(run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization)) {
                _context18.next = 13;
                break;
              }
              _context18.next = 10;
              return this.processRunOperation({
                action: "update",
                item: data
              })["catch"](console.error);
            case 10:
              return _context18.abrupt("return");
            case 13:
              void this.processRunOperation({
                action: "update",
                item: data
              })["catch"](console.error);
            case 14:
              return _context18.abrupt("return");
            case 15:
              headers = _objectSpread(_objectSpread({}, this.headers), {}, {
                "Content-Type": "application/json"
              });
              _context18.next = 18;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/").concat(runId), _objectSpread({
                method: "PATCH",
                headers: headers,
                body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(run),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 18:
              response = _context18.sent;
              _context18.next = 21;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update run", true);
            case 21:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function updateRun(_x16, _x17) {
        return _updateRun.apply(this, arguments);
      }
      return updateRun;
    }()
  }, {
    key: "readRun",
    value: function () {
      var _readRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(runId) {
        var _ref8,
          loadChildRuns,
          run,
          _args19 = arguments;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _ref8 = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {
                loadChildRuns: false
              }, loadChildRuns = _ref8.loadChildRuns;
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);
              _context19.next = 4;
              return this._get("/runs/".concat(runId));
            case 4:
              run = _context19.sent;
              if (!(loadChildRuns && run.child_run_ids)) {
                _context19.next = 9;
                break;
              }
              _context19.next = 8;
              return this._loadChildRuns(run);
            case 8:
              run = _context19.sent;
            case 9:
              return _context19.abrupt("return", run);
            case 10:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function readRun(_x18) {
        return _readRun.apply(this, arguments);
      }
      return readRun;
    }()
  }, {
    key: "getRunUrl",
    value: function () {
      var _getRunUrl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref9) {
        var runId, run, projectOpts, sessionId, project, tenantId, run_, baseUrl;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              runId = _ref9.runId, run = _ref9.run, projectOpts = _ref9.projectOpts;
              if (!(run !== undefined)) {
                _context20.next = 26;
                break;
              }
              if (!run.session_id) {
                _context20.next = 6;
                break;
              }
              sessionId = run.session_id;
              _context20.next = 20;
              break;
            case 6:
              if (!(projectOpts !== null && projectOpts !== void 0 && projectOpts.projectName)) {
                _context20.next = 12;
                break;
              }
              _context20.next = 9;
              return this.readProject({
                projectName: projectOpts === null || projectOpts === void 0 ? void 0 : projectOpts.projectName
              });
            case 9:
              sessionId = _context20.sent.id;
              _context20.next = 20;
              break;
            case 12:
              if (!(projectOpts !== null && projectOpts !== void 0 && projectOpts.projectId)) {
                _context20.next = 16;
                break;
              }
              sessionId = projectOpts === null || projectOpts === void 0 ? void 0 : projectOpts.projectId;
              _context20.next = 20;
              break;
            case 16:
              _context20.next = 18;
              return this.readProject({
                projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)("PROJECT") || "default"
              });
            case 18:
              project = _context20.sent;
              sessionId = project.id;
            case 20:
              _context20.next = 22;
              return this._getTenantId();
            case 22:
              tenantId = _context20.sent;
              return _context20.abrupt("return", "".concat(this.getHostUrl(), "/o/").concat(tenantId, "/projects/p/").concat(sessionId, "/r/").concat(run.id, "?poll=true"));
            case 26:
              if (!(runId !== undefined)) {
                _context20.next = 36;
                break;
              }
              _context20.next = 29;
              return this.readRun(runId);
            case 29:
              run_ = _context20.sent;
              if (run_.app_path) {
                _context20.next = 32;
                break;
              }
              throw new Error("Run ".concat(runId, " has no app_path"));
            case 32:
              baseUrl = this.getHostUrl();
              return _context20.abrupt("return", "".concat(baseUrl).concat(run_.app_path));
            case 36:
              throw new Error("Must provide either runId or run");
            case 37:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function getRunUrl(_x19) {
        return _getRunUrl.apply(this, arguments);
      }
      return getRunUrl;
    }()
  }, {
    key: "_loadChildRuns",
    value: function () {
      var _loadChildRuns2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(run) {
        var childRuns, treemap, runs, _iterator20, _step20, childRun, runId;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return toArray(this.listRuns({
                id: run.child_run_ids
              }));
            case 2:
              childRuns = _context21.sent;
              treemap = {};
              runs = {}; // TODO: make dotted order required when the migration finishes
              childRuns.sort(function (a, b) {
                var _a$dotted_order, _b$dotted_order;
                return ((_a$dotted_order = a === null || a === void 0 ? void 0 : a.dotted_order) !== null && _a$dotted_order !== void 0 ? _a$dotted_order : "").localeCompare((_b$dotted_order = b === null || b === void 0 ? void 0 : b.dotted_order) !== null && _b$dotted_order !== void 0 ? _b$dotted_order : "");
              });
              _iterator20 = _createForOfIteratorHelper(childRuns);
              _context21.prev = 7;
              _iterator20.s();
            case 9:
              if ((_step20 = _iterator20.n()).done) {
                _context21.next = 18;
                break;
              }
              childRun = _step20.value;
              if (!(childRun.parent_run_id === null || childRun.parent_run_id === undefined)) {
                _context21.next = 13;
                break;
              }
              throw new Error("Child run ".concat(childRun.id, " has no parent"));
            case 13:
              if (!(childRun.parent_run_id in treemap)) {
                treemap[childRun.parent_run_id] = [];
              }
              treemap[childRun.parent_run_id].push(childRun);
              runs[childRun.id] = childRun;
            case 16:
              _context21.next = 9;
              break;
            case 18:
              _context21.next = 23;
              break;
            case 20:
              _context21.prev = 20;
              _context21.t0 = _context21["catch"](7);
              _iterator20.e(_context21.t0);
            case 23:
              _context21.prev = 23;
              _iterator20.f();
              return _context21.finish(23);
            case 26:
              run.child_runs = treemap[run.id] || [];
              for (runId in treemap) {
                if (runId !== run.id) {
                  runs[runId].child_runs = treemap[runId];
                }
              }
              return _context21.abrupt("return", run);
            case 29:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this, [[7, 20, 23, 26]]);
      }));
      function _loadChildRuns(_x20) {
        return _loadChildRuns2.apply(this, arguments);
      }
      return _loadChildRuns;
    }()
    /**
     * List runs from the LangSmith server.
     * @param projectId - The ID of the project to filter by.
     * @param projectName - The name of the project to filter by.
     * @param parentRunId - The ID of the parent run to filter by.
     * @param traceId - The ID of the trace to filter by.
     * @param referenceExampleId - The ID of the reference example to filter by.
     * @param startTime - The start time to filter by.
     * @param isRoot - Indicates whether to only return root runs.
     * @param runType - The run type to filter by.
     * @param error - Indicates whether to filter by error runs.
     * @param id - The ID of the run to filter by.
     * @param query - The query string to filter by.
     * @param filter - The filter string to apply to the run spans.
     * @param traceFilter - The filter string to apply on the root run of the trace.
     * @param limit - The maximum number of runs to retrieve.
     * @returns {AsyncIterable<Run>} - The runs.
     *
     * @example
     * // List all runs in a project
     * const projectRuns = client.listRuns({ projectName: "<your_project>" });
     *
     * @example
     * // List LLM and Chat runs in the last 24 hours
     * const todaysLLMRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
     *   run_type: "llm",
     * });
     *
     * @example
     * // List traces in a project
     * const rootRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   execution_order: 1,
     * });
     *
     * @example
     * // List runs without errors
     * const correctRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   error: false,
     * });
     *
     * @example
     * // List runs by run ID
     * const runIds = [
     *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
     *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
     * ];
     * const selectedRuns = client.listRuns({ run_ids: runIds });
     *
     * @example
     * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
     * const chainRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
     * });
     *
     * @example
     * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
     * const goodExtractorRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'eq(name, "extractor")',
     *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
     * });
     *
     * @example
     * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
     * const complexRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
     * });
     *
     * @example
     * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
     * const taggedRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
     * });
     */
  }, {
    key: "listRuns",
    value: function listRuns(props) {
      var _this3 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        var projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, projectIds, _projectIds, projectNames, projectIds_, default_select, body, runsYielded, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, runs, newRuns;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              projectId = props.projectId, projectName = props.projectName, parentRunId = props.parentRunId, traceId = props.traceId, referenceExampleId = props.referenceExampleId, startTime = props.startTime, executionOrder = props.executionOrder, isRoot = props.isRoot, runType = props.runType, error = props.error, id = props.id, query = props.query, filter = props.filter, traceFilter = props.traceFilter, treeFilter = props.treeFilter, limit = props.limit, select = props.select;
              projectIds = [];
              if (projectId) {
                projectIds = Array.isArray(projectId) ? projectId : [projectId];
              }
              if (!projectName) {
                _context22.next = 9;
                break;
              }
              projectNames = Array.isArray(projectName) ? projectName : [projectName];
              _context22.next = 7;
              return _awaitAsyncGenerator(Promise.all(projectNames.map(function (name) {
                return _this3.readProject({
                  projectName: name
                }).then(function (project) {
                  return project.id;
                });
              })));
            case 7:
              projectIds_ = _context22.sent;
              (_projectIds = projectIds).push.apply(_projectIds, _toConsumableArray(projectIds_));
            case 9:
              default_select = ["app_path", "child_run_ids", "completion_cost", "completion_tokens", "dotted_order", "end_time", "error", "events", "extra", "feedback_stats", "first_token_time", "id", "inputs", "name", "outputs", "parent_run_id", "parent_run_ids", "prompt_cost", "prompt_tokens", "reference_example_id", "run_type", "session_id", "start_time", "status", "tags", "total_cost", "total_tokens", "trace_id"];
              body = {
                session: projectIds.length ? projectIds : null,
                run_type: runType,
                reference_example: referenceExampleId,
                query: query,
                filter: filter,
                trace_filter: traceFilter,
                tree_filter: treeFilter,
                execution_order: executionOrder,
                parent_run: parentRunId,
                start_time: startTime ? startTime.toISOString() : null,
                error: error,
                id: id,
                limit: limit,
                trace: traceId,
                select: select ? select : default_select,
                is_root: isRoot
              };
              runsYielded = 0;
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context22.prev = 14;
              _iterator2 = _asyncIterator(_this3._getCursorPaginatedList("/runs/query", body));
            case 16:
              _context22.next = 18;
              return _awaitAsyncGenerator(_iterator2.next());
            case 18:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context22.sent).done)) {
                _context22.next = 35;
                break;
              }
              runs = _step2.value;
              if (!limit) {
                _context22.next = 31;
                break;
              }
              if (!(runsYielded >= limit)) {
                _context22.next = 23;
                break;
              }
              return _context22.abrupt("break", 35);
            case 23:
              if (!(runs.length + runsYielded > limit)) {
                _context22.next = 27;
                break;
              }
              newRuns = runs.slice(0, limit - runsYielded);
              return _context22.delegateYield(_asyncGeneratorDelegate(_asyncIterator(newRuns), _awaitAsyncGenerator), "t0", 26);
            case 26:
              return _context22.abrupt("break", 35);
            case 27:
              runsYielded += runs.length;
              return _context22.delegateYield(_asyncGeneratorDelegate(_asyncIterator(runs), _awaitAsyncGenerator), "t1", 29);
            case 29:
              _context22.next = 32;
              break;
            case 31:
              return _context22.delegateYield(_asyncGeneratorDelegate(_asyncIterator(runs), _awaitAsyncGenerator), "t2", 32);
            case 32:
              _iteratorAbruptCompletion2 = false;
              _context22.next = 16;
              break;
            case 35:
              _context22.next = 41;
              break;
            case 37:
              _context22.prev = 37;
              _context22.t3 = _context22["catch"](14);
              _didIteratorError2 = true;
              _iteratorError2 = _context22.t3;
            case 41:
              _context22.prev = 41;
              _context22.prev = 42;
              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context22.next = 46;
                break;
              }
              _context22.next = 46;
              return _awaitAsyncGenerator(_iterator2["return"]());
            case 46:
              _context22.prev = 46;
              if (!_didIteratorError2) {
                _context22.next = 49;
                break;
              }
              throw _iteratorError2;
            case 49:
              return _context22.finish(46);
            case 50:
              return _context22.finish(41);
            case 51:
            case "end":
              return _context22.stop();
          }
        }, _callee22, null, [[14, 37, 41, 51], [42,, 46, 50]]);
      }))();
    }
  }, {
    key: "getRunStats",
    value: function () {
      var _getRunStats = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(_ref10) {
        var _this15 = this;
        var id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, projectIds_, payload, filteredPayload, response, result;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              id = _ref10.id, trace = _ref10.trace, parentRun = _ref10.parentRun, runType = _ref10.runType, projectNames = _ref10.projectNames, projectIds = _ref10.projectIds, referenceExampleIds = _ref10.referenceExampleIds, startTime = _ref10.startTime, endTime = _ref10.endTime, error = _ref10.error, query = _ref10.query, filter = _ref10.filter, traceFilter = _ref10.traceFilter, treeFilter = _ref10.treeFilter, isRoot = _ref10.isRoot, dataSourceType = _ref10.dataSourceType;
              projectIds_ = projectIds || [];
              if (!projectNames) {
                _context23.next = 11;
                break;
              }
              _context23.t0 = [];
              _context23.t1 = _toConsumableArray(projectIds || []);
              _context23.t2 = _toConsumableArray;
              _context23.next = 8;
              return Promise.all(projectNames.map(function (name) {
                return _this15.readProject({
                  projectName: name
                }).then(function (project) {
                  return project.id;
                });
              }));
            case 8:
              _context23.t3 = _context23.sent;
              _context23.t4 = (0, _context23.t2)(_context23.t3);
              projectIds_ = _context23.t0.concat.call(_context23.t0, _context23.t1, _context23.t4);
            case 11:
              payload = {
                id: id,
                trace: trace,
                parent_run: parentRun,
                run_type: runType,
                session: projectIds_,
                reference_example: referenceExampleIds,
                start_time: startTime,
                end_time: endTime,
                error: error,
                query: query,
                filter: filter,
                trace_filter: traceFilter,
                tree_filter: treeFilter,
                is_root: isRoot,
                data_source_type: dataSourceType
              }; // Remove undefined values from the payload
              filteredPayload = Object.fromEntries(Object.entries(payload).filter(function (_ref11) {
                var _ref12 = _slicedToArray(_ref11, 2),
                  _ = _ref12[0],
                  value = _ref12[1];
                return value !== undefined;
              }));
              _context23.next = 15;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/stats"), _objectSpread({
                method: "POST",
                headers: this.headers,
                body: JSON.stringify(filteredPayload),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 15:
              response = _context23.sent;
              _context23.next = 18;
              return response.json();
            case 18:
              result = _context23.sent;
              return _context23.abrupt("return", result);
            case 20:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function getRunStats(_x21) {
        return _getRunStats.apply(this, arguments);
      }
      return getRunStats;
    }()
  }, {
    key: "shareRun",
    value: function () {
      var _shareRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(runId) {
        var _ref13,
          shareId,
          data,
          response,
          result,
          _args24 = arguments;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _ref13 = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {}, shareId = _ref13.shareId;
              data = {
                run_id: runId,
                share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_10__["default"]()
              };
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);
              _context24.next = 5;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/").concat(runId, "/share"), _objectSpread({
                method: "PUT",
                headers: this.headers,
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 5:
              response = _context24.sent;
              _context24.next = 8;
              return response.json();
            case 8:
              result = _context24.sent;
              if (!(result === null || !("share_token" in result))) {
                _context24.next = 11;
                break;
              }
              throw new Error("Invalid response from server");
            case 11:
              return _context24.abrupt("return", "".concat(this.getHostUrl(), "/public/").concat(result["share_token"], "/r"));
            case 12:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function shareRun(_x22) {
        return _shareRun.apply(this, arguments);
      }
      return shareRun;
    }()
  }, {
    key: "unshareRun",
    value: function () {
      var _unshareRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(runId) {
        var response;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);
              _context25.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/").concat(runId, "/share"), _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context25.sent;
              _context25.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "unshare run", true);
            case 6:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function unshareRun(_x23) {
        return _unshareRun.apply(this, arguments);
      }
      return unshareRun;
    }()
  }, {
    key: "readRunSharedLink",
    value: function () {
      var _readRunSharedLink = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(runId) {
        var response, result;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);
              _context26.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/runs/").concat(runId, "/share"), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context26.sent;
              _context26.next = 6;
              return response.json();
            case 6:
              result = _context26.sent;
              if (!(result === null || !("share_token" in result))) {
                _context26.next = 9;
                break;
              }
              return _context26.abrupt("return", undefined);
            case 9:
              return _context26.abrupt("return", "".concat(this.getHostUrl(), "/public/").concat(result["share_token"], "/r"));
            case 10:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function readRunSharedLink(_x24) {
        return _readRunSharedLink.apply(this, arguments);
      }
      return readRunSharedLink;
    }()
  }, {
    key: "listSharedRuns",
    value: function () {
      var _listSharedRuns = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(shareToken) {
        var _ref14,
          runIds,
          queryParams,
          _iterator21,
          _step21,
          runId,
          response,
          runs,
          _args27 = arguments;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _ref14 = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : {}, runIds = _ref14.runIds;
              queryParams = new URLSearchParams({
                share_token: shareToken
              });
              if (runIds !== undefined) {
                _iterator21 = _createForOfIteratorHelper(runIds);
                try {
                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                    runId = _step21.value;
                    queryParams.append("id", runId);
                  }
                } catch (err) {
                  _iterator21.e(err);
                } finally {
                  _iterator21.f();
                }
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);
              _context27.next = 6;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/public/").concat(shareToken, "/runs").concat(queryParams), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 6:
              response = _context27.sent;
              _context27.next = 9;
              return response.json();
            case 9:
              runs = _context27.sent;
              return _context27.abrupt("return", runs);
            case 11:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function listSharedRuns(_x25) {
        return _listSharedRuns.apply(this, arguments);
      }
      return listSharedRuns;
    }()
  }, {
    key: "readDatasetSharedSchema",
    value: function () {
      var _readDatasetSharedSchema = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(datasetId, datasetName) {
        var dataset, response, shareSchema;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              if (!(!datasetId && !datasetName)) {
                _context28.next = 2;
                break;
              }
              throw new Error("Either datasetId or datasetName must be given");
            case 2:
              if (datasetId) {
                _context28.next = 7;
                break;
              }
              _context28.next = 5;
              return this.readDataset({
                datasetName: datasetName
              });
            case 5:
              dataset = _context28.sent;
              datasetId = dataset.id;
            case 7:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);
              _context28.next = 10;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(datasetId, "/share"), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 10:
              response = _context28.sent;
              _context28.next = 13;
              return response.json();
            case 13:
              shareSchema = _context28.sent;
              shareSchema.url = "".concat(this.getHostUrl(), "/public/").concat(shareSchema.share_token, "/d");
              return _context28.abrupt("return", shareSchema);
            case 16:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function readDatasetSharedSchema(_x26, _x27) {
        return _readDatasetSharedSchema.apply(this, arguments);
      }
      return readDatasetSharedSchema;
    }()
  }, {
    key: "shareDataset",
    value: function () {
      var _shareDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(datasetId, datasetName) {
        var dataset, data, response, shareSchema;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              if (!(!datasetId && !datasetName)) {
                _context29.next = 2;
                break;
              }
              throw new Error("Either datasetId or datasetName must be given");
            case 2:
              if (datasetId) {
                _context29.next = 7;
                break;
              }
              _context29.next = 5;
              return this.readDataset({
                datasetName: datasetName
              });
            case 5:
              dataset = _context29.sent;
              datasetId = dataset.id;
            case 7:
              data = {
                dataset_id: datasetId
              };
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);
              _context29.next = 11;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(datasetId, "/share"), _objectSpread({
                method: "PUT",
                headers: this.headers,
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 11:
              response = _context29.sent;
              _context29.next = 14;
              return response.json();
            case 14:
              shareSchema = _context29.sent;
              shareSchema.url = "".concat(this.getHostUrl(), "/public/").concat(shareSchema.share_token, "/d");
              return _context29.abrupt("return", shareSchema);
            case 17:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
      function shareDataset(_x28, _x29) {
        return _shareDataset.apply(this, arguments);
      }
      return shareDataset;
    }()
  }, {
    key: "unshareDataset",
    value: function () {
      var _unshareDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(datasetId) {
        var response;
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);
              _context30.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(datasetId, "/share"), _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context30.sent;
              _context30.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "unshare dataset", true);
            case 6:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function unshareDataset(_x30) {
        return _unshareDataset.apply(this, arguments);
      }
      return unshareDataset;
    }()
  }, {
    key: "readSharedDataset",
    value: function () {
      var _readSharedDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(shareToken) {
        var response, dataset;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);
              _context31.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/public/").concat(shareToken, "/datasets"), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context31.sent;
              _context31.next = 6;
              return response.json();
            case 6:
              dataset = _context31.sent;
              return _context31.abrupt("return", dataset);
            case 8:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));
      function readSharedDataset(_x31) {
        return _readSharedDataset.apply(this, arguments);
      }
      return readSharedDataset;
    }()
    /**
     * Get shared examples.
     *
     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
     * @param {Object} [options] Additional options for listing the examples.
     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
     * @returns {Promise<Example[]>} The shared examples.
     */
  }, {
    key: "listSharedExamples",
    value: (function () {
      var _listSharedExamples = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(shareToken, options) {
        var _this16 = this;
        var params, urlParams, response, result;
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              params = {};
              if (options !== null && options !== void 0 && options.exampleIds) {
                params.id = options.exampleIds;
              }
              urlParams = new URLSearchParams();
              Object.entries(params).forEach(function (_ref15) {
                var _ref16 = _slicedToArray(_ref15, 2),
                  key = _ref16[0],
                  value = _ref16[1];
                if (Array.isArray(value)) {
                  value.forEach(function (v) {
                    return urlParams.append(key, v);
                  });
                } else {
                  urlParams.append(key, value);
                }
              });
              _context32.next = 6;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/public/").concat(shareToken, "/examples?").concat(urlParams.toString()), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 6:
              response = _context32.sent;
              _context32.next = 9;
              return response.json();
            case 9:
              result = _context32.sent;
              if (response.ok) {
                _context32.next = 14;
                break;
              }
              if (!("detail" in result)) {
                _context32.next = 13;
                break;
              }
              throw new Error("Failed to list shared examples.\nStatus: ".concat(response.status, "\nMessage: ").concat(result.detail.join("\n")));
            case 13:
              throw new Error("Failed to list shared examples: ".concat(response.status, " ").concat(response.statusText));
            case 14:
              return _context32.abrupt("return", result.map(function (example) {
                return _objectSpread(_objectSpread({}, example), {}, {
                  _hostUrl: _this16.getHostUrl()
                });
              }));
            case 15:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this);
      }));
      function listSharedExamples(_x32, _x33) {
        return _listSharedExamples.apply(this, arguments);
      }
      return listSharedExamples;
    }())
  }, {
    key: "createProject",
    value: function () {
      var _createProject = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(_ref17) {
        var projectName, _ref17$description, description, _ref17$metadata, metadata, _ref17$upsert, upsert, _ref17$projectExtra, projectExtra, _ref17$referenceDatas, referenceDatasetId, upsert_, endpoint, extra, body, response, result;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              projectName = _ref17.projectName, _ref17$description = _ref17.description, description = _ref17$description === void 0 ? null : _ref17$description, _ref17$metadata = _ref17.metadata, metadata = _ref17$metadata === void 0 ? null : _ref17$metadata, _ref17$upsert = _ref17.upsert, upsert = _ref17$upsert === void 0 ? false : _ref17$upsert, _ref17$projectExtra = _ref17.projectExtra, projectExtra = _ref17$projectExtra === void 0 ? null : _ref17$projectExtra, _ref17$referenceDatas = _ref17.referenceDatasetId, referenceDatasetId = _ref17$referenceDatas === void 0 ? null : _ref17$referenceDatas;
              upsert_ = upsert ? "?upsert=true" : "";
              endpoint = "".concat(this.apiUrl, "/sessions").concat(upsert_);
              extra = projectExtra || {};
              if (metadata) {
                extra["metadata"] = metadata;
              }
              body = {
                name: projectName,
                extra: extra,
                description: description
              };
              if (referenceDatasetId !== null) {
                body["reference_dataset_id"] = referenceDatasetId;
              }
              _context33.next = 9;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(body),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 9:
              response = _context33.sent;
              _context33.next = 12;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create project");
            case 12:
              _context33.next = 14;
              return response.json();
            case 14:
              result = _context33.sent;
              return _context33.abrupt("return", result);
            case 16:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function createProject(_x34) {
        return _createProject.apply(this, arguments);
      }
      return createProject;
    }()
  }, {
    key: "updateProject",
    value: function () {
      var _updateProject = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(projectId, _ref18) {
        var _ref18$name, name, _ref18$description, description, _ref18$metadata, metadata, _ref18$projectExtra, projectExtra, _ref18$endTime, endTime, endpoint, extra, body, response, result;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              _ref18$name = _ref18.name, name = _ref18$name === void 0 ? null : _ref18$name, _ref18$description = _ref18.description, description = _ref18$description === void 0 ? null : _ref18$description, _ref18$metadata = _ref18.metadata, metadata = _ref18$metadata === void 0 ? null : _ref18$metadata, _ref18$projectExtra = _ref18.projectExtra, projectExtra = _ref18$projectExtra === void 0 ? null : _ref18$projectExtra, _ref18$endTime = _ref18.endTime, endTime = _ref18$endTime === void 0 ? null : _ref18$endTime;
              endpoint = "".concat(this.apiUrl, "/sessions/").concat(projectId);
              extra = projectExtra;
              if (metadata) {
                extra = _objectSpread(_objectSpread({}, extra || {}), {}, {
                  metadata: metadata
                });
              }
              body = {
                name: name,
                extra: extra,
                description: description,
                end_time: endTime ? new Date(endTime).toISOString() : null
              };
              _context34.next = 7;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, _objectSpread({
                method: "PATCH",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(body),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 7:
              response = _context34.sent;
              _context34.next = 10;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update project");
            case 10:
              _context34.next = 12;
              return response.json();
            case 12:
              result = _context34.sent;
              return _context34.abrupt("return", result);
            case 14:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
      function updateProject(_x35, _x36) {
        return _updateProject.apply(this, arguments);
      }
      return updateProject;
    }()
  }, {
    key: "hasProject",
    value: function () {
      var _hasProject = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(_ref19) {
        var projectId, projectName, path, params, response, result;
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              projectId = _ref19.projectId, projectName = _ref19.projectName;
              // TODO: Add a head request
              path = "/sessions";
              params = new URLSearchParams();
              if (!(projectId !== undefined && projectName !== undefined)) {
                _context35.next = 7;
                break;
              }
              throw new Error("Must provide either projectName or projectId, not both");
            case 7:
              if (!(projectId !== undefined)) {
                _context35.next = 12;
                break;
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);
              path += "/".concat(projectId);
              _context35.next = 17;
              break;
            case 12:
              if (!(projectName !== undefined)) {
                _context35.next = 16;
                break;
              }
              params.append("name", projectName);
              _context35.next = 17;
              break;
            case 16:
              throw new Error("Must provide projectName or projectId");
            case 17:
              _context35.next = 19;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl).concat(path, "?").concat(params), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 19:
              response = _context35.sent;
              _context35.prev = 20;
              _context35.next = 23;
              return response.json();
            case 23:
              result = _context35.sent;
              if (response.ok) {
                _context35.next = 26;
                break;
              }
              return _context35.abrupt("return", false);
            case 26:
              if (!Array.isArray(result)) {
                _context35.next = 28;
                break;
              }
              return _context35.abrupt("return", result.length > 0);
            case 28:
              return _context35.abrupt("return", true);
            case 31:
              _context35.prev = 31;
              _context35.t0 = _context35["catch"](20);
              return _context35.abrupt("return", false);
            case 34:
            case "end":
              return _context35.stop();
          }
        }, _callee35, this, [[20, 31]]);
      }));
      function hasProject(_x37) {
        return _hasProject.apply(this, arguments);
      }
      return hasProject;
    }()
  }, {
    key: "readProject",
    value: function () {
      var _readProject = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(_ref20) {
        var projectId, projectName, includeStats, path, params, response, result;
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              projectId = _ref20.projectId, projectName = _ref20.projectName, includeStats = _ref20.includeStats;
              path = "/sessions";
              params = new URLSearchParams();
              if (!(projectId !== undefined && projectName !== undefined)) {
                _context36.next = 7;
                break;
              }
              throw new Error("Must provide either projectName or projectId, not both");
            case 7:
              if (!(projectId !== undefined)) {
                _context36.next = 12;
                break;
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);
              path += "/".concat(projectId);
              _context36.next = 17;
              break;
            case 12:
              if (!(projectName !== undefined)) {
                _context36.next = 16;
                break;
              }
              params.append("name", projectName);
              _context36.next = 17;
              break;
            case 16:
              throw new Error("Must provide projectName or projectId");
            case 17:
              if (includeStats !== undefined) {
                params.append("include_stats", includeStats.toString());
              }
              _context36.next = 20;
              return this._get(path, params);
            case 20:
              response = _context36.sent;
              if (!Array.isArray(response)) {
                _context36.next = 27;
                break;
              }
              if (!(response.length === 0)) {
                _context36.next = 24;
                break;
              }
              throw new Error("Project[id=".concat(projectId, ", name=").concat(projectName, "] not found"));
            case 24:
              result = response[0];
              _context36.next = 28;
              break;
            case 27:
              result = response;
            case 28:
              return _context36.abrupt("return", result);
            case 29:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
      function readProject(_x38) {
        return _readProject.apply(this, arguments);
      }
      return readProject;
    }()
  }, {
    key: "getProjectUrl",
    value: function () {
      var _getProjectUrl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37(_ref21) {
        var projectId, projectName, project, tenantId;
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              projectId = _ref21.projectId, projectName = _ref21.projectName;
              if (!(projectId === undefined && projectName === undefined)) {
                _context37.next = 3;
                break;
              }
              throw new Error("Must provide either projectName or projectId");
            case 3:
              _context37.next = 5;
              return this.readProject({
                projectId: projectId,
                projectName: projectName
              });
            case 5:
              project = _context37.sent;
              _context37.next = 8;
              return this._getTenantId();
            case 8:
              tenantId = _context37.sent;
              return _context37.abrupt("return", "".concat(this.getHostUrl(), "/o/").concat(tenantId, "/projects/p/").concat(project.id));
            case 10:
            case "end":
              return _context37.stop();
          }
        }, _callee37, this);
      }));
      function getProjectUrl(_x39) {
        return _getProjectUrl.apply(this, arguments);
      }
      return getProjectUrl;
    }()
  }, {
    key: "getDatasetUrl",
    value: function () {
      var _getDatasetUrl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(_ref22) {
        var datasetId, datasetName, dataset, tenantId;
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              datasetId = _ref22.datasetId, datasetName = _ref22.datasetName;
              if (!(datasetId === undefined && datasetName === undefined)) {
                _context38.next = 3;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId");
            case 3:
              _context38.next = 5;
              return this.readDataset({
                datasetId: datasetId,
                datasetName: datasetName
              });
            case 5:
              dataset = _context38.sent;
              _context38.next = 8;
              return this._getTenantId();
            case 8:
              tenantId = _context38.sent;
              return _context38.abrupt("return", "".concat(this.getHostUrl(), "/o/").concat(tenantId, "/datasets/").concat(dataset.id));
            case 10:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this);
      }));
      function getDatasetUrl(_x40) {
        return _getDatasetUrl.apply(this, arguments);
      }
      return getDatasetUrl;
    }()
  }, {
    key: "_getTenantId",
    value: function () {
      var _getTenantId2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
        var queryParams, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, projects;
        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              if (!(this._tenantId !== null)) {
                _context39.next = 2;
                break;
              }
              return _context39.abrupt("return", this._tenantId);
            case 2:
              queryParams = new URLSearchParams({
                limit: "1"
              });
              _iteratorAbruptCompletion3 = false;
              _didIteratorError3 = false;
              _context39.prev = 5;
              _iterator3 = _asyncIterator(this._getPaginated("/sessions", queryParams));
            case 7:
              _context39.next = 9;
              return _iterator3.next();
            case 9:
              if (!(_iteratorAbruptCompletion3 = !(_step3 = _context39.sent).done)) {
                _context39.next = 16;
                break;
              }
              projects = _step3.value;
              this._tenantId = projects[0].tenant_id;
              return _context39.abrupt("return", projects[0].tenant_id);
            case 13:
              _iteratorAbruptCompletion3 = false;
              _context39.next = 7;
              break;
            case 16:
              _context39.next = 22;
              break;
            case 18:
              _context39.prev = 18;
              _context39.t0 = _context39["catch"](5);
              _didIteratorError3 = true;
              _iteratorError3 = _context39.t0;
            case 22:
              _context39.prev = 22;
              _context39.prev = 23;
              if (!(_iteratorAbruptCompletion3 && _iterator3["return"] != null)) {
                _context39.next = 27;
                break;
              }
              _context39.next = 27;
              return _iterator3["return"]();
            case 27:
              _context39.prev = 27;
              if (!_didIteratorError3) {
                _context39.next = 30;
                break;
              }
              throw _iteratorError3;
            case 30:
              return _context39.finish(27);
            case 31:
              return _context39.finish(22);
            case 32:
              throw new Error("No projects found to resolve tenant.");
            case 33:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this, [[5, 18, 22, 32], [23,, 27, 31]]);
      }));
      function _getTenantId() {
        return _getTenantId2.apply(this, arguments);
      }
      return _getTenantId;
    }()
  }, {
    key: "listProjects",
    value: function listProjects() {
      var _this4 = this;
      var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        projectIds = _ref23.projectIds,
        name = _ref23.name,
        nameContains = _ref23.nameContains,
        referenceDatasetId = _ref23.referenceDatasetId,
        referenceDatasetName = _ref23.referenceDatasetName,
        referenceFree = _ref23.referenceFree,
        metadata = _ref23.metadata;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        var params, _iterator22, _step22, projectId, dataset, _iteratorAbruptCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, projects;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              params = new URLSearchParams();
              if (projectIds !== undefined) {
                _iterator22 = _createForOfIteratorHelper(projectIds);
                try {
                  for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                    projectId = _step22.value;
                    params.append("id", projectId);
                  }
                } catch (err) {
                  _iterator22.e(err);
                } finally {
                  _iterator22.f();
                }
              }
              if (name !== undefined) {
                params.append("name", name);
              }
              if (nameContains !== undefined) {
                params.append("name_contains", nameContains);
              }
              if (!(referenceDatasetId !== undefined)) {
                _context40.next = 8;
                break;
              }
              params.append("reference_dataset", referenceDatasetId);
              _context40.next = 13;
              break;
            case 8:
              if (!(referenceDatasetName !== undefined)) {
                _context40.next = 13;
                break;
              }
              _context40.next = 11;
              return _awaitAsyncGenerator(_this4.readDataset({
                datasetName: referenceDatasetName
              }));
            case 11:
              dataset = _context40.sent;
              params.append("reference_dataset", dataset.id);
            case 13:
              if (referenceFree !== undefined) {
                params.append("reference_free", referenceFree.toString());
              }
              if (metadata !== undefined) {
                params.append("metadata", JSON.stringify(metadata));
              }
              _iteratorAbruptCompletion4 = false;
              _didIteratorError4 = false;
              _context40.prev = 17;
              _iterator4 = _asyncIterator(_this4._getPaginated("/sessions", params));
            case 19:
              _context40.next = 21;
              return _awaitAsyncGenerator(_iterator4.next());
            case 21:
              if (!(_iteratorAbruptCompletion4 = !(_step4 = _context40.sent).done)) {
                _context40.next = 27;
                break;
              }
              projects = _step4.value;
              return _context40.delegateYield(_asyncGeneratorDelegate(_asyncIterator(projects), _awaitAsyncGenerator), "t0", 24);
            case 24:
              _iteratorAbruptCompletion4 = false;
              _context40.next = 19;
              break;
            case 27:
              _context40.next = 33;
              break;
            case 29:
              _context40.prev = 29;
              _context40.t1 = _context40["catch"](17);
              _didIteratorError4 = true;
              _iteratorError4 = _context40.t1;
            case 33:
              _context40.prev = 33;
              _context40.prev = 34;
              if (!(_iteratorAbruptCompletion4 && _iterator4["return"] != null)) {
                _context40.next = 38;
                break;
              }
              _context40.next = 38;
              return _awaitAsyncGenerator(_iterator4["return"]());
            case 38:
              _context40.prev = 38;
              if (!_didIteratorError4) {
                _context40.next = 41;
                break;
              }
              throw _iteratorError4;
            case 41:
              return _context40.finish(38);
            case 42:
              return _context40.finish(33);
            case 43:
            case "end":
              return _context40.stop();
          }
        }, _callee40, null, [[17, 29, 33, 43], [34,, 38, 42]]);
      }))();
    }
  }, {
    key: "deleteProject",
    value: function () {
      var _deleteProject = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41(_ref24) {
        var projectId, projectName, projectId_, response;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              projectId = _ref24.projectId, projectName = _ref24.projectName;
              if (!(projectId === undefined && projectName === undefined)) {
                _context41.next = 5;
                break;
              }
              throw new Error("Must provide projectName or projectId");
            case 5:
              if (!(projectId !== undefined && projectName !== undefined)) {
                _context41.next = 9;
                break;
              }
              throw new Error("Must provide either projectName or projectId, not both");
            case 9:
              if (!(projectId === undefined)) {
                _context41.next = 15;
                break;
              }
              _context41.next = 12;
              return this.readProject({
                projectName: projectName
              });
            case 12:
              projectId_ = _context41.sent.id;
              _context41.next = 16;
              break;
            case 15:
              projectId_ = projectId;
            case 16:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId_);
              _context41.next = 19;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/sessions/").concat(projectId_), _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 19:
              response = _context41.sent;
              _context41.next = 22;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "delete session ".concat(projectId_, " (").concat(projectName, ")"), true);
            case 22:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this);
      }));
      function deleteProject(_x41) {
        return _deleteProject.apply(this, arguments);
      }
      return deleteProject;
    }()
  }, {
    key: "uploadCsv",
    value: function () {
      var _uploadCsv = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42(_ref25) {
        var csvFile, fileName, inputKeys, outputKeys, description, dataType, name, url, formData, response, result;
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              csvFile = _ref25.csvFile, fileName = _ref25.fileName, inputKeys = _ref25.inputKeys, outputKeys = _ref25.outputKeys, description = _ref25.description, dataType = _ref25.dataType, name = _ref25.name;
              url = "".concat(this.apiUrl, "/datasets/upload");
              formData = new FormData();
              formData.append("file", csvFile, fileName);
              inputKeys.forEach(function (key) {
                formData.append("input_keys", key);
              });
              outputKeys.forEach(function (key) {
                formData.append("output_keys", key);
              });
              if (description) {
                formData.append("description", description);
              }
              if (dataType) {
                formData.append("data_type", dataType);
              }
              if (name) {
                formData.append("name", name);
              }
              _context42.next = 11;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, _objectSpread({
                method: "POST",
                headers: this.headers,
                body: formData,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 11:
              response = _context42.sent;
              _context42.next = 14;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "upload CSV");
            case 14:
              _context42.next = 16;
              return response.json();
            case 16:
              result = _context42.sent;
              return _context42.abrupt("return", result);
            case 18:
            case "end":
              return _context42.stop();
          }
        }, _callee42, this);
      }));
      function uploadCsv(_x42) {
        return _uploadCsv.apply(this, arguments);
      }
      return uploadCsv;
    }()
  }, {
    key: "createDataset",
    value: function () {
      var _createDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43(name) {
        var _ref26,
          description,
          dataType,
          inputsSchema,
          outputsSchema,
          metadata,
          body,
          response,
          result,
          _args43 = arguments;
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _ref26 = _args43.length > 1 && _args43[1] !== undefined ? _args43[1] : {}, description = _ref26.description, dataType = _ref26.dataType, inputsSchema = _ref26.inputsSchema, outputsSchema = _ref26.outputsSchema, metadata = _ref26.metadata;
              body = {
                name: name,
                description: description,
                extra: metadata ? {
                  metadata: metadata
                } : undefined
              };
              if (dataType) {
                body.data_type = dataType;
              }
              if (inputsSchema) {
                body.inputs_schema_definition = inputsSchema;
              }
              if (outputsSchema) {
                body.outputs_schema_definition = outputsSchema;
              }
              _context43.next = 7;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(body),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 7:
              response = _context43.sent;
              _context43.next = 10;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create dataset");
            case 10:
              _context43.next = 12;
              return response.json();
            case 12:
              result = _context43.sent;
              return _context43.abrupt("return", result);
            case 14:
            case "end":
              return _context43.stop();
          }
        }, _callee43, this);
      }));
      function createDataset(_x43) {
        return _createDataset.apply(this, arguments);
      }
      return createDataset;
    }()
  }, {
    key: "readDataset",
    value: function () {
      var _readDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(_ref27) {
        var datasetId, datasetName, path, params, response, result;
        return _regeneratorRuntime().wrap(function _callee44$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              datasetId = _ref27.datasetId, datasetName = _ref27.datasetName;
              path = "/datasets"; // limit to 1 result
              params = new URLSearchParams({
                limit: "1"
              });
              if (!(datasetId !== undefined && datasetName !== undefined)) {
                _context44.next = 7;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 7:
              if (!(datasetId !== undefined)) {
                _context44.next = 12;
                break;
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);
              path += "/".concat(datasetId);
              _context44.next = 17;
              break;
            case 12:
              if (!(datasetName !== undefined)) {
                _context44.next = 16;
                break;
              }
              params.append("name", datasetName);
              _context44.next = 17;
              break;
            case 16:
              throw new Error("Must provide datasetName or datasetId");
            case 17:
              _context44.next = 19;
              return this._get(path, params);
            case 19:
              response = _context44.sent;
              if (!Array.isArray(response)) {
                _context44.next = 26;
                break;
              }
              if (!(response.length === 0)) {
                _context44.next = 23;
                break;
              }
              throw new Error("Dataset[id=".concat(datasetId, ", name=").concat(datasetName, "] not found"));
            case 23:
              result = response[0];
              _context44.next = 27;
              break;
            case 26:
              result = response;
            case 27:
              return _context44.abrupt("return", result);
            case 28:
            case "end":
              return _context44.stop();
          }
        }, _callee44, this);
      }));
      function readDataset(_x44) {
        return _readDataset.apply(this, arguments);
      }
      return readDataset;
    }()
  }, {
    key: "hasDataset",
    value: function () {
      var _hasDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(_ref28) {
        var datasetId, datasetName;
        return _regeneratorRuntime().wrap(function _callee45$(_context45) {
          while (1) switch (_context45.prev = _context45.next) {
            case 0:
              datasetId = _ref28.datasetId, datasetName = _ref28.datasetName;
              _context45.prev = 1;
              _context45.next = 4;
              return this.readDataset({
                datasetId: datasetId,
                datasetName: datasetName
              });
            case 4:
              return _context45.abrupt("return", true);
            case 7:
              _context45.prev = 7;
              _context45.t0 = _context45["catch"](1);
              if (!(
              // eslint-disable-next-line no-instanceof/no-instanceof
              _context45.t0 instanceof Error && _context45.t0.message.toLocaleLowerCase().includes("not found"))) {
                _context45.next = 11;
                break;
              }
              return _context45.abrupt("return", false);
            case 11:
              throw _context45.t0;
            case 12:
            case "end":
              return _context45.stop();
          }
        }, _callee45, this, [[1, 7]]);
      }));
      function hasDataset(_x45) {
        return _hasDataset.apply(this, arguments);
      }
      return hasDataset;
    }()
  }, {
    key: "diffDatasetVersions",
    value: function () {
      var _diffDatasetVersions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46(_ref29) {
        var datasetId, datasetName, fromVersion, toVersion, datasetId_, dataset, urlParams, response;
        return _regeneratorRuntime().wrap(function _callee46$(_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              datasetId = _ref29.datasetId, datasetName = _ref29.datasetName, fromVersion = _ref29.fromVersion, toVersion = _ref29.toVersion;
              datasetId_ = datasetId;
              if (!(datasetId_ === undefined && datasetName === undefined)) {
                _context46.next = 6;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId");
            case 6:
              if (!(datasetId_ !== undefined && datasetName !== undefined)) {
                _context46.next = 10;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 10:
              if (!(datasetId_ === undefined)) {
                _context46.next = 15;
                break;
              }
              _context46.next = 13;
              return this.readDataset({
                datasetName: datasetName
              });
            case 13:
              dataset = _context46.sent;
              datasetId_ = dataset.id;
            case 15:
              urlParams = new URLSearchParams({
                from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
                to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
              });
              _context46.next = 18;
              return this._get("/datasets/".concat(datasetId_, "/versions/diff"), urlParams);
            case 18:
              response = _context46.sent;
              return _context46.abrupt("return", response);
            case 20:
            case "end":
              return _context46.stop();
          }
        }, _callee46, this);
      }));
      function diffDatasetVersions(_x46) {
        return _diffDatasetVersions.apply(this, arguments);
      }
      return diffDatasetVersions;
    }()
  }, {
    key: "readDatasetOpenaiFinetuning",
    value: function () {
      var _readDatasetOpenaiFinetuning = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(_ref30) {
        var datasetId, datasetName, path, response, datasetText, dataset;
        return _regeneratorRuntime().wrap(function _callee47$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              datasetId = _ref30.datasetId, datasetName = _ref30.datasetName;
              path = "/datasets";
              if (!(datasetId !== undefined)) {
                _context47.next = 5;
                break;
              }
              _context47.next = 12;
              break;
            case 5:
              if (!(datasetName !== undefined)) {
                _context47.next = 11;
                break;
              }
              _context47.next = 8;
              return this.readDataset({
                datasetName: datasetName
              });
            case 8:
              datasetId = _context47.sent.id;
              _context47.next = 12;
              break;
            case 11:
              throw new Error("Must provide datasetName or datasetId");
            case 12:
              _context47.next = 14;
              return this._getResponse("".concat(path, "/").concat(datasetId, "/openai_ft"));
            case 14:
              response = _context47.sent;
              _context47.next = 17;
              return response.text();
            case 17:
              datasetText = _context47.sent;
              dataset = datasetText.trim().split("\n").map(function (line) {
                return JSON.parse(line);
              });
              return _context47.abrupt("return", dataset);
            case 20:
            case "end":
              return _context47.stop();
          }
        }, _callee47, this);
      }));
      function readDatasetOpenaiFinetuning(_x47) {
        return _readDatasetOpenaiFinetuning.apply(this, arguments);
      }
      return readDatasetOpenaiFinetuning;
    }()
  }, {
    key: "listDatasets",
    value: function listDatasets() {
      var _this5 = this;
      var _ref31 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref31$limit = _ref31.limit,
        limit = _ref31$limit === void 0 ? 100 : _ref31$limit,
        _ref31$offset = _ref31.offset,
        offset = _ref31$offset === void 0 ? 0 : _ref31$offset,
        datasetIds = _ref31.datasetIds,
        datasetName = _ref31.datasetName,
        datasetNameContains = _ref31.datasetNameContains,
        metadata = _ref31.metadata;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48() {
        var path, params, _iterator23, _step23, id_, _iteratorAbruptCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, datasets;
        return _regeneratorRuntime().wrap(function _callee48$(_context48) {
          while (1) switch (_context48.prev = _context48.next) {
            case 0:
              path = "/datasets";
              params = new URLSearchParams({
                limit: limit.toString(),
                offset: offset.toString()
              });
              if (datasetIds !== undefined) {
                _iterator23 = _createForOfIteratorHelper(datasetIds);
                try {
                  for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                    id_ = _step23.value;
                    params.append("id", id_);
                  }
                } catch (err) {
                  _iterator23.e(err);
                } finally {
                  _iterator23.f();
                }
              }
              if (datasetName !== undefined) {
                params.append("name", datasetName);
              }
              if (datasetNameContains !== undefined) {
                params.append("name_contains", datasetNameContains);
              }
              if (metadata !== undefined) {
                params.append("metadata", JSON.stringify(metadata));
              }
              _iteratorAbruptCompletion5 = false;
              _didIteratorError5 = false;
              _context48.prev = 8;
              _iterator5 = _asyncIterator(_this5._getPaginated(path, params));
            case 10:
              _context48.next = 12;
              return _awaitAsyncGenerator(_iterator5.next());
            case 12:
              if (!(_iteratorAbruptCompletion5 = !(_step5 = _context48.sent).done)) {
                _context48.next = 18;
                break;
              }
              datasets = _step5.value;
              return _context48.delegateYield(_asyncGeneratorDelegate(_asyncIterator(datasets), _awaitAsyncGenerator), "t0", 15);
            case 15:
              _iteratorAbruptCompletion5 = false;
              _context48.next = 10;
              break;
            case 18:
              _context48.next = 24;
              break;
            case 20:
              _context48.prev = 20;
              _context48.t1 = _context48["catch"](8);
              _didIteratorError5 = true;
              _iteratorError5 = _context48.t1;
            case 24:
              _context48.prev = 24;
              _context48.prev = 25;
              if (!(_iteratorAbruptCompletion5 && _iterator5["return"] != null)) {
                _context48.next = 29;
                break;
              }
              _context48.next = 29;
              return _awaitAsyncGenerator(_iterator5["return"]());
            case 29:
              _context48.prev = 29;
              if (!_didIteratorError5) {
                _context48.next = 32;
                break;
              }
              throw _iteratorError5;
            case 32:
              return _context48.finish(29);
            case 33:
              return _context48.finish(24);
            case 34:
            case "end":
              return _context48.stop();
          }
        }, _callee48, null, [[8, 20, 24, 34], [25,, 29, 33]]);
      }))();
    }
    /**
     * Update a dataset
     * @param props The dataset details to update
     * @returns The updated dataset
     */
  }, {
    key: "updateDataset",
    value: (function () {
      var _updateDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49(props) {
        var datasetId, datasetName, update, _datasetId, response;
        return _regeneratorRuntime().wrap(function _callee49$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              datasetId = props.datasetId, datasetName = props.datasetName, update = _objectWithoutProperties(props, _excluded2);
              if (!(!datasetId && !datasetName)) {
                _context49.next = 3;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId");
            case 3:
              if (!(datasetId !== null && datasetId !== void 0)) {
                _context49.next = 7;
                break;
              }
              _context49.t0 = datasetId;
              _context49.next = 10;
              break;
            case 7:
              _context49.next = 9;
              return this.readDataset({
                datasetName: datasetName
              });
            case 9:
              _context49.t0 = _context49.sent.id;
            case 10:
              _datasetId = _context49.t0;
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(_datasetId);
              _context49.next = 14;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(_datasetId), _objectSpread({
                method: "PATCH",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(update),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 14:
              response = _context49.sent;
              _context49.next = 17;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update dataset");
            case 17:
              _context49.next = 19;
              return response.json();
            case 19:
              return _context49.abrupt("return", _context49.sent);
            case 20:
            case "end":
              return _context49.stop();
          }
        }, _callee49, this);
      }));
      function updateDataset(_x48) {
        return _updateDataset.apply(this, arguments);
      }
      return updateDataset;
    }())
  }, {
    key: "deleteDataset",
    value: function () {
      var _deleteDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee50(_ref32) {
        var datasetId, datasetName, path, datasetId_, dataset, response;
        return _regeneratorRuntime().wrap(function _callee50$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              datasetId = _ref32.datasetId, datasetName = _ref32.datasetName;
              path = "/datasets";
              datasetId_ = datasetId;
              if (!(datasetId !== undefined && datasetName !== undefined)) {
                _context50.next = 7;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 7:
              if (!(datasetName !== undefined)) {
                _context50.next = 12;
                break;
              }
              _context50.next = 10;
              return this.readDataset({
                datasetName: datasetName
              });
            case 10:
              dataset = _context50.sent;
              datasetId_ = dataset.id;
            case 12:
              if (!(datasetId_ !== undefined)) {
                _context50.next = 17;
                break;
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);
              path += "/".concat(datasetId_);
              _context50.next = 18;
              break;
            case 17:
              throw new Error("Must provide datasetName or datasetId");
            case 18:
              _context50.next = 20;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 20:
              response = _context50.sent;
              _context50.next = 23;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "delete ".concat(path));
            case 23:
              _context50.next = 25;
              return response.json();
            case 25:
            case "end":
              return _context50.stop();
          }
        }, _callee50, this);
      }));
      function deleteDataset(_x49) {
        return _deleteDataset.apply(this, arguments);
      }
      return deleteDataset;
    }()
  }, {
    key: "indexDataset",
    value: function () {
      var _indexDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee51(_ref33) {
        var datasetId, datasetName, tag, datasetId_, dataset, data, response;
        return _regeneratorRuntime().wrap(function _callee51$(_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              datasetId = _ref33.datasetId, datasetName = _ref33.datasetName, tag = _ref33.tag;
              datasetId_ = datasetId;
              if (!(!datasetId_ && !datasetName)) {
                _context51.next = 6;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId");
            case 6:
              if (!(datasetId_ && datasetName)) {
                _context51.next = 10;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 10:
              if (datasetId_) {
                _context51.next = 15;
                break;
              }
              _context51.next = 13;
              return this.readDataset({
                datasetName: datasetName
              });
            case 13:
              dataset = _context51.sent;
              datasetId_ = dataset.id;
            case 15:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);
              data = {
                tag: tag
              };
              _context51.next = 19;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(datasetId_, "/index"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 19:
              response = _context51.sent;
              _context51.next = 22;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "index dataset");
            case 22:
              _context51.next = 24;
              return response.json();
            case 24:
            case "end":
              return _context51.stop();
          }
        }, _callee51, this);
      }));
      function indexDataset(_x50) {
        return _indexDataset.apply(this, arguments);
      }
      return indexDataset;
    }()
    /**
     * Lets you run a similarity search query on a dataset.
     *
     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
     *
     * @param inputs      The input on which to run the similarity search. Must have the
     *                    same schema as the dataset.
     *
     * @param datasetId   The dataset to search for similar examples.
     *
     * @param limit       The maximum number of examples to return. Will return the top `limit` most
     *                    similar examples in order of most similar to least similar. If no similar
     *                    examples are found, random examples will be returned.
     *
     * @param filter      A filter string to apply to the search. Only examples will be returned that
     *                    match the filter string. Some examples of filters
     *
     *                    - eq(metadata.mykey, "value")
     *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
     *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
     *
     * @returns           A list of similar examples.
     *
     *
     * @example
     * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
     * inputs = {"text": "How many people live in Berlin?"}
     * limit = 5
     * examples = await client.similarExamples(inputs, dataset_id, limit)
     */
  }, {
    key: "similarExamples",
    value: (function () {
      var _similarExamples = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee52(inputs, datasetId, limit) {
        var _ref34,
          filter,
          data,
          response,
          result,
          _args52 = arguments;
        return _regeneratorRuntime().wrap(function _callee52$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              _ref34 = _args52.length > 3 && _args52[3] !== undefined ? _args52[3] : {}, filter = _ref34.filter;
              data = {
                limit: limit,
                inputs: inputs
              };
              if (filter !== undefined) {
                data["filter"] = filter;
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);
              _context52.next = 6;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(datasetId, "/search"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 6:
              response = _context52.sent;
              _context52.next = 9;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "fetch similar examples");
            case 9:
              _context52.next = 11;
              return response.json();
            case 11:
              result = _context52.sent;
              return _context52.abrupt("return", result["examples"]);
            case 13:
            case "end":
              return _context52.stop();
          }
        }, _callee52, this);
      }));
      function similarExamples(_x51, _x52, _x53) {
        return _similarExamples.apply(this, arguments);
      }
      return similarExamples;
    }())
  }, {
    key: "createExample",
    value: function () {
      var _createExample = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee53(inputs, outputs, _ref35) {
        var datasetId, datasetName, createdAt, exampleId, metadata, split, sourceRunId, datasetId_, dataset, createdAt_, data, response, result;
        return _regeneratorRuntime().wrap(function _callee53$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              datasetId = _ref35.datasetId, datasetName = _ref35.datasetName, createdAt = _ref35.createdAt, exampleId = _ref35.exampleId, metadata = _ref35.metadata, split = _ref35.split, sourceRunId = _ref35.sourceRunId;
              datasetId_ = datasetId;
              if (!(datasetId_ === undefined && datasetName === undefined)) {
                _context53.next = 6;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId");
            case 6:
              if (!(datasetId_ !== undefined && datasetName !== undefined)) {
                _context53.next = 10;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 10:
              if (!(datasetId_ === undefined)) {
                _context53.next = 15;
                break;
              }
              _context53.next = 13;
              return this.readDataset({
                datasetName: datasetName
              });
            case 13:
              dataset = _context53.sent;
              datasetId_ = dataset.id;
            case 15:
              createdAt_ = createdAt || new Date();
              data = {
                dataset_id: datasetId_,
                inputs: inputs,
                outputs: outputs,
                created_at: createdAt_ === null || createdAt_ === void 0 ? void 0 : createdAt_.toISOString(),
                id: exampleId,
                metadata: metadata,
                split: split,
                source_run_id: sourceRunId
              };
              _context53.next = 19;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/examples"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 19:
              response = _context53.sent;
              _context53.next = 22;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create example");
            case 22:
              _context53.next = 24;
              return response.json();
            case 24:
              result = _context53.sent;
              return _context53.abrupt("return", result);
            case 26:
            case "end":
              return _context53.stop();
          }
        }, _callee53, this);
      }));
      function createExample(_x54, _x55, _x56) {
        return _createExample.apply(this, arguments);
      }
      return createExample;
    }()
  }, {
    key: "createExamples",
    value: function () {
      var _createExamples = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee54(props) {
        var inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName, datasetId_, dataset, formattedExamples, response, result;
        return _regeneratorRuntime().wrap(function _callee54$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              inputs = props.inputs, outputs = props.outputs, metadata = props.metadata, sourceRunIds = props.sourceRunIds, exampleIds = props.exampleIds, datasetId = props.datasetId, datasetName = props.datasetName;
              datasetId_ = datasetId;
              if (!(datasetId_ === undefined && datasetName === undefined)) {
                _context54.next = 6;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId");
            case 6:
              if (!(datasetId_ !== undefined && datasetName !== undefined)) {
                _context54.next = 10;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 10:
              if (!(datasetId_ === undefined)) {
                _context54.next = 15;
                break;
              }
              _context54.next = 13;
              return this.readDataset({
                datasetName: datasetName
              });
            case 13:
              dataset = _context54.sent;
              datasetId_ = dataset.id;
            case 15:
              formattedExamples = inputs.map(function (input, idx) {
                return {
                  dataset_id: datasetId_,
                  inputs: input,
                  outputs: outputs ? outputs[idx] : undefined,
                  metadata: metadata ? metadata[idx] : undefined,
                  split: props.splits ? props.splits[idx] : undefined,
                  id: exampleIds ? exampleIds[idx] : undefined,
                  source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined
                };
              });
              _context54.next = 18;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/examples/bulk"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(formattedExamples),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 18:
              response = _context54.sent;
              _context54.next = 21;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create examples");
            case 21:
              _context54.next = 23;
              return response.json();
            case 23:
              result = _context54.sent;
              return _context54.abrupt("return", result);
            case 25:
            case "end":
              return _context54.stop();
          }
        }, _callee54, this);
      }));
      function createExamples(_x57) {
        return _createExamples.apply(this, arguments);
      }
      return createExamples;
    }()
  }, {
    key: "createLLMExample",
    value: function () {
      var _createLLMExample = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee55(input, generation, options) {
        return _regeneratorRuntime().wrap(function _callee55$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              return _context55.abrupt("return", this.createExample({
                input: input
              }, {
                output: generation
              }, options));
            case 1:
            case "end":
              return _context55.stop();
          }
        }, _callee55, this);
      }));
      function createLLMExample(_x58, _x59, _x60) {
        return _createLLMExample.apply(this, arguments);
      }
      return createLLMExample;
    }()
  }, {
    key: "createChatExample",
    value: function () {
      var _createChatExample = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee56(input, generations, options) {
        var finalInput, finalOutput;
        return _regeneratorRuntime().wrap(function _callee56$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              finalInput = input.map(function (message) {
                if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {
                  return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);
                }
                return message;
              });
              finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;
              return _context56.abrupt("return", this.createExample({
                input: finalInput
              }, {
                output: finalOutput
              }, options));
            case 3:
            case "end":
              return _context56.stop();
          }
        }, _callee56, this);
      }));
      function createChatExample(_x61, _x62, _x63) {
        return _createChatExample.apply(this, arguments);
      }
      return createChatExample;
    }()
  }, {
    key: "readExample",
    value: function () {
      var _readExample = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee57(exampleId) {
        var path;
        return _regeneratorRuntime().wrap(function _callee57$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);
              path = "/examples/".concat(exampleId);
              _context57.next = 4;
              return this._get(path);
            case 4:
              return _context57.abrupt("return", _context57.sent);
            case 5:
            case "end":
              return _context57.stop();
          }
        }, _callee57, this);
      }));
      function readExample(_x64) {
        return _readExample.apply(this, arguments);
      }
      return readExample;
    }()
  }, {
    key: "listExamples",
    value: function listExamples() {
      var _this6 = this;
      var _ref36 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        datasetId = _ref36.datasetId,
        datasetName = _ref36.datasetName,
        exampleIds = _ref36.exampleIds,
        asOf = _ref36.asOf,
        splits = _ref36.splits,
        inlineS3Urls = _ref36.inlineS3Urls,
        metadata = _ref36.metadata,
        limit = _ref36.limit,
        offset = _ref36.offset,
        filter = _ref36.filter;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {
        var datasetId_, dataset, params, dataset_version, inlineS3Urls_, _iterator24, _step24, id_, _iterator25, _step25, split, serializedMetadata, i, _iteratorAbruptCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, examples, _iterator26, _step26, example;
        return _regeneratorRuntime().wrap(function _callee58$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              if (!(datasetId !== undefined && datasetName !== undefined)) {
                _context58.next = 4;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 4:
              if (!(datasetId !== undefined)) {
                _context58.next = 8;
                break;
              }
              datasetId_ = datasetId;
              _context58.next = 16;
              break;
            case 8:
              if (!(datasetName !== undefined)) {
                _context58.next = 15;
                break;
              }
              _context58.next = 11;
              return _awaitAsyncGenerator(_this6.readDataset({
                datasetName: datasetName
              }));
            case 11:
              dataset = _context58.sent;
              datasetId_ = dataset.id;
              _context58.next = 16;
              break;
            case 15:
              throw new Error("Must provide a datasetName or datasetId");
            case 16:
              params = new URLSearchParams({
                dataset: datasetId_
              });
              dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf === null || asOf === void 0 ? void 0 : asOf.toISOString() : undefined;
              if (dataset_version) {
                params.append("as_of", dataset_version);
              }
              inlineS3Urls_ = inlineS3Urls !== null && inlineS3Urls !== void 0 ? inlineS3Urls : true;
              params.append("inline_s3_urls", inlineS3Urls_.toString());
              if (exampleIds !== undefined) {
                _iterator24 = _createForOfIteratorHelper(exampleIds);
                try {
                  for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                    id_ = _step24.value;
                    params.append("id", id_);
                  }
                } catch (err) {
                  _iterator24.e(err);
                } finally {
                  _iterator24.f();
                }
              }
              if (splits !== undefined) {
                _iterator25 = _createForOfIteratorHelper(splits);
                try {
                  for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                    split = _step25.value;
                    params.append("splits", split);
                  }
                } catch (err) {
                  _iterator25.e(err);
                } finally {
                  _iterator25.f();
                }
              }
              if (metadata !== undefined) {
                serializedMetadata = JSON.stringify(metadata);
                params.append("metadata", serializedMetadata);
              }
              if (limit !== undefined) {
                params.append("limit", limit.toString());
              }
              if (offset !== undefined) {
                params.append("offset", offset.toString());
              }
              if (filter !== undefined) {
                params.append("filter", filter);
              }
              i = 0;
              _iteratorAbruptCompletion6 = false;
              _didIteratorError6 = false;
              _context58.prev = 30;
              _iterator6 = _asyncIterator(_this6._getPaginated("/examples", params));
            case 32:
              _context58.next = 34;
              return _awaitAsyncGenerator(_iterator6.next());
            case 34:
              if (!(_iteratorAbruptCompletion6 = !(_step6 = _context58.sent).done)) {
                _context58.next = 59;
                break;
              }
              examples = _step6.value;
              _iterator26 = _createForOfIteratorHelper(examples);
              _context58.prev = 37;
              _iterator26.s();
            case 39:
              if ((_step26 = _iterator26.n()).done) {
                _context58.next = 46;
                break;
              }
              example = _step26.value;
              _context58.next = 43;
              return example;
            case 43:
              i++;
            case 44:
              _context58.next = 39;
              break;
            case 46:
              _context58.next = 51;
              break;
            case 48:
              _context58.prev = 48;
              _context58.t0 = _context58["catch"](37);
              _iterator26.e(_context58.t0);
            case 51:
              _context58.prev = 51;
              _iterator26.f();
              return _context58.finish(51);
            case 54:
              if (!(limit !== undefined && i >= limit)) {
                _context58.next = 56;
                break;
              }
              return _context58.abrupt("break", 59);
            case 56:
              _iteratorAbruptCompletion6 = false;
              _context58.next = 32;
              break;
            case 59:
              _context58.next = 65;
              break;
            case 61:
              _context58.prev = 61;
              _context58.t1 = _context58["catch"](30);
              _didIteratorError6 = true;
              _iteratorError6 = _context58.t1;
            case 65:
              _context58.prev = 65;
              _context58.prev = 66;
              if (!(_iteratorAbruptCompletion6 && _iterator6["return"] != null)) {
                _context58.next = 70;
                break;
              }
              _context58.next = 70;
              return _awaitAsyncGenerator(_iterator6["return"]());
            case 70:
              _context58.prev = 70;
              if (!_didIteratorError6) {
                _context58.next = 73;
                break;
              }
              throw _iteratorError6;
            case 73:
              return _context58.finish(70);
            case 74:
              return _context58.finish(65);
            case 75:
            case "end":
              return _context58.stop();
          }
        }, _callee58, null, [[30, 61, 65, 75], [37, 48, 51, 54], [66,, 70, 74]]);
      }))();
    }
  }, {
    key: "deleteExample",
    value: function () {
      var _deleteExample = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee59(exampleId) {
        var path, response;
        return _regeneratorRuntime().wrap(function _callee59$(_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);
              path = "/examples/".concat(exampleId);
              _context59.next = 4;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 4:
              response = _context59.sent;
              _context59.next = 7;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "delete ".concat(path));
            case 7:
              _context59.next = 9;
              return response.json();
            case 9:
            case "end":
              return _context59.stop();
          }
        }, _callee59, this);
      }));
      function deleteExample(_x65) {
        return _deleteExample.apply(this, arguments);
      }
      return deleteExample;
    }()
  }, {
    key: "updateExample",
    value: function () {
      var _updateExample = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee60(exampleId, update) {
        var response, result;
        return _regeneratorRuntime().wrap(function _callee60$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);
              _context60.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/examples/").concat(exampleId), _objectSpread({
                method: "PATCH",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(update),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context60.sent;
              _context60.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update example");
            case 6:
              _context60.next = 8;
              return response.json();
            case 8:
              result = _context60.sent;
              return _context60.abrupt("return", result);
            case 10:
            case "end":
              return _context60.stop();
          }
        }, _callee60, this);
      }));
      function updateExample(_x66, _x67) {
        return _updateExample.apply(this, arguments);
      }
      return updateExample;
    }()
  }, {
    key: "updateExamples",
    value: function () {
      var _updateExamples = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee61(update) {
        var response, result;
        return _regeneratorRuntime().wrap(function _callee61$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              _context61.next = 2;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/examples/bulk"), _objectSpread({
                method: "PATCH",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(update),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 2:
              response = _context61.sent;
              _context61.next = 5;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update examples");
            case 5:
              _context61.next = 7;
              return response.json();
            case 7:
              result = _context61.sent;
              return _context61.abrupt("return", result);
            case 9:
            case "end":
              return _context61.stop();
          }
        }, _callee61, this);
      }));
      function updateExamples(_x68) {
        return _updateExamples.apply(this, arguments);
      }
      return updateExamples;
    }()
  }, {
    key: "listDatasetSplits",
    value: function () {
      var _listDatasetSplits = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee62(_ref37) {
        var datasetId, datasetName, asOf, datasetId_, dataset, params, dataset_version, response;
        return _regeneratorRuntime().wrap(function _callee62$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              datasetId = _ref37.datasetId, datasetName = _ref37.datasetName, asOf = _ref37.asOf;
              if (!(datasetId === undefined && datasetName === undefined)) {
                _context62.next = 5;
                break;
              }
              throw new Error("Must provide dataset name or ID");
            case 5:
              if (!(datasetId !== undefined && datasetName !== undefined)) {
                _context62.next = 9;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 9:
              if (!(datasetId === undefined)) {
                _context62.next = 16;
                break;
              }
              _context62.next = 12;
              return this.readDataset({
                datasetName: datasetName
              });
            case 12:
              dataset = _context62.sent;
              datasetId_ = dataset.id;
              _context62.next = 17;
              break;
            case 16:
              datasetId_ = datasetId;
            case 17:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);
              params = new URLSearchParams();
              dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf === null || asOf === void 0 ? void 0 : asOf.toISOString() : undefined;
              if (dataset_version) {
                params.append("as_of", dataset_version);
              }
              _context62.next = 23;
              return this._get("/datasets/".concat(datasetId_, "/splits"), params);
            case 23:
              response = _context62.sent;
              return _context62.abrupt("return", response);
            case 25:
            case "end":
              return _context62.stop();
          }
        }, _callee62, this);
      }));
      function listDatasetSplits(_x69) {
        return _listDatasetSplits.apply(this, arguments);
      }
      return listDatasetSplits;
    }()
  }, {
    key: "updateDatasetSplits",
    value: function () {
      var _updateDatasetSplits = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee63(_ref38) {
        var datasetId, datasetName, splitName, exampleIds, _ref38$remove, remove, datasetId_, dataset, data, response;
        return _regeneratorRuntime().wrap(function _callee63$(_context63) {
          while (1) switch (_context63.prev = _context63.next) {
            case 0:
              datasetId = _ref38.datasetId, datasetName = _ref38.datasetName, splitName = _ref38.splitName, exampleIds = _ref38.exampleIds, _ref38$remove = _ref38.remove, remove = _ref38$remove === void 0 ? false : _ref38$remove;
              if (!(datasetId === undefined && datasetName === undefined)) {
                _context63.next = 5;
                break;
              }
              throw new Error("Must provide dataset name or ID");
            case 5:
              if (!(datasetId !== undefined && datasetName !== undefined)) {
                _context63.next = 9;
                break;
              }
              throw new Error("Must provide either datasetName or datasetId, not both");
            case 9:
              if (!(datasetId === undefined)) {
                _context63.next = 16;
                break;
              }
              _context63.next = 12;
              return this.readDataset({
                datasetName: datasetName
              });
            case 12:
              dataset = _context63.sent;
              datasetId_ = dataset.id;
              _context63.next = 17;
              break;
            case 16:
              datasetId_ = datasetId;
            case 17:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);
              data = {
                split_name: splitName,
                examples: exampleIds.map(function (id) {
                  (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id);
                  return id;
                }),
                remove: remove
              };
              _context63.next = 21;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/").concat(datasetId_, "/splits"), _objectSpread({
                method: "PUT",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 21:
              response = _context63.sent;
              _context63.next = 24;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update dataset splits", true);
            case 24:
            case "end":
              return _context63.stop();
          }
        }, _callee63, this);
      }));
      function updateDatasetSplits(_x70) {
        return _updateDatasetSplits.apply(this, arguments);
      }
      return updateDatasetSplits;
    }()
    /**
     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
     */
  }, {
    key: "evaluateRun",
    value: (function () {
      var _evaluateRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee64(run, evaluator) {
        var _ref39,
          sourceInfo,
          loadChildRuns,
          referenceExample,
          run_,
          feedbackResult,
          _yield$this$_logEvalu,
          _yield$this$_logEvalu2,
          _,
          feedbacks,
          _args64 = arguments;
        return _regeneratorRuntime().wrap(function _callee64$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              _ref39 = _args64.length > 2 && _args64[2] !== undefined ? _args64[2] : {
                loadChildRuns: false
              }, sourceInfo = _ref39.sourceInfo, loadChildRuns = _ref39.loadChildRuns, referenceExample = _ref39.referenceExample;
              (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_5__.warnOnce)("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
              if (!(typeof run === "string")) {
                _context64.next = 8;
                break;
              }
              _context64.next = 5;
              return this.readRun(run, {
                loadChildRuns: loadChildRuns
              });
            case 5:
              run_ = _context64.sent;
              _context64.next = 13;
              break;
            case 8:
              if (!(_typeof(run) === "object" && "id" in run)) {
                _context64.next = 12;
                break;
              }
              run_ = run;
              _context64.next = 13;
              break;
            case 12:
              throw new Error("Invalid run type: ".concat(_typeof(run)));
            case 13:
              if (!(run_.reference_example_id !== null && run_.reference_example_id !== undefined)) {
                _context64.next = 17;
                break;
              }
              _context64.next = 16;
              return this.readExample(run_.reference_example_id);
            case 16:
              referenceExample = _context64.sent;
            case 17:
              _context64.next = 19;
              return evaluator.evaluateRun(run_, referenceExample);
            case 19:
              feedbackResult = _context64.sent;
              _context64.next = 22;
              return this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
            case 22:
              _yield$this$_logEvalu = _context64.sent;
              _yield$this$_logEvalu2 = _slicedToArray(_yield$this$_logEvalu, 2);
              _ = _yield$this$_logEvalu2[0];
              feedbacks = _yield$this$_logEvalu2[1];
              return _context64.abrupt("return", feedbacks[0]);
            case 27:
            case "end":
              return _context64.stop();
          }
        }, _callee64, this);
      }));
      function evaluateRun(_x71, _x72) {
        return _evaluateRun.apply(this, arguments);
      }
      return evaluateRun;
    }())
  }, {
    key: "createFeedback",
    value: function () {
      var _createFeedback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee65(runId, key, _ref40) {
        var _feedback_source$meta;
        var score, value, correction, comment, sourceInfo, _ref40$feedbackSource, feedbackSourceType, sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, feedback_source, feedback, url, response;
        return _regeneratorRuntime().wrap(function _callee65$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              score = _ref40.score, value = _ref40.value, correction = _ref40.correction, comment = _ref40.comment, sourceInfo = _ref40.sourceInfo, _ref40$feedbackSource = _ref40.feedbackSourceType, feedbackSourceType = _ref40$feedbackSource === void 0 ? "api" : _ref40$feedbackSource, sourceRunId = _ref40.sourceRunId, feedbackId = _ref40.feedbackId, feedbackConfig = _ref40.feedbackConfig, projectId = _ref40.projectId, comparativeExperimentId = _ref40.comparativeExperimentId;
              if (!(!runId && !projectId)) {
                _context65.next = 3;
                break;
              }
              throw new Error("One of runId or projectId must be provided");
            case 3:
              if (!(runId && projectId)) {
                _context65.next = 5;
                break;
              }
              throw new Error("Only one of runId or projectId can be provided");
            case 5:
              feedback_source = {
                type: feedbackSourceType !== null && feedbackSourceType !== void 0 ? feedbackSourceType : "api",
                metadata: sourceInfo !== null && sourceInfo !== void 0 ? sourceInfo : {}
              };
              if (sourceRunId !== undefined && (feedback_source === null || feedback_source === void 0 ? void 0 : feedback_source.metadata) !== undefined && !feedback_source.metadata["__run"]) {
                feedback_source.metadata["__run"] = {
                  run_id: sourceRunId
                };
              }
              if ((feedback_source === null || feedback_source === void 0 ? void 0 : feedback_source.metadata) !== undefined && ((_feedback_source$meta = feedback_source.metadata["__run"]) === null || _feedback_source$meta === void 0 ? void 0 : _feedback_source$meta.run_id) !== undefined) {
                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedback_source.metadata["__run"].run_id);
              }
              feedback = {
                id: feedbackId !== null && feedbackId !== void 0 ? feedbackId : uuid__WEBPACK_IMPORTED_MODULE_10__["default"](),
                run_id: runId,
                key: key,
                score: score,
                value: value,
                correction: correction,
                comment: comment,
                feedback_source: feedback_source,
                comparative_experiment_id: comparativeExperimentId,
                feedbackConfig: feedbackConfig,
                session_id: projectId
              };
              url = "".concat(this.apiUrl, "/feedback");
              _context65.next = 12;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(feedback),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 12:
              response = _context65.sent;
              _context65.next = 15;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create feedback", true);
            case 15:
              return _context65.abrupt("return", feedback);
            case 16:
            case "end":
              return _context65.stop();
          }
        }, _callee65, this);
      }));
      function createFeedback(_x73, _x74, _x75) {
        return _createFeedback.apply(this, arguments);
      }
      return createFeedback;
    }()
  }, {
    key: "updateFeedback",
    value: function () {
      var _updateFeedback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee66(feedbackId, _ref41) {
        var score, value, correction, comment, feedbackUpdate, response;
        return _regeneratorRuntime().wrap(function _callee66$(_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              score = _ref41.score, value = _ref41.value, correction = _ref41.correction, comment = _ref41.comment;
              feedbackUpdate = {};
              if (score !== undefined && score !== null) {
                feedbackUpdate["score"] = score;
              }
              if (value !== undefined && value !== null) {
                feedbackUpdate["value"] = value;
              }
              if (correction !== undefined && correction !== null) {
                feedbackUpdate["correction"] = correction;
              }
              if (comment !== undefined && comment !== null) {
                feedbackUpdate["comment"] = comment;
              }
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);
              _context66.next = 9;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/feedback/").concat(feedbackId), _objectSpread({
                method: "PATCH",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(feedbackUpdate),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 9:
              response = _context66.sent;
              _context66.next = 12;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update feedback", true);
            case 12:
            case "end":
              return _context66.stop();
          }
        }, _callee66, this);
      }));
      function updateFeedback(_x76, _x77) {
        return _updateFeedback.apply(this, arguments);
      }
      return updateFeedback;
    }()
  }, {
    key: "readFeedback",
    value: function () {
      var _readFeedback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee67(feedbackId) {
        var path, response;
        return _regeneratorRuntime().wrap(function _callee67$(_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);
              path = "/feedback/".concat(feedbackId);
              _context67.next = 4;
              return this._get(path);
            case 4:
              response = _context67.sent;
              return _context67.abrupt("return", response);
            case 6:
            case "end":
              return _context67.stop();
          }
        }, _callee67, this);
      }));
      function readFeedback(_x78) {
        return _readFeedback.apply(this, arguments);
      }
      return readFeedback;
    }()
  }, {
    key: "deleteFeedback",
    value: function () {
      var _deleteFeedback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee68(feedbackId) {
        var path, response;
        return _regeneratorRuntime().wrap(function _callee68$(_context68) {
          while (1) switch (_context68.prev = _context68.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);
              path = "/feedback/".concat(feedbackId);
              _context68.next = 4;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 4:
              response = _context68.sent;
              _context68.next = 7;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "delete ".concat(path));
            case 7:
              _context68.next = 9;
              return response.json();
            case 9:
            case "end":
              return _context68.stop();
          }
        }, _callee68, this);
      }));
      function deleteFeedback(_x79) {
        return _deleteFeedback.apply(this, arguments);
      }
      return deleteFeedback;
    }()
  }, {
    key: "listFeedback",
    value: function listFeedback() {
      var _this7 = this;
      var _ref42 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        runIds = _ref42.runIds,
        feedbackKeys = _ref42.feedbackKeys,
        feedbackSourceTypes = _ref42.feedbackSourceTypes;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee69() {
        var queryParams, _iterator27, _step27, key, _iterator28, _step28, type, _iteratorAbruptCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, feedbacks;
        return _regeneratorRuntime().wrap(function _callee69$(_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              queryParams = new URLSearchParams();
              if (runIds) {
                queryParams.append("run", runIds.join(","));
              }
              if (feedbackKeys) {
                _iterator27 = _createForOfIteratorHelper(feedbackKeys);
                try {
                  for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                    key = _step27.value;
                    queryParams.append("key", key);
                  }
                } catch (err) {
                  _iterator27.e(err);
                } finally {
                  _iterator27.f();
                }
              }
              if (feedbackSourceTypes) {
                _iterator28 = _createForOfIteratorHelper(feedbackSourceTypes);
                try {
                  for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                    type = _step28.value;
                    queryParams.append("source", type);
                  }
                } catch (err) {
                  _iterator28.e(err);
                } finally {
                  _iterator28.f();
                }
              }
              _iteratorAbruptCompletion7 = false;
              _didIteratorError7 = false;
              _context69.prev = 6;
              _iterator7 = _asyncIterator(_this7._getPaginated("/feedback", queryParams));
            case 8:
              _context69.next = 10;
              return _awaitAsyncGenerator(_iterator7.next());
            case 10:
              if (!(_iteratorAbruptCompletion7 = !(_step7 = _context69.sent).done)) {
                _context69.next = 16;
                break;
              }
              feedbacks = _step7.value;
              return _context69.delegateYield(_asyncGeneratorDelegate(_asyncIterator(feedbacks), _awaitAsyncGenerator), "t0", 13);
            case 13:
              _iteratorAbruptCompletion7 = false;
              _context69.next = 8;
              break;
            case 16:
              _context69.next = 22;
              break;
            case 18:
              _context69.prev = 18;
              _context69.t1 = _context69["catch"](6);
              _didIteratorError7 = true;
              _iteratorError7 = _context69.t1;
            case 22:
              _context69.prev = 22;
              _context69.prev = 23;
              if (!(_iteratorAbruptCompletion7 && _iterator7["return"] != null)) {
                _context69.next = 27;
                break;
              }
              _context69.next = 27;
              return _awaitAsyncGenerator(_iterator7["return"]());
            case 27:
              _context69.prev = 27;
              if (!_didIteratorError7) {
                _context69.next = 30;
                break;
              }
              throw _iteratorError7;
            case 30:
              return _context69.finish(27);
            case 31:
              return _context69.finish(22);
            case 32:
            case "end":
              return _context69.stop();
          }
        }, _callee69, null, [[6, 18, 22, 32], [23,, 27, 31]]);
      }))();
    }
    /**
     * Creates a presigned feedback token and URL.
     *
     * The token can be used to authorize feedback metrics without
     * needing an API key. This is useful for giving browser-based
     * applications the ability to submit feedback without needing
     * to expose an API key.
     *
     * @param runId - The ID of the run.
     * @param feedbackKey - The feedback key.
     * @param options - Additional options for the token.
     * @param options.expiration - The expiration time for the token.
     *
     * @returns A promise that resolves to a FeedbackIngestToken.
     */
  }, {
    key: "createPresignedFeedbackToken",
    value: (function () {
      var _createPresignedFeedbackToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee70(runId, feedbackKey) {
        var _ref43,
          expiration,
          feedbackConfig,
          body,
          response,
          result,
          _args70 = arguments;
        return _regeneratorRuntime().wrap(function _callee70$(_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              _ref43 = _args70.length > 2 && _args70[2] !== undefined ? _args70[2] : {}, expiration = _ref43.expiration, feedbackConfig = _ref43.feedbackConfig;
              body = {
                run_id: runId,
                feedback_key: feedbackKey,
                feedback_config: feedbackConfig
              };
              if (expiration) {
                if (typeof expiration === "string") {
                  body["expires_at"] = expiration;
                } else if (expiration !== null && expiration !== void 0 && expiration.hours || expiration !== null && expiration !== void 0 && expiration.minutes || expiration !== null && expiration !== void 0 && expiration.days) {
                  body["expires_in"] = expiration;
                }
              } else {
                body["expires_in"] = {
                  hours: 3
                };
              }
              _context70.next = 5;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/feedback/tokens"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(body),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 5:
              response = _context70.sent;
              _context70.next = 8;
              return response.json();
            case 8:
              result = _context70.sent;
              return _context70.abrupt("return", result);
            case 10:
            case "end":
              return _context70.stop();
          }
        }, _callee70, this);
      }));
      function createPresignedFeedbackToken(_x80, _x81) {
        return _createPresignedFeedbackToken.apply(this, arguments);
      }
      return createPresignedFeedbackToken;
    }())
  }, {
    key: "createComparativeExperiment",
    value: function () {
      var _createComparativeExperiment = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee71(_ref44) {
        var _ref45;
        var name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, body, response;
        return _regeneratorRuntime().wrap(function _callee71$(_context71) {
          while (1) switch (_context71.prev = _context71.next) {
            case 0:
              name = _ref44.name, experimentIds = _ref44.experimentIds, referenceDatasetId = _ref44.referenceDatasetId, createdAt = _ref44.createdAt, description = _ref44.description, metadata = _ref44.metadata, id = _ref44.id;
              if (!(experimentIds.length === 0)) {
                _context71.next = 3;
                break;
              }
              throw new Error("At least one experiment is required");
            case 3:
              if (referenceDatasetId) {
                _context71.next = 7;
                break;
              }
              _context71.next = 6;
              return this.readProject({
                projectId: experimentIds[0]
              });
            case 6:
              referenceDatasetId = _context71.sent.reference_dataset_id;
            case 7:
              if (!(!referenceDatasetId == null)) {
                _context71.next = 9;
                break;
              }
              throw new Error("A reference dataset is required");
            case 9:
              body = {
                id: id,
                name: name,
                experiment_ids: experimentIds,
                reference_dataset_id: referenceDatasetId,
                description: description,
                created_at: (_ref45 = createdAt !== null && createdAt !== void 0 ? createdAt : new Date()) === null || _ref45 === void 0 ? void 0 : _ref45.toISOString(),
                extra: {}
              };
              if (metadata) body.extra["metadata"] = metadata;
              _context71.next = 13;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/datasets/comparative"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(body),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 13:
              response = _context71.sent;
              _context71.next = 16;
              return response.json();
            case 16:
              return _context71.abrupt("return", _context71.sent);
            case 17:
            case "end":
              return _context71.stop();
          }
        }, _callee71, this);
      }));
      function createComparativeExperiment(_x82) {
        return _createComparativeExperiment.apply(this, arguments);
      }
      return createComparativeExperiment;
    }()
    /**
     * Retrieves a list of presigned feedback tokens for a given run ID.
     * @param runId The ID of the run.
     * @returns An async iterable of FeedbackIngestToken objects.
     */
  }, {
    key: "listPresignedFeedbackTokens",
    value: function listPresignedFeedbackTokens(runId) {
      var _this8 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee72() {
        var params, _iteratorAbruptCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, tokens;
        return _regeneratorRuntime().wrap(function _callee72$(_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);
              params = new URLSearchParams({
                run_id: runId
              });
              _iteratorAbruptCompletion8 = false;
              _didIteratorError8 = false;
              _context72.prev = 4;
              _iterator8 = _asyncIterator(_this8._getPaginated("/feedback/tokens", params));
            case 6:
              _context72.next = 8;
              return _awaitAsyncGenerator(_iterator8.next());
            case 8:
              if (!(_iteratorAbruptCompletion8 = !(_step8 = _context72.sent).done)) {
                _context72.next = 14;
                break;
              }
              tokens = _step8.value;
              return _context72.delegateYield(_asyncGeneratorDelegate(_asyncIterator(tokens), _awaitAsyncGenerator), "t0", 11);
            case 11:
              _iteratorAbruptCompletion8 = false;
              _context72.next = 6;
              break;
            case 14:
              _context72.next = 20;
              break;
            case 16:
              _context72.prev = 16;
              _context72.t1 = _context72["catch"](4);
              _didIteratorError8 = true;
              _iteratorError8 = _context72.t1;
            case 20:
              _context72.prev = 20;
              _context72.prev = 21;
              if (!(_iteratorAbruptCompletion8 && _iterator8["return"] != null)) {
                _context72.next = 25;
                break;
              }
              _context72.next = 25;
              return _awaitAsyncGenerator(_iterator8["return"]());
            case 25:
              _context72.prev = 25;
              if (!_didIteratorError8) {
                _context72.next = 28;
                break;
              }
              throw _iteratorError8;
            case 28:
              return _context72.finish(25);
            case 29:
              return _context72.finish(20);
            case 30:
            case "end":
              return _context72.stop();
          }
        }, _callee72, null, [[4, 16, 20, 30], [21,, 25, 29]]);
      }))();
    }
  }, {
    key: "_selectEvalResults",
    value: function _selectEvalResults(results) {
      var results_;
      if ("results" in results) {
        results_ = results.results;
      } else {
        results_ = [results];
      }
      return results_;
    }
  }, {
    key: "_logEvaluationFeedback",
    value: function () {
      var _logEvaluationFeedback2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee73(evaluatorResponse, run, sourceInfo) {
        var evalResults, feedbacks, _iterator29, _step29, res, sourceInfo_, runId_;
        return _regeneratorRuntime().wrap(function _callee73$(_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              evalResults = this._selectEvalResults(evaluatorResponse);
              feedbacks = [];
              _iterator29 = _createForOfIteratorHelper(evalResults);
              _context73.prev = 3;
              _iterator29.s();
            case 5:
              if ((_step29 = _iterator29.n()).done) {
                _context73.next = 18;
                break;
              }
              res = _step29.value;
              sourceInfo_ = sourceInfo || {};
              if (res.evaluatorInfo) {
                sourceInfo_ = _objectSpread(_objectSpread({}, res.evaluatorInfo), sourceInfo_);
              }
              runId_ = null;
              if (res.targetRunId) {
                runId_ = res.targetRunId;
              } else if (run) {
                runId_ = run.id;
              }
              _context73.t0 = feedbacks;
              _context73.next = 14;
              return this.createFeedback(runId_, res.key, {
                score: res.score,
                value: res.value,
                comment: res.comment,
                correction: res.correction,
                sourceInfo: sourceInfo_,
                sourceRunId: res.sourceRunId,
                feedbackConfig: res.feedbackConfig,
                feedbackSourceType: "model"
              });
            case 14:
              _context73.t1 = _context73.sent;
              _context73.t0.push.call(_context73.t0, _context73.t1);
            case 16:
              _context73.next = 5;
              break;
            case 18:
              _context73.next = 23;
              break;
            case 20:
              _context73.prev = 20;
              _context73.t2 = _context73["catch"](3);
              _iterator29.e(_context73.t2);
            case 23:
              _context73.prev = 23;
              _iterator29.f();
              return _context73.finish(23);
            case 26:
              return _context73.abrupt("return", [evalResults, feedbacks]);
            case 27:
            case "end":
              return _context73.stop();
          }
        }, _callee73, this, [[3, 20, 23, 26]]);
      }));
      function _logEvaluationFeedback(_x83, _x84, _x85) {
        return _logEvaluationFeedback2.apply(this, arguments);
      }
      return _logEvaluationFeedback;
    }()
  }, {
    key: "logEvaluationFeedback",
    value: function () {
      var _logEvaluationFeedback3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee74(evaluatorResponse, run, sourceInfo) {
        var _yield$this$_logEvalu3, _yield$this$_logEvalu4, results;
        return _regeneratorRuntime().wrap(function _callee74$(_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              _context74.next = 2;
              return this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
            case 2:
              _yield$this$_logEvalu3 = _context74.sent;
              _yield$this$_logEvalu4 = _slicedToArray(_yield$this$_logEvalu3, 1);
              results = _yield$this$_logEvalu4[0];
              return _context74.abrupt("return", results);
            case 6:
            case "end":
              return _context74.stop();
          }
        }, _callee74, this);
      }));
      function logEvaluationFeedback(_x86, _x87, _x88) {
        return _logEvaluationFeedback3.apply(this, arguments);
      }
      return logEvaluationFeedback;
    }()
    /**
     * API for managing annotation queues
     */
    /**
     * List the annotation queues on the LangSmith API.
     * @param options - The options for listing annotation queues
     * @param options.queueIds - The IDs of the queues to filter by
     * @param options.name - The name of the queue to filter by
     * @param options.nameContains - The substring that the queue name should contain
     * @param options.limit - The maximum number of queues to return
     * @returns An iterator of AnnotationQueue objects
     */
  }, {
    key: "listAnnotationQueues",
    value: function listAnnotationQueues() {
      var _this9 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee75() {
        var queueIds, name, nameContains, limit, params, count, _iteratorAbruptCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, queues;
        return _regeneratorRuntime().wrap(function _callee75$(_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              queueIds = options.queueIds, name = options.name, nameContains = options.nameContains, limit = options.limit;
              params = new URLSearchParams();
              if (queueIds) {
                queueIds.forEach(function (id, i) {
                  (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, "queueIds[".concat(i, "]"));
                  params.append("ids", id);
                });
              }
              if (name) params.append("name", name);
              if (nameContains) params.append("name_contains", nameContains);
              params.append("limit", (limit !== undefined ? Math.min(limit, 100) : 100).toString());
              count = 0;
              _iteratorAbruptCompletion9 = false;
              _didIteratorError9 = false;
              _context75.prev = 9;
              _iterator9 = _asyncIterator(_this9._getPaginated("/annotation-queues", params));
            case 11:
              _context75.next = 13;
              return _awaitAsyncGenerator(_iterator9.next());
            case 13:
              if (!(_iteratorAbruptCompletion9 = !(_step9 = _context75.sent).done)) {
                _context75.next = 22;
                break;
              }
              queues = _step9.value;
              return _context75.delegateYield(_asyncGeneratorDelegate(_asyncIterator(queues), _awaitAsyncGenerator), "t0", 16);
            case 16:
              count++;
              if (!(limit !== undefined && count >= limit)) {
                _context75.next = 19;
                break;
              }
              return _context75.abrupt("break", 22);
            case 19:
              _iteratorAbruptCompletion9 = false;
              _context75.next = 11;
              break;
            case 22:
              _context75.next = 28;
              break;
            case 24:
              _context75.prev = 24;
              _context75.t1 = _context75["catch"](9);
              _didIteratorError9 = true;
              _iteratorError9 = _context75.t1;
            case 28:
              _context75.prev = 28;
              _context75.prev = 29;
              if (!(_iteratorAbruptCompletion9 && _iterator9["return"] != null)) {
                _context75.next = 33;
                break;
              }
              _context75.next = 33;
              return _awaitAsyncGenerator(_iterator9["return"]());
            case 33:
              _context75.prev = 33;
              if (!_didIteratorError9) {
                _context75.next = 36;
                break;
              }
              throw _iteratorError9;
            case 36:
              return _context75.finish(33);
            case 37:
              return _context75.finish(28);
            case 38:
            case "end":
              return _context75.stop();
          }
        }, _callee75, null, [[9, 24, 28, 38], [29,, 33, 37]]);
      }))();
    }
    /**
     * Create an annotation queue on the LangSmith API.
     * @param options - The options for creating an annotation queue
     * @param options.name - The name of the annotation queue
     * @param options.description - The description of the annotation queue
     * @param options.queueId - The ID of the annotation queue
     * @returns The created AnnotationQueue object
     */
  }, {
    key: "createAnnotationQueue",
    value: (function () {
      var _createAnnotationQueue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee76(options) {
        var name, description, queueId, body, response, data;
        return _regeneratorRuntime().wrap(function _callee76$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              name = options.name, description = options.description, queueId = options.queueId;
              body = {
                name: name,
                description: description,
                id: queueId || uuid__WEBPACK_IMPORTED_MODULE_10__["default"]()
              };
              _context76.next = 4;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/annotation-queues"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(function (_ref46) {
                  var _ref47 = _slicedToArray(_ref46, 2),
                    _ = _ref47[0],
                    v = _ref47[1];
                  return v !== undefined;
                }))),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 4:
              response = _context76.sent;
              _context76.next = 7;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create annotation queue");
            case 7:
              _context76.next = 9;
              return response.json();
            case 9:
              data = _context76.sent;
              return _context76.abrupt("return", data);
            case 11:
            case "end":
              return _context76.stop();
          }
        }, _callee76, this);
      }));
      function createAnnotationQueue(_x89) {
        return _createAnnotationQueue.apply(this, arguments);
      }
      return createAnnotationQueue;
    }()
    /**
     * Read an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue to read
     * @returns The AnnotationQueue object
     */
    )
  }, {
    key: "readAnnotationQueue",
    value: (function () {
      var _readAnnotationQueue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee77(queueId) {
        var queueIteratorResult;
        return _regeneratorRuntime().wrap(function _callee77$(_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              _context77.next = 2;
              return this.listAnnotationQueues({
                queueIds: [queueId]
              }).next();
            case 2:
              queueIteratorResult = _context77.sent;
              if (!queueIteratorResult.done) {
                _context77.next = 5;
                break;
              }
              throw new Error("Annotation queue with ID ".concat(queueId, " not found"));
            case 5:
              return _context77.abrupt("return", queueIteratorResult.value);
            case 6:
            case "end":
              return _context77.stop();
          }
        }, _callee77, this);
      }));
      function readAnnotationQueue(_x90) {
        return _readAnnotationQueue.apply(this, arguments);
      }
      return readAnnotationQueue;
    }()
    /**
     * Update an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue to update
     * @param options - The options for updating the annotation queue
     * @param options.name - The new name for the annotation queue
     * @param options.description - The new description for the annotation queue
     */
    )
  }, {
    key: "updateAnnotationQueue",
    value: (function () {
      var _updateAnnotationQueue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee78(queueId, options) {
        var name, description, response;
        return _regeneratorRuntime().wrap(function _callee78$(_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              name = options.name, description = options.description;
              _context78.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/annotation-queues/").concat((0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, "queueId")), _objectSpread({
                method: "PATCH",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify({
                  name: name,
                  description: description
                }),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context78.sent;
              _context78.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update annotation queue");
            case 6:
            case "end":
              return _context78.stop();
          }
        }, _callee78, this);
      }));
      function updateAnnotationQueue(_x91, _x92) {
        return _updateAnnotationQueue.apply(this, arguments);
      }
      return updateAnnotationQueue;
    }()
    /**
     * Delete an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue to delete
     */
    )
  }, {
    key: "deleteAnnotationQueue",
    value: (function () {
      var _deleteAnnotationQueue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee79(queueId) {
        var response;
        return _regeneratorRuntime().wrap(function _callee79$(_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              _context79.next = 2;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/annotation-queues/").concat((0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, "queueId")), _objectSpread({
                method: "DELETE",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  Accept: "application/json"
                }),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 2:
              response = _context79.sent;
              _context79.next = 5;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "delete annotation queue");
            case 5:
            case "end":
              return _context79.stop();
          }
        }, _callee79, this);
      }));
      function deleteAnnotationQueue(_x93) {
        return _deleteAnnotationQueue.apply(this, arguments);
      }
      return deleteAnnotationQueue;
    }()
    /**
     * Add runs to an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue
     * @param runIds - The IDs of the runs to be added to the annotation queue
     */
    )
  }, {
    key: "addRunsToAnnotationQueue",
    value: (function () {
      var _addRunsToAnnotationQueue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee80(queueId, runIds) {
        var response;
        return _regeneratorRuntime().wrap(function _callee80$(_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              _context80.next = 2;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/annotation-queues/").concat((0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, "queueId"), "/runs"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(runIds.map(function (id, i) {
                  return (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, "runIds[".concat(i, "]")).toString();
                })),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 2:
              response = _context80.sent;
              _context80.next = 5;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "add runs to annotation queue");
            case 5:
            case "end":
              return _context80.stop();
          }
        }, _callee80, this);
      }));
      function addRunsToAnnotationQueue(_x94, _x95) {
        return _addRunsToAnnotationQueue.apply(this, arguments);
      }
      return addRunsToAnnotationQueue;
    }()
    /**
     * Get a run from an annotation queue at the specified index.
     * @param queueId - The ID of the annotation queue
     * @param index - The index of the run to retrieve
     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
     * @throws {Error} If the run is not found at the given index or for other API-related errors
     */
    )
  }, {
    key: "getRunFromAnnotationQueue",
    value: (function () {
      var _getRunFromAnnotationQueue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee81(queueId, index) {
        var baseUrl, response;
        return _regeneratorRuntime().wrap(function _callee81$(_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              baseUrl = "/annotation-queues/".concat((0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, "queueId"), "/run");
              _context81.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl).concat(baseUrl, "/").concat(index), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context81.sent;
              _context81.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "get run from annotation queue");
            case 6:
              _context81.next = 8;
              return response.json();
            case 8:
              return _context81.abrupt("return", _context81.sent);
            case 9:
            case "end":
              return _context81.stop();
          }
        }, _callee81, this);
      }));
      function getRunFromAnnotationQueue(_x96, _x97) {
        return _getRunFromAnnotationQueue.apply(this, arguments);
      }
      return getRunFromAnnotationQueue;
    }())
  }, {
    key: "_currentTenantIsOwner",
    value: function () {
      var _currentTenantIsOwner2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee82(owner) {
        var settings;
        return _regeneratorRuntime().wrap(function _callee82$(_context82) {
          while (1) switch (_context82.prev = _context82.next) {
            case 0:
              _context82.next = 2;
              return this._getSettings();
            case 2:
              settings = _context82.sent;
              return _context82.abrupt("return", owner == "-" || settings.tenant_handle === owner);
            case 4:
            case "end":
              return _context82.stop();
          }
        }, _callee82, this);
      }));
      function _currentTenantIsOwner(_x98) {
        return _currentTenantIsOwner2.apply(this, arguments);
      }
      return _currentTenantIsOwner;
    }()
  }, {
    key: "_ownerConflictError",
    value: function () {
      var _ownerConflictError2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee83(action, owner) {
        var settings;
        return _regeneratorRuntime().wrap(function _callee83$(_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              _context83.next = 2;
              return this._getSettings();
            case 2:
              settings = _context83.sent;
              return _context83.abrupt("return", new Error("Cannot ".concat(action, " for another tenant.\n\n      Current tenant: ").concat(settings.tenant_handle, "\n\n      Requested tenant: ").concat(owner)));
            case 4:
            case "end":
              return _context83.stop();
          }
        }, _callee83, this);
      }));
      function _ownerConflictError(_x99, _x100) {
        return _ownerConflictError2.apply(this, arguments);
      }
      return _ownerConflictError;
    }()
  }, {
    key: "_getLatestCommitHash",
    value: function () {
      var _getLatestCommitHash2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee84(promptOwnerAndName) {
        var res, json, detail, error;
        return _regeneratorRuntime().wrap(function _callee84$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              _context84.next = 2;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/commits/").concat(promptOwnerAndName, "/?limit=", 1, "&offset=", 0), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 2:
              res = _context84.sent;
              _context84.next = 5;
              return res.json();
            case 5:
              json = _context84.sent;
              if (res.ok) {
                _context84.next = 11;
                break;
              }
              detail = typeof json.detail === "string" ? json.detail : JSON.stringify(json.detail);
              error = new Error("Error ".concat(res.status, ": ").concat(res.statusText, "\n").concat(detail)); // eslint-disable-next-line @typescript-eslint/no-explicit-any
              error.statusCode = res.status;
              throw error;
            case 11:
              if (!(json.commits.length === 0)) {
                _context84.next = 13;
                break;
              }
              return _context84.abrupt("return", undefined);
            case 13:
              return _context84.abrupt("return", json.commits[0].commit_hash);
            case 14:
            case "end":
              return _context84.stop();
          }
        }, _callee84, this);
      }));
      function _getLatestCommitHash(_x101) {
        return _getLatestCommitHash2.apply(this, arguments);
      }
      return _getLatestCommitHash;
    }()
  }, {
    key: "_likeOrUnlikePrompt",
    value: function () {
      var _likeOrUnlikePrompt2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee85(promptIdentifier, like) {
        var _parsePromptIdentifie, _parsePromptIdentifie2, owner, promptName, _, response;
        return _regeneratorRuntime().wrap(function _callee85$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              _parsePromptIdentifie = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie2 = _slicedToArray(_parsePromptIdentifie, 3), owner = _parsePromptIdentifie2[0], promptName = _parsePromptIdentifie2[1], _ = _parsePromptIdentifie2[2];
              _context85.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/likes/").concat(owner, "/").concat(promptName), _objectSpread({
                method: "POST",
                body: JSON.stringify({
                  like: like
                }),
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context85.sent;
              _context85.next = 6;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "".concat(like ? "like" : "unlike", " prompt"));
            case 6:
              _context85.next = 8;
              return response.json();
            case 8:
              return _context85.abrupt("return", _context85.sent);
            case 9:
            case "end":
              return _context85.stop();
          }
        }, _callee85, this);
      }));
      function _likeOrUnlikePrompt(_x102, _x103) {
        return _likeOrUnlikePrompt2.apply(this, arguments);
      }
      return _likeOrUnlikePrompt;
    }()
  }, {
    key: "_getPromptUrl",
    value: function () {
      var _getPromptUrl2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee86(promptIdentifier) {
        var _parsePromptIdentifie3, _parsePromptIdentifie4, owner, promptName, commitHash, settings;
        return _regeneratorRuntime().wrap(function _callee86$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              _parsePromptIdentifie3 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie4 = _slicedToArray(_parsePromptIdentifie3, 3), owner = _parsePromptIdentifie4[0], promptName = _parsePromptIdentifie4[1], commitHash = _parsePromptIdentifie4[2];
              _context86.next = 3;
              return this._currentTenantIsOwner(owner);
            case 3:
              if (_context86.sent) {
                _context86.next = 11;
                break;
              }
              if (!(commitHash !== "latest")) {
                _context86.next = 8;
                break;
              }
              return _context86.abrupt("return", "".concat(this.getHostUrl(), "/hub/").concat(owner, "/").concat(promptName, "/").concat(commitHash.substring(0, 8)));
            case 8:
              return _context86.abrupt("return", "".concat(this.getHostUrl(), "/hub/").concat(owner, "/").concat(promptName));
            case 9:
              _context86.next = 19;
              break;
            case 11:
              _context86.next = 13;
              return this._getSettings();
            case 13:
              settings = _context86.sent;
              if (!(commitHash !== "latest")) {
                _context86.next = 18;
                break;
              }
              return _context86.abrupt("return", "".concat(this.getHostUrl(), "/prompts/").concat(promptName, "/").concat(commitHash.substring(0, 8), "?organizationId=").concat(settings.id));
            case 18:
              return _context86.abrupt("return", "".concat(this.getHostUrl(), "/prompts/").concat(promptName, "?organizationId=").concat(settings.id));
            case 19:
            case "end":
              return _context86.stop();
          }
        }, _callee86, this);
      }));
      function _getPromptUrl(_x104) {
        return _getPromptUrl2.apply(this, arguments);
      }
      return _getPromptUrl;
    }()
  }, {
    key: "promptExists",
    value: function () {
      var _promptExists = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee87(promptIdentifier) {
        var prompt;
        return _regeneratorRuntime().wrap(function _callee87$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              _context87.next = 2;
              return this.getPrompt(promptIdentifier);
            case 2:
              prompt = _context87.sent;
              return _context87.abrupt("return", !!prompt);
            case 4:
            case "end":
              return _context87.stop();
          }
        }, _callee87, this);
      }));
      function promptExists(_x105) {
        return _promptExists.apply(this, arguments);
      }
      return promptExists;
    }()
  }, {
    key: "likePrompt",
    value: function () {
      var _likePrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee88(promptIdentifier) {
        return _regeneratorRuntime().wrap(function _callee88$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              return _context88.abrupt("return", this._likeOrUnlikePrompt(promptIdentifier, true));
            case 1:
            case "end":
              return _context88.stop();
          }
        }, _callee88, this);
      }));
      function likePrompt(_x106) {
        return _likePrompt.apply(this, arguments);
      }
      return likePrompt;
    }()
  }, {
    key: "unlikePrompt",
    value: function () {
      var _unlikePrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee89(promptIdentifier) {
        return _regeneratorRuntime().wrap(function _callee89$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              return _context89.abrupt("return", this._likeOrUnlikePrompt(promptIdentifier, false));
            case 1:
            case "end":
              return _context89.stop();
          }
        }, _callee89, this);
      }));
      function unlikePrompt(_x107) {
        return _unlikePrompt.apply(this, arguments);
      }
      return unlikePrompt;
    }()
  }, {
    key: "listCommits",
    value: function listCommits(promptOwnerAndName) {
      var _this10 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee90() {
        var _iteratorAbruptCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, commits;
        return _regeneratorRuntime().wrap(function _callee90$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              _iteratorAbruptCompletion10 = false;
              _didIteratorError10 = false;
              _context90.prev = 2;
              _iterator10 = _asyncIterator(_this10._getPaginated("/commits/".concat(promptOwnerAndName, "/"), new URLSearchParams(), function (res) {
                return res.commits;
              }));
            case 4:
              _context90.next = 6;
              return _awaitAsyncGenerator(_iterator10.next());
            case 6:
              if (!(_iteratorAbruptCompletion10 = !(_step10 = _context90.sent).done)) {
                _context90.next = 12;
                break;
              }
              commits = _step10.value;
              return _context90.delegateYield(_asyncGeneratorDelegate(_asyncIterator(commits), _awaitAsyncGenerator), "t0", 9);
            case 9:
              _iteratorAbruptCompletion10 = false;
              _context90.next = 4;
              break;
            case 12:
              _context90.next = 18;
              break;
            case 14:
              _context90.prev = 14;
              _context90.t1 = _context90["catch"](2);
              _didIteratorError10 = true;
              _iteratorError10 = _context90.t1;
            case 18:
              _context90.prev = 18;
              _context90.prev = 19;
              if (!(_iteratorAbruptCompletion10 && _iterator10["return"] != null)) {
                _context90.next = 23;
                break;
              }
              _context90.next = 23;
              return _awaitAsyncGenerator(_iterator10["return"]());
            case 23:
              _context90.prev = 23;
              if (!_didIteratorError10) {
                _context90.next = 26;
                break;
              }
              throw _iteratorError10;
            case 26:
              return _context90.finish(23);
            case 27:
              return _context90.finish(18);
            case 28:
            case "end":
              return _context90.stop();
          }
        }, _callee90, null, [[2, 14, 18, 28], [19,, 23, 27]]);
      }))();
    }
  }, {
    key: "listPrompts",
    value: function listPrompts(options) {
      var _this11 = this;
      return _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee91() {
        var _options$sortField;
        var params, _iteratorAbruptCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, prompts;
        return _regeneratorRuntime().wrap(function _callee91$(_context91) {
          while (1) switch (_context91.prev = _context91.next) {
            case 0:
              params = new URLSearchParams();
              params.append("sort_field", (_options$sortField = options === null || options === void 0 ? void 0 : options.sortField) !== null && _options$sortField !== void 0 ? _options$sortField : "updated_at");
              params.append("sort_direction", "desc");
              params.append("is_archived", (!!(options !== null && options !== void 0 && options.isArchived)).toString());
              if ((options === null || options === void 0 ? void 0 : options.isPublic) !== undefined) {
                params.append("is_public", options.isPublic.toString());
              }
              if (options !== null && options !== void 0 && options.query) {
                params.append("query", options.query);
              }
              _iteratorAbruptCompletion11 = false;
              _didIteratorError11 = false;
              _context91.prev = 8;
              _iterator11 = _asyncIterator(_this11._getPaginated("/repos", params, function (res) {
                return res.repos;
              }));
            case 10:
              _context91.next = 12;
              return _awaitAsyncGenerator(_iterator11.next());
            case 12:
              if (!(_iteratorAbruptCompletion11 = !(_step11 = _context91.sent).done)) {
                _context91.next = 18;
                break;
              }
              prompts = _step11.value;
              return _context91.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prompts), _awaitAsyncGenerator), "t0", 15);
            case 15:
              _iteratorAbruptCompletion11 = false;
              _context91.next = 10;
              break;
            case 18:
              _context91.next = 24;
              break;
            case 20:
              _context91.prev = 20;
              _context91.t1 = _context91["catch"](8);
              _didIteratorError11 = true;
              _iteratorError11 = _context91.t1;
            case 24:
              _context91.prev = 24;
              _context91.prev = 25;
              if (!(_iteratorAbruptCompletion11 && _iterator11["return"] != null)) {
                _context91.next = 29;
                break;
              }
              _context91.next = 29;
              return _awaitAsyncGenerator(_iterator11["return"]());
            case 29:
              _context91.prev = 29;
              if (!_didIteratorError11) {
                _context91.next = 32;
                break;
              }
              throw _iteratorError11;
            case 32:
              return _context91.finish(29);
            case 33:
              return _context91.finish(24);
            case 34:
            case "end":
              return _context91.stop();
          }
        }, _callee91, null, [[8, 20, 24, 34], [25,, 29, 33]]);
      }))();
    }
  }, {
    key: "getPrompt",
    value: function () {
      var _getPrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee92(promptIdentifier) {
        var _parsePromptIdentifie5, _parsePromptIdentifie6, owner, promptName, _, response, result;
        return _regeneratorRuntime().wrap(function _callee92$(_context92) {
          while (1) switch (_context92.prev = _context92.next) {
            case 0:
              _parsePromptIdentifie5 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie6 = _slicedToArray(_parsePromptIdentifie5, 3), owner = _parsePromptIdentifie6[0], promptName = _parsePromptIdentifie6[1], _ = _parsePromptIdentifie6[2];
              _context92.next = 3;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/repos/").concat(owner, "/").concat(promptName), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 3:
              response = _context92.sent;
              if (!(response.status === 404)) {
                _context92.next = 6;
                break;
              }
              return _context92.abrupt("return", null);
            case 6:
              _context92.next = 8;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "get prompt");
            case 8:
              _context92.next = 10;
              return response.json();
            case 10:
              result = _context92.sent;
              if (!result.repo) {
                _context92.next = 15;
                break;
              }
              return _context92.abrupt("return", result.repo);
            case 15:
              return _context92.abrupt("return", null);
            case 16:
            case "end":
              return _context92.stop();
          }
        }, _callee92, this);
      }));
      function getPrompt(_x108) {
        return _getPrompt.apply(this, arguments);
      }
      return getPrompt;
    }()
  }, {
    key: "createPrompt",
    value: function () {
      var _createPrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee93(promptIdentifier, options) {
        var settings, _parsePromptIdentifie7, _parsePromptIdentifie8, owner, promptName, _, data, response, _yield$response$json, repo;
        return _regeneratorRuntime().wrap(function _callee93$(_context93) {
          while (1) switch (_context93.prev = _context93.next) {
            case 0:
              _context93.next = 2;
              return this._getSettings();
            case 2:
              settings = _context93.sent;
              if (!(options !== null && options !== void 0 && options.isPublic && !settings.tenant_handle)) {
                _context93.next = 5;
                break;
              }
              throw new Error("Cannot create a public prompt without first\n\n        creating a LangChain Hub handle. \n        You can add a handle by creating a public prompt at:\n\n        https://smith.langchain.com/prompts");
            case 5:
              _parsePromptIdentifie7 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie8 = _slicedToArray(_parsePromptIdentifie7, 3), owner = _parsePromptIdentifie8[0], promptName = _parsePromptIdentifie8[1], _ = _parsePromptIdentifie8[2];
              _context93.next = 8;
              return this._currentTenantIsOwner(owner);
            case 8:
              if (_context93.sent) {
                _context93.next = 12;
                break;
              }
              _context93.next = 11;
              return this._ownerConflictError("create a prompt", owner);
            case 11:
              throw _context93.sent;
            case 12:
              data = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
                repo_handle: promptName
              }, (options === null || options === void 0 ? void 0 : options.description) && {
                description: options.description
              }), (options === null || options === void 0 ? void 0 : options.readme) && {
                readme: options.readme
              }), (options === null || options === void 0 ? void 0 : options.tags) && {
                tags: options.tags
              }), {}, {
                is_public: !!(options !== null && options !== void 0 && options.isPublic)
              });
              _context93.next = 15;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/repos/"), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 15:
              response = _context93.sent;
              _context93.next = 18;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create prompt");
            case 18:
              _context93.next = 20;
              return response.json();
            case 20:
              _yield$response$json = _context93.sent;
              repo = _yield$response$json.repo;
              return _context93.abrupt("return", repo);
            case 23:
            case "end":
              return _context93.stop();
          }
        }, _callee93, this);
      }));
      function createPrompt(_x109, _x110) {
        return _createPrompt.apply(this, arguments);
      }
      return createPrompt;
    }()
  }, {
    key: "createCommit",
    value: function () {
      var _createCommit = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee94(promptIdentifier, object, options) {
        var _parsePromptIdentifie9, _parsePromptIdentifie10, owner, promptName, _, resolvedParentCommitHash, payload, response, result;
        return _regeneratorRuntime().wrap(function _callee94$(_context94) {
          while (1) switch (_context94.prev = _context94.next) {
            case 0:
              _context94.next = 2;
              return this.promptExists(promptIdentifier);
            case 2:
              if (_context94.sent) {
                _context94.next = 4;
                break;
              }
              throw new Error("Prompt does not exist, you must create it first.");
            case 4:
              _parsePromptIdentifie9 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie10 = _slicedToArray(_parsePromptIdentifie9, 3), owner = _parsePromptIdentifie10[0], promptName = _parsePromptIdentifie10[1], _ = _parsePromptIdentifie10[2];
              if (!((options === null || options === void 0 ? void 0 : options.parentCommitHash) === "latest" || !(options !== null && options !== void 0 && options.parentCommitHash))) {
                _context94.next = 11;
                break;
              }
              _context94.next = 8;
              return this._getLatestCommitHash("".concat(owner, "/").concat(promptName));
            case 8:
              _context94.t0 = _context94.sent;
              _context94.next = 12;
              break;
            case 11:
              _context94.t0 = options === null || options === void 0 ? void 0 : options.parentCommitHash;
            case 12:
              resolvedParentCommitHash = _context94.t0;
              payload = {
                manifest: JSON.parse(JSON.stringify(object)),
                parent_commit: resolvedParentCommitHash
              };
              _context94.next = 16;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/commits/").concat(owner, "/").concat(promptName), _objectSpread({
                method: "POST",
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                body: JSON.stringify(payload),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 16:
              response = _context94.sent;
              _context94.next = 19;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "create commit");
            case 19:
              _context94.next = 21;
              return response.json();
            case 21:
              result = _context94.sent;
              return _context94.abrupt("return", this._getPromptUrl("".concat(owner, "/").concat(promptName).concat(result.commit_hash ? ":".concat(result.commit_hash) : "")));
            case 23:
            case "end":
              return _context94.stop();
          }
        }, _callee94, this);
      }));
      function createCommit(_x111, _x112, _x113) {
        return _createCommit.apply(this, arguments);
      }
      return createCommit;
    }()
  }, {
    key: "updatePrompt",
    value: function () {
      var _updatePrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee95(promptIdentifier, options) {
        var _parsePromptIdentifie11, _parsePromptIdentifie12, owner, promptName, payload, response;
        return _regeneratorRuntime().wrap(function _callee95$(_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              _context95.next = 2;
              return this.promptExists(promptIdentifier);
            case 2:
              if (_context95.sent) {
                _context95.next = 4;
                break;
              }
              throw new Error("Prompt does not exist, you must create it first.");
            case 4:
              _parsePromptIdentifie11 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie12 = _slicedToArray(_parsePromptIdentifie11, 2), owner = _parsePromptIdentifie12[0], promptName = _parsePromptIdentifie12[1];
              _context95.next = 7;
              return this._currentTenantIsOwner(owner);
            case 7:
              if (_context95.sent) {
                _context95.next = 11;
                break;
              }
              _context95.next = 10;
              return this._ownerConflictError("update a prompt", owner);
            case 10:
              throw _context95.sent;
            case 11:
              payload = {};
              if ((options === null || options === void 0 ? void 0 : options.description) !== undefined) payload.description = options.description;
              if ((options === null || options === void 0 ? void 0 : options.readme) !== undefined) payload.readme = options.readme;
              if ((options === null || options === void 0 ? void 0 : options.tags) !== undefined) payload.tags = options.tags;
              if ((options === null || options === void 0 ? void 0 : options.isPublic) !== undefined) payload.is_public = options.isPublic;
              if ((options === null || options === void 0 ? void 0 : options.isArchived) !== undefined) payload.is_archived = options.isArchived;
              // Check if payload is empty
              if (!(Object.keys(payload).length === 0)) {
                _context95.next = 19;
                break;
              }
              throw new Error("No valid update options provided");
            case 19:
              _context95.next = 21;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/repos/").concat(owner, "/").concat(promptName), _objectSpread({
                method: "PATCH",
                body: JSON.stringify(payload),
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  "Content-Type": "application/json"
                }),
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 21:
              response = _context95.sent;
              _context95.next = 24;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "update prompt");
            case 24:
              return _context95.abrupt("return", response.json());
            case 25:
            case "end":
              return _context95.stop();
          }
        }, _callee95, this);
      }));
      function updatePrompt(_x114, _x115) {
        return _updatePrompt.apply(this, arguments);
      }
      return updatePrompt;
    }()
  }, {
    key: "deletePrompt",
    value: function () {
      var _deletePrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee96(promptIdentifier) {
        var _parsePromptIdentifie13, _parsePromptIdentifie14, owner, promptName, _, response;
        return _regeneratorRuntime().wrap(function _callee96$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              _context96.next = 2;
              return this.promptExists(promptIdentifier);
            case 2:
              if (_context96.sent) {
                _context96.next = 4;
                break;
              }
              throw new Error("Prompt does not exist, you must create it first.");
            case 4:
              _parsePromptIdentifie13 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie14 = _slicedToArray(_parsePromptIdentifie13, 3), owner = _parsePromptIdentifie14[0], promptName = _parsePromptIdentifie14[1], _ = _parsePromptIdentifie14[2];
              _context96.next = 7;
              return this._currentTenantIsOwner(owner);
            case 7:
              if (_context96.sent) {
                _context96.next = 11;
                break;
              }
              _context96.next = 10;
              return this._ownerConflictError("delete a prompt", owner);
            case 10:
              throw _context96.sent;
            case 11:
              _context96.next = 13;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/repos/").concat(owner, "/").concat(promptName), _objectSpread({
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 13:
              response = _context96.sent;
              _context96.next = 16;
              return response.json();
            case 16:
              return _context96.abrupt("return", _context96.sent);
            case 17:
            case "end":
              return _context96.stop();
          }
        }, _callee96, this);
      }));
      function deletePrompt(_x116) {
        return _deletePrompt.apply(this, arguments);
      }
      return deletePrompt;
    }()
  }, {
    key: "pullPromptCommit",
    value: function () {
      var _pullPromptCommit = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee97(promptIdentifier, options) {
        var _parsePromptIdentifie15, _parsePromptIdentifie16, owner, promptName, commitHash, serverInfo, useOptimization, passedCommitHash, latestCommitHash, response, result;
        return _regeneratorRuntime().wrap(function _callee97$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _parsePromptIdentifie15 = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier), _parsePromptIdentifie16 = _slicedToArray(_parsePromptIdentifie15, 3), owner = _parsePromptIdentifie16[0], promptName = _parsePromptIdentifie16[1], commitHash = _parsePromptIdentifie16[2];
              _context97.next = 3;
              return this._getServerInfo();
            case 3:
              serverInfo = _context97.sent;
              useOptimization = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.isVersionGreaterOrEqual)(serverInfo.version, "0.5.23");
              passedCommitHash = commitHash;
              if (!(!useOptimization && commitHash === "latest")) {
                _context97.next = 15;
                break;
              }
              _context97.next = 9;
              return this._getLatestCommitHash("".concat(owner, "/").concat(promptName));
            case 9:
              latestCommitHash = _context97.sent;
              if (latestCommitHash) {
                _context97.next = 14;
                break;
              }
              throw new Error("No commits found");
            case 14:
              passedCommitHash = latestCommitHash;
            case 15:
              _context97.next = 17;
              return this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), "".concat(this.apiUrl, "/commits/").concat(owner, "/").concat(promptName, "/").concat(passedCommitHash).concat(options !== null && options !== void 0 && options.includeModel ? "?include_model=true" : ""), _objectSpread({
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms)
              }, this.fetchOptions));
            case 17:
              response = _context97.sent;
              _context97.next = 20;
              return (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, "pull prompt commit");
            case 20:
              _context97.next = 22;
              return response.json();
            case 22:
              result = _context97.sent;
              return _context97.abrupt("return", {
                owner: owner,
                repo: promptName,
                commit_hash: result.commit_hash,
                manifest: result.manifest,
                examples: result.examples
              });
            case 24:
            case "end":
              return _context97.stop();
          }
        }, _callee97, this);
      }));
      function pullPromptCommit(_x117, _x118) {
        return _pullPromptCommit.apply(this, arguments);
      }
      return pullPromptCommit;
    }()
    /**
     * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
     * @private
     */
  }, {
    key: "_pullPrompt",
    value: (function () {
      var _pullPrompt2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee98(promptIdentifier, options) {
        var promptObject, prompt;
        return _regeneratorRuntime().wrap(function _callee98$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              _context98.next = 2;
              return this.pullPromptCommit(promptIdentifier, {
                includeModel: options === null || options === void 0 ? void 0 : options.includeModel
              });
            case 2:
              promptObject = _context98.sent;
              prompt = JSON.stringify(promptObject.manifest);
              return _context98.abrupt("return", prompt);
            case 5:
            case "end":
              return _context98.stop();
          }
        }, _callee98, this);
      }));
      function _pullPrompt(_x119, _x120) {
        return _pullPrompt2.apply(this, arguments);
      }
      return _pullPrompt;
    }())
  }, {
    key: "pushPrompt",
    value: function () {
      var _pushPrompt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee99(promptIdentifier, options) {
        var url;
        return _regeneratorRuntime().wrap(function _callee99$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              _context99.next = 2;
              return this.promptExists(promptIdentifier);
            case 2:
              if (!_context99.sent) {
                _context99.next = 8;
                break;
              }
              if (!(options && Object.keys(options).some(function (key) {
                return key !== "object";
              }))) {
                _context99.next = 6;
                break;
              }
              _context99.next = 6;
              return this.updatePrompt(promptIdentifier, {
                description: options === null || options === void 0 ? void 0 : options.description,
                readme: options === null || options === void 0 ? void 0 : options.readme,
                tags: options === null || options === void 0 ? void 0 : options.tags,
                isPublic: options === null || options === void 0 ? void 0 : options.isPublic
              });
            case 6:
              _context99.next = 10;
              break;
            case 8:
              _context99.next = 10;
              return this.createPrompt(promptIdentifier, {
                description: options === null || options === void 0 ? void 0 : options.description,
                readme: options === null || options === void 0 ? void 0 : options.readme,
                tags: options === null || options === void 0 ? void 0 : options.tags,
                isPublic: options === null || options === void 0 ? void 0 : options.isPublic
              });
            case 10:
              if (options !== null && options !== void 0 && options.object) {
                _context99.next = 14;
                break;
              }
              _context99.next = 13;
              return this._getPromptUrl(promptIdentifier);
            case 13:
              return _context99.abrupt("return", _context99.sent);
            case 14:
              _context99.next = 16;
              return this.createCommit(promptIdentifier, options === null || options === void 0 ? void 0 : options.object, {
                parentCommitHash: options === null || options === void 0 ? void 0 : options.parentCommitHash
              });
            case 16:
              url = _context99.sent;
              return _context99.abrupt("return", url);
            case 18:
            case "end":
              return _context99.stop();
          }
        }, _callee99, this);
      }));
      function pushPrompt(_x121, _x122) {
        return _pushPrompt.apply(this, arguments);
      }
      return pushPrompt;
    }()
    /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
        * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  }, {
    key: "clonePublicDataset",
    value: (function () {
      var _clonePublicDataset = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee100(tokenOrUrl) {
        var _ds$inputs_schema_def, _ds$outputs_schema_de;
        var options,
          _options$sourceApiUrl,
          sourceApiUrl,
          datasetName,
          _this$parseTokenOrUrl,
          _this$parseTokenOrUrl2,
          parsedApiUrl,
          tokenUuid,
          sourceClient,
          ds,
          finalDatasetName,
          examples,
          dataset,
          _args100 = arguments;
        return _regeneratorRuntime().wrap(function _callee100$(_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              options = _args100.length > 1 && _args100[1] !== undefined ? _args100[1] : {};
              _options$sourceApiUrl = options.sourceApiUrl, sourceApiUrl = _options$sourceApiUrl === void 0 ? this.apiUrl : _options$sourceApiUrl, datasetName = options.datasetName;
              _this$parseTokenOrUrl = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl), _this$parseTokenOrUrl2 = _slicedToArray(_this$parseTokenOrUrl, 2), parsedApiUrl = _this$parseTokenOrUrl2[0], tokenUuid = _this$parseTokenOrUrl2[1];
              sourceClient = new Client({
                apiUrl: parsedApiUrl,
                // Placeholder API key not needed anymore in most cases, but
                // some private deployments may have API key-based rate limiting
                // that would cause this to fail if we provide no value.
                apiKey: "placeholder"
              });
              _context100.next = 6;
              return sourceClient.readSharedDataset(tokenUuid);
            case 6:
              ds = _context100.sent;
              finalDatasetName = datasetName || ds.name;
              _context100.prev = 8;
              _context100.next = 11;
              return this.hasDataset({
                datasetId: finalDatasetName
              });
            case 11:
              if (!_context100.sent) {
                _context100.next = 14;
                break;
              }
              console.log("Dataset ".concat(finalDatasetName, " already exists in your tenant. Skipping."));
              return _context100.abrupt("return");
            case 14:
              _context100.next = 18;
              break;
            case 16:
              _context100.prev = 16;
              _context100.t0 = _context100["catch"](8);
            case 18:
              _context100.next = 20;
              return sourceClient.listSharedExamples(tokenUuid);
            case 20:
              examples = _context100.sent;
              _context100.next = 23;
              return this.createDataset(finalDatasetName, {
                description: ds.description,
                dataType: ds.data_type || "kv",
                inputsSchema: (_ds$inputs_schema_def = ds.inputs_schema_definition) !== null && _ds$inputs_schema_def !== void 0 ? _ds$inputs_schema_def : undefined,
                outputsSchema: (_ds$outputs_schema_de = ds.outputs_schema_definition) !== null && _ds$outputs_schema_de !== void 0 ? _ds$outputs_schema_de : undefined
              });
            case 23:
              dataset = _context100.sent;
              _context100.prev = 24;
              _context100.next = 27;
              return this.createExamples({
                inputs: examples.map(function (e) {
                  return e.inputs;
                }),
                outputs: examples.flatMap(function (e) {
                  return e.outputs ? [e.outputs] : [];
                }),
                datasetId: dataset.id
              });
            case 27:
              _context100.next = 33;
              break;
            case 29:
              _context100.prev = 29;
              _context100.t1 = _context100["catch"](24);
              console.error("An error occurred while creating dataset ".concat(finalDatasetName, ". ") + "You should delete it manually.");
              throw _context100.t1;
            case 33:
            case "end":
              return _context100.stop();
          }
        }, _callee100, this, [[8, 16], [24, 29]]);
      }));
      function clonePublicDataset(_x123) {
        return _clonePublicDataset.apply(this, arguments);
      }
      return clonePublicDataset;
    }())
  }, {
    key: "parseTokenOrUrl",
    value: function parseTokenOrUrl(urlOrToken, apiUrl) {
      var numParts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
      var kind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "dataset";
      // Try parsing as UUID
      try {
        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.
        return [apiUrl, urlOrToken];
      } catch (_) {
        // no-op if it's not a uuid
      }
      // Parse as URL
      try {
        var parsedUrl = new URL(urlOrToken);
        var pathParts = parsedUrl.pathname.split("/").filter(function (part) {
          return part !== "";
        });
        if (pathParts.length >= numParts) {
          var tokenUuid = pathParts[pathParts.length - numParts];
          return [apiUrl, tokenUuid];
        } else {
          throw new Error("Invalid public ".concat(kind, " URL: ").concat(urlOrToken));
        }
      } catch (error) {
        throw new Error("Invalid public ".concat(kind, " URL or token: ").concat(urlOrToken));
      }
    }
    /**
     * Awaits all pending trace batches. Useful for environments where
     * you need to be sure that all tracing requests finish before execution ends,
     * such as serverless environments.
     *
     * @example
     * ```
     * import { Client } from "langsmith";
     *
     * const client = new Client();
     *
     * try {
     *   // Tracing happens here
     *   ...
     * } finally {
     *   await client.awaitPendingTraceBatches();
     * }
     * ```
     *
     * @returns A promise that resolves once all currently pending traces have sent.
     */
  }, {
    key: "awaitPendingTraceBatches",
    value: function awaitPendingTraceBatches() {
      return Promise.all([].concat(_toConsumableArray(this.autoBatchQueue.items.map(function (_ref48) {
        var itemPromise = _ref48.itemPromise;
        return itemPromise;
      })), [this.batchIngestCaller.queue.onIdle()]));
    }
  }], [{
    key: "getDefaultClientConfig",
    value: function getDefaultClientConfig() {
      var _getLangSmithEnvironm;
      var apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)("API_KEY");
      var apiUrl = (_getLangSmithEnvironm = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)("ENDPOINT")) !== null && _getLangSmithEnvironm !== void 0 ? _getLangSmithEnvironm : "https://api.smith.langchain.com";
      var hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)("HIDE_INPUTS") === "true";
      var hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)("HIDE_OUTPUTS") === "true";
      return {
        apiUrl: apiUrl,
        apiKey: apiKey,
        webUrl: undefined,
        hideInputs: hideInputs,
        hideOutputs: hideOutputs
      };
    }
  }]);
}();

/***/ }),

/***/ "./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)
/* harmony export */ });
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ "./node_modules/langsmith/dist/utils/env.js");

var isTracingEnabled = function isTracingEnabled(tracingEnabled) {
  if (tracingEnabled !== undefined) {
    return tracingEnabled;
  }
  var envVars = ["TRACING_V2", "TRACING"];
  return !!envVars.find(function (envVar) {
    return (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === "true";
  });
};

/***/ }),

/***/ "./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),
/* harmony export */   __version__: () => (/* binding */ __version__),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation)
/* harmony export */ });
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ "./node_modules/langsmith/dist/client.js");
/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ "./node_modules/langsmith/dist/run_trees.js");
/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ "./node_modules/langsmith/dist/singletons/fetch.js");



// Update using yarn bump-version
var __version__ = "0.2.8";

/***/ }),

/***/ "./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunTree: () => (/* binding */ RunTree),
/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),
/* harmony export */   isRunTree: () => (/* binding */ isRunTree),
/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ "./node_modules/langsmith/dist/utils/env.js");
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ "./node_modules/langsmith/dist/client.js");
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./env.js */ "./node_modules/langsmith/dist/env.js");
/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/warn.js */ "./node_modules/langsmith/dist/utils/warn.js");
/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singletons/constants.js */ "./node_modules/langsmith/dist/singletons/constants.js");
var _excluded = ["metadata"];
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }






function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat(epoch, runId) {
  var executionOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  // Date only has millisecond precision, so we use the microseconds to break
  // possible ties, avoiding incorrect run order
  var paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return stripNonAlphanumeric("".concat(new Date(epoch).toISOString().slice(0, -1)).concat(paddedOrder, "Z")) + runId;
}
/**
 * Baggage header information
 */
var Baggage = /*#__PURE__*/function () {
  function Baggage(metadata, tags) {
    _classCallCheck(this, Baggage);
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.metadata = metadata;
    this.tags = tags;
  }
  return _createClass(Baggage, [{
    key: "toHeader",
    value: function toHeader() {
      var items = [];
      if (this.metadata && Object.keys(this.metadata).length > 0) {
        items.push("langsmith-metadata=".concat(encodeURIComponent(JSON.stringify(this.metadata))));
      }
      if (this.tags && this.tags.length > 0) {
        items.push("langsmith-tags=".concat(encodeURIComponent(this.tags.join(","))));
      }
      return items.join(",");
    }
  }], [{
    key: "fromHeader",
    value: function fromHeader(value) {
      var items = value.split(",");
      var metadata = {};
      var tags = [];
      var _iterator = _createForOfIteratorHelper(items),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          var _item$split = item.split("="),
            _item$split2 = _slicedToArray(_item$split, 2),
            key = _item$split2[0],
            uriValue = _item$split2[1];
          var _value = decodeURIComponent(uriValue);
          if (key === "langsmith-metadata") {
            metadata = JSON.parse(_value);
          } else if (key === "langsmith-tags") {
            tags = _value.split(",");
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return new Baggage(metadata, tags);
    }
  }]);
}();
var RunTree = /*#__PURE__*/function () {
  function RunTree(originalConfig) {
    var _config$client, _config$extra, _this$execution_order, _this$child_execution;
    _classCallCheck(this, RunTree);
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "run_type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parent_run", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_runs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "end_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "extra", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "error", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "serialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reference_example_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "events", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "trace_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "dotted_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingEnabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    /**
     * Attachments associated with the run.
     * Each entry is a tuple of [mime_type, bytes]
     */
    Object.defineProperty(this, "attachments", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    // If you pass in a run tree directly, return a shallow clone
    if (isRunTree(originalConfig)) {
      Object.assign(this, _objectSpread({}, originalConfig));
      return;
    }
    var defaultConfig = RunTree.getDefaultConfig();
    var metadata = originalConfig.metadata,
      config = _objectWithoutProperties(originalConfig, _excluded);
    var client = (_config$client = config.client) !== null && _config$client !== void 0 ? _config$client : RunTree.getSharedClient();
    var dedupedMetadata = _objectSpread(_objectSpread({}, metadata), config === null || config === void 0 || (_config$extra = config.extra) === null || _config$extra === void 0 ? void 0 : _config$extra.metadata);
    config.extra = _objectSpread(_objectSpread({}, config.extra), {}, {
      metadata: dedupedMetadata
    });
    Object.assign(this, _objectSpread(_objectSpread(_objectSpread({}, defaultConfig), config), {}, {
      client: client
    }));
    if (!this.trace_id) {
      if (this.parent_run) {
        var _this$parent_run$trac;
        this.trace_id = (_this$parent_run$trac = this.parent_run.trace_id) !== null && _this$parent_run$trac !== void 0 ? _this$parent_run$trac : this.id;
      } else {
        this.trace_id = this.id;
      }
    }
    (_this$execution_order = this.execution_order) !== null && _this$execution_order !== void 0 ? _this$execution_order : this.execution_order = 1;
    (_this$child_execution = this.child_execution_order) !== null && _this$child_execution !== void 0 ? _this$child_execution : this.child_execution_order = 1;
    if (!this.dotted_order) {
      var currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
      if (this.parent_run) {
        this.dotted_order = this.parent_run.dotted_order + "." + currentDottedOrder;
      } else {
        this.dotted_order = currentDottedOrder;
      }
    }
  }
  return _createClass(RunTree, [{
    key: "createChild",
    value: function createChild(config) {
      var _config$extra$LC_CHIL, _config$extra2;
      var child_execution_order = this.child_execution_order + 1;
      var child = new RunTree(_objectSpread(_objectSpread({}, config), {}, {
        parent_run: this,
        project_name: this.project_name,
        client: this.client,
        tracingEnabled: this.tracingEnabled,
        execution_order: child_execution_order,
        child_execution_order: child_execution_order
      }));
      // Copy context vars over into the new run tree.
      if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY in this) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY] = this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY];
      }
      var LC_CHILD = Symbol["for"]("lc:child_config");
      var presentConfig = (_config$extra$LC_CHIL = (_config$extra2 = config.extra) === null || _config$extra2 === void 0 ? void 0 : _config$extra2[LC_CHILD]) !== null && _config$extra$LC_CHIL !== void 0 ? _config$extra$LC_CHIL : this.extra[LC_CHILD];
      // tracing for LangChain is defined by the _parentRunId and runMap of the tracer
      if (isRunnableConfigLike(presentConfig)) {
        var _newConfig$callbacks$, _newConfig$callbacks;
        var newConfig = _objectSpread({}, presentConfig);
        var callbacks = isCallbackManagerLike(newConfig.callbacks) ? (_newConfig$callbacks$ = (_newConfig$callbacks = newConfig.callbacks).copy) === null || _newConfig$callbacks$ === void 0 ? void 0 : _newConfig$callbacks$.call(_newConfig$callbacks) : undefined;
        if (callbacks) {
          var _callbacks$handlers, _callbacks$handlers$u;
          // update the parent run id
          Object.assign(callbacks, {
            _parentRunId: child.id
          });
          // only populate if we're in a newer LC.JS version
          (_callbacks$handlers = callbacks.handlers) === null || _callbacks$handlers === void 0 || (_callbacks$handlers = _callbacks$handlers.find(isLangChainTracerLike)) === null || _callbacks$handlers === void 0 || (_callbacks$handlers$u = _callbacks$handlers.updateFromRunTree) === null || _callbacks$handlers$u === void 0 || _callbacks$handlers$u.call(_callbacks$handlers, child);
          newConfig.callbacks = callbacks;
        }
        child.extra[LC_CHILD] = newConfig;
      }
      // propagate child_execution_order upwards
      var visited = new Set();
      var current = this;
      while (current != null && !visited.has(current.id)) {
        visited.add(current.id);
        current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
        current = current.parent_run;
      }
      this.child_runs.push(child);
      return child;
    }
  }, {
    key: "end",
    value: function () {
      var _end = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(outputs, error) {
        var _this$outputs, _this$error, _this$end_time;
        var endTime,
          metadata,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              endTime = _args.length > 2 && _args[2] !== undefined ? _args[2] : Date.now();
              metadata = _args.length > 3 ? _args[3] : undefined;
              this.outputs = (_this$outputs = this.outputs) !== null && _this$outputs !== void 0 ? _this$outputs : outputs;
              this.error = (_this$error = this.error) !== null && _this$error !== void 0 ? _this$error : error;
              this.end_time = (_this$end_time = this.end_time) !== null && _this$end_time !== void 0 ? _this$end_time : endTime;
              if (metadata && Object.keys(metadata).length > 0) {
                this.extra = this.extra ? _objectSpread(_objectSpread({}, this.extra), {}, {
                  metadata: _objectSpread(_objectSpread({}, this.extra.metadata), metadata)
                }) : {
                  metadata: metadata
                };
              }
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function end(_x, _x2) {
        return _end.apply(this, arguments);
      }
      return end;
    }()
  }, {
    key: "_convertToCreate",
    value: function _convertToCreate(run, runtimeEnv) {
      var _run$extra,
        _this = this;
      var excludeChildRuns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var runExtra = (_run$extra = run.extra) !== null && _run$extra !== void 0 ? _run$extra : {};
      if (!runExtra.runtime) {
        runExtra.runtime = {};
      }
      if (runtimeEnv) {
        for (var _i = 0, _Object$entries = Object.entries(runtimeEnv); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            k = _Object$entries$_i[0],
            v = _Object$entries$_i[1];
          if (!runExtra.runtime[k]) {
            runExtra.runtime[k] = v;
          }
        }
      }
      var child_runs;
      var parent_run_id;
      if (!excludeChildRuns) {
        child_runs = run.child_runs.map(function (child_run) {
          return _this._convertToCreate(child_run, runtimeEnv, excludeChildRuns);
        });
        parent_run_id = undefined;
      } else {
        var _run$parent_run;
        parent_run_id = (_run$parent_run = run.parent_run) === null || _run$parent_run === void 0 ? void 0 : _run$parent_run.id;
        child_runs = [];
      }
      var persistedRun = {
        id: run.id,
        name: run.name,
        start_time: run.start_time,
        end_time: run.end_time,
        run_type: run.run_type,
        reference_example_id: run.reference_example_id,
        extra: runExtra,
        serialized: run.serialized,
        error: run.error,
        inputs: run.inputs,
        outputs: run.outputs,
        session_name: run.project_name,
        child_runs: child_runs,
        parent_run_id: parent_run_id,
        trace_id: run.trace_id,
        dotted_order: run.dotted_order,
        tags: run.tags,
        attachments: run.attachments
      };
      return persistedRun;
    }
  }, {
    key: "postRun",
    value: function () {
      var _postRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var excludeChildRuns,
          runtimeEnv,
          runCreate,
          _iterator2,
          _step2,
          childRun,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              excludeChildRuns = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : true;
              _context2.prev = 1;
              runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();
              _context2.next = 5;
              return this._convertToCreate(this, runtimeEnv, true);
            case 5:
              runCreate = _context2.sent;
              _context2.next = 8;
              return this.client.createRun(runCreate);
            case 8:
              if (excludeChildRuns) {
                _context2.next = 27;
                break;
              }
              (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_3__.warnOnce)("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
              _iterator2 = _createForOfIteratorHelper(this.child_runs);
              _context2.prev = 11;
              _iterator2.s();
            case 13:
              if ((_step2 = _iterator2.n()).done) {
                _context2.next = 19;
                break;
              }
              childRun = _step2.value;
              _context2.next = 17;
              return childRun.postRun(false);
            case 17:
              _context2.next = 13;
              break;
            case 19:
              _context2.next = 24;
              break;
            case 21:
              _context2.prev = 21;
              _context2.t0 = _context2["catch"](11);
              _iterator2.e(_context2.t0);
            case 24:
              _context2.prev = 24;
              _iterator2.f();
              return _context2.finish(24);
            case 27:
              _context2.next = 32;
              break;
            case 29:
              _context2.prev = 29;
              _context2.t1 = _context2["catch"](1);
              console.error("Error in postRun for run ".concat(this.id, ":"), _context2.t1);
            case 32:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 29], [11, 21, 24, 27]]);
      }));
      function postRun() {
        return _postRun.apply(this, arguments);
      }
      return postRun;
    }()
  }, {
    key: "patchRun",
    value: function () {
      var _patchRun = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var _this$parent_run, runUpdate;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              runUpdate = {
                end_time: this.end_time,
                error: this.error,
                inputs: this.inputs,
                outputs: this.outputs,
                parent_run_id: (_this$parent_run = this.parent_run) === null || _this$parent_run === void 0 ? void 0 : _this$parent_run.id,
                reference_example_id: this.reference_example_id,
                extra: this.extra,
                events: this.events,
                dotted_order: this.dotted_order,
                trace_id: this.trace_id,
                tags: this.tags,
                attachments: this.attachments
              };
              _context3.next = 4;
              return this.client.updateRun(this.id, runUpdate);
            case 4:
              _context3.next = 9;
              break;
            case 6:
              _context3.prev = 6;
              _context3.t0 = _context3["catch"](0);
              console.error("Error in patchRun for run ".concat(this.id), _context3.t0);
            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 6]]);
      }));
      function patchRun() {
        return _patchRun.apply(this, arguments);
      }
      return patchRun;
    }()
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this._convertToCreate(this, undefined, false);
    }
  }, {
    key: "toHeaders",
    value: function toHeaders(headers) {
      var _this$extra;
      var result = {
        "langsmith-trace": this.dotted_order,
        baggage: new Baggage((_this$extra = this.extra) === null || _this$extra === void 0 ? void 0 : _this$extra.metadata, this.tags).toHeader()
      };
      if (headers) {
        for (var _i2 = 0, _Object$entries2 = Object.entries(result); _i2 < _Object$entries2.length; _i2++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
            key = _Object$entries2$_i[0],
            value = _Object$entries2$_i[1];
          headers.set(key, value);
        }
      }
      return result;
    }
  }], [{
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var _ref, _getEnvironmentVariab, _getEnvironmentVariab2;
      return {
        id: uuid__WEBPACK_IMPORTED_MODULE_5__["default"](),
        run_type: "chain",
        project_name: (_ref = (_getEnvironmentVariab = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)("LANGCHAIN_PROJECT")) !== null && _getEnvironmentVariab !== void 0 ? _getEnvironmentVariab : (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)("LANGCHAIN_SESSION")) !== null && _ref !== void 0 ? _ref :
        // TODO: Deprecate
        "default",
        child_runs: [],
        api_url: (_getEnvironmentVariab2 = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)("LANGCHAIN_ENDPOINT")) !== null && _getEnvironmentVariab2 !== void 0 ? _getEnvironmentVariab2 : "http://localhost:1984",
        api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)("LANGCHAIN_API_KEY"),
        caller_options: {},
        start_time: Date.now(),
        serialized: {},
        inputs: {},
        extra: {}
      };
    }
  }, {
    key: "getSharedClient",
    value: function getSharedClient() {
      if (!RunTree.sharedClient) {
        RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client();
      }
      return RunTree.sharedClient;
    }
  }, {
    key: "fromRunnableConfig",
    value: function fromRunnableConfig(parentConfig, props) {
      var _parentRun$tags, _parentRun, _parentConfig$tags, _parentRun2;
      // We only handle the callback manager case for now
      var callbackManager = parentConfig === null || parentConfig === void 0 ? void 0 : parentConfig.callbacks;
      var parentRun;
      var projectName;
      var client;
      var tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_2__.isTracingEnabled)();
      if (callbackManager) {
        var _callbackManager$getP, _callbackManager$getP2, _callbackManager$hand, _langChainTracer$getR;
        var parentRunId = (_callbackManager$getP = callbackManager === null || callbackManager === void 0 || (_callbackManager$getP2 = callbackManager.getParentRunId) === null || _callbackManager$getP2 === void 0 ? void 0 : _callbackManager$getP2.call(callbackManager)) !== null && _callbackManager$getP !== void 0 ? _callbackManager$getP : "";
        var langChainTracer = callbackManager === null || callbackManager === void 0 || (_callbackManager$hand = callbackManager.handlers) === null || _callbackManager$hand === void 0 ? void 0 : _callbackManager$hand.find(function (handler) {
          return (handler === null || handler === void 0 ? void 0 : handler.name) == "langchain_tracer";
        });
        parentRun = langChainTracer === null || langChainTracer === void 0 || (_langChainTracer$getR = langChainTracer.getRun) === null || _langChainTracer$getR === void 0 ? void 0 : _langChainTracer$getR.call(langChainTracer, parentRunId);
        projectName = langChainTracer === null || langChainTracer === void 0 ? void 0 : langChainTracer.projectName;
        client = langChainTracer === null || langChainTracer === void 0 ? void 0 : langChainTracer.client;
        tracingEnabled = tracingEnabled || !!langChainTracer;
      }
      if (!parentRun) {
        return new RunTree(_objectSpread(_objectSpread({}, props), {}, {
          client: client,
          tracingEnabled: tracingEnabled,
          project_name: projectName
        }));
      }
      var parentRunTree = new RunTree({
        name: parentRun.name,
        id: parentRun.id,
        trace_id: parentRun.trace_id,
        dotted_order: parentRun.dotted_order,
        client: client,
        tracingEnabled: tracingEnabled,
        project_name: projectName,
        tags: _toConsumableArray(new Set(((_parentRun$tags = (_parentRun = parentRun) === null || _parentRun === void 0 ? void 0 : _parentRun.tags) !== null && _parentRun$tags !== void 0 ? _parentRun$tags : []).concat((_parentConfig$tags = parentConfig === null || parentConfig === void 0 ? void 0 : parentConfig.tags) !== null && _parentConfig$tags !== void 0 ? _parentConfig$tags : []))),
        extra: {
          metadata: _objectSpread(_objectSpread({}, (_parentRun2 = parentRun) === null || _parentRun2 === void 0 || (_parentRun2 = _parentRun2.extra) === null || _parentRun2 === void 0 ? void 0 : _parentRun2.metadata), parentConfig === null || parentConfig === void 0 ? void 0 : parentConfig.metadata)
        }
      });
      return parentRunTree.createChild(props);
    }
  }, {
    key: "fromDottedOrder",
    value: function fromDottedOrder(dottedOrder) {
      return this.fromHeaders({
        "langsmith-trace": dottedOrder
      });
    }
  }, {
    key: "fromHeaders",
    value: function fromHeaders(headers, inheritArgs) {
      var _inheritArgs$name, _inheritArgs$run_type, _inheritArgs$start_ti, _parsedDottedOrder$at;
      var rawHeaders = "get" in headers && typeof headers.get === "function" ? {
        "langsmith-trace": headers.get("langsmith-trace"),
        baggage: headers.get("baggage")
      } : headers;
      var headerTrace = rawHeaders["langsmith-trace"];
      if (!headerTrace || typeof headerTrace !== "string") return undefined;
      var parentDottedOrder = headerTrace.trim();
      var parsedDottedOrder = parentDottedOrder.split(".").map(function (part) {
        var _part$split = part.split("Z"),
          _part$split2 = _slicedToArray(_part$split, 2),
          strTime = _part$split2[0],
          uuid = _part$split2[1];
        return {
          strTime: strTime,
          time: Date.parse(strTime + "Z"),
          uuid: uuid
        };
      });
      var traceId = parsedDottedOrder[0].uuid;
      var config = _objectSpread(_objectSpread({}, inheritArgs), {}, {
        name: (_inheritArgs$name = inheritArgs === null || inheritArgs === void 0 ? void 0 : inheritArgs["name"]) !== null && _inheritArgs$name !== void 0 ? _inheritArgs$name : "parent",
        run_type: (_inheritArgs$run_type = inheritArgs === null || inheritArgs === void 0 ? void 0 : inheritArgs["run_type"]) !== null && _inheritArgs$run_type !== void 0 ? _inheritArgs$run_type : "chain",
        start_time: (_inheritArgs$start_ti = inheritArgs === null || inheritArgs === void 0 ? void 0 : inheritArgs["start_time"]) !== null && _inheritArgs$start_ti !== void 0 ? _inheritArgs$start_ti : Date.now(),
        id: (_parsedDottedOrder$at = parsedDottedOrder.at(-1)) === null || _parsedDottedOrder$at === void 0 ? void 0 : _parsedDottedOrder$at.uuid,
        trace_id: traceId,
        dotted_order: parentDottedOrder
      });
      if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
        var baggage = Baggage.fromHeader(rawHeaders["baggage"]);
        config.metadata = baggage.metadata;
        config.tags = baggage.tags;
      }
      return new RunTree(config);
    }
  }]);
}();
Object.defineProperty(RunTree, "sharedClient", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: null
});
function isRunTree(x) {
  return x !== undefined && typeof x.createChild === "function" && typeof x.postRun === "function";
}
function isLangChainTracerLike(x) {
  return _typeof(x) === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
}
function containsLangChainTracerLike(x) {
  return Array.isArray(x) && x.some(function (callback) {
    return isLangChainTracerLike(callback);
  });
}
function isCallbackManagerLike(x) {
  return _typeof(x) === "object" && x != null && Array.isArray(x.handlers);
}
function isRunnableConfigLike(x) {
  var _x$callbacks;
  // Check that it's an object with a callbacks arg
  // that has either a CallbackManagerLike object with a langchain tracer within it
  // or an array with a LangChainTracerLike object within it
  return x !== undefined && _typeof(x.callbacks) === "object" && (
  // Callback manager with a langchain tracer
  containsLangChainTracerLike((_x$callbacks = x.callbacks) === null || _x$callbacks === void 0 ? void 0 : _x$callbacks.handlers) ||
  // Or it's an array with a LangChainTracerLike object within it
  containsLangChainTracerLike(x.callbacks));
}

/***/ }),

/***/ "./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY)
/* harmony export */ });
var _LC_CONTEXT_VARIABLES_KEY = Symbol["for"]("lc:context_variables");

/***/ }),

/***/ "./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),
/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)
/* harmony export */ });
// Wrap the default fetch call due to issues with illegal invocations
// in some environments:
// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err
// @ts-expect-error Broad typing to support a range of fetch implementations
var DEFAULT_FETCH_IMPLEMENTATION = function DEFAULT_FETCH_IMPLEMENTATION() {
  return fetch.apply(void 0, arguments);
};
var LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol["for"]("ls:fetch_implementation");
/**
 * Overrides the fetch implementation used for LangSmith calls.
 * You should use this if you need to use an implementation of fetch
 * other than the default global (e.g. for dealing with proxies).
 * @param fetch The new fetch functino to use.
 */
var overrideFetchImplementation = function overrideFetchImplementation(fetch) {
  globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;
};
/**
 * @internal
 */
var _getFetchImplementation = function _getFetchImplementation() {
  var _globalThis$LANGSMITH;
  return (_globalThis$LANGSMITH = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY]) !== null && _globalThis$LANGSMITH !== void 0 ? _globalThis$LANGSMITH : DEFAULT_FETCH_IMPLEMENTATION;
};

/***/ }),

/***/ "./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),
/* harmony export */   ROOT: () => (/* binding */ ROOT),
/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),
/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),
/* harmony export */   withRunTree: () => (/* binding */ withRunTree)
/* harmony export */ });
/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../run_trees.js */ "./node_modules/langsmith/dist/run_trees.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var MockAsyncLocalStorage = /*#__PURE__*/function () {
  function MockAsyncLocalStorage() {
    _classCallCheck(this, MockAsyncLocalStorage);
  }
  return _createClass(MockAsyncLocalStorage, [{
    key: "getStore",
    value: function getStore() {
      return undefined;
    }
  }, {
    key: "run",
    value: function run(_, callback) {
      return callback();
    }
  }]);
}();
var TRACING_ALS_KEY = Symbol["for"]("ls:tracing_async_local_storage");
var mockAsyncLocalStorage = new MockAsyncLocalStorage();
var AsyncLocalStorageProvider = /*#__PURE__*/function () {
  function AsyncLocalStorageProvider() {
    _classCallCheck(this, AsyncLocalStorageProvider);
  }
  return _createClass(AsyncLocalStorageProvider, [{
    key: "getInstance",
    value: function getInstance() {
      var _globalThis$TRACING_A;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return (_globalThis$TRACING_A = globalThis[TRACING_ALS_KEY]) !== null && _globalThis$TRACING_A !== void 0 ? _globalThis$TRACING_A : mockAsyncLocalStorage;
    }
  }, {
    key: "initializeGlobalInstance",
    value: function initializeGlobalInstance(instance) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (globalThis[TRACING_ALS_KEY] === undefined) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        globalThis[TRACING_ALS_KEY] = instance;
      }
    }
  }]);
}();
var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
/**
 * Return the current run tree from within a traceable-wrapped function.
 * Will throw an error if called outside of a traceable function.
 *
 * @returns The run tree for the given context.
 */
var getCurrentRunTree = function getCurrentRunTree() {
  var runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
  if (!(0,_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree)(runTree)) {
    throw new Error(["Could not get the current run tree.", "", "Please make sure you are calling this method within a traceable function or the tracing is enabled."].join("\n"));
  }
  return runTree;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withRunTree(runTree, fn) {
  var storage = AsyncLocalStorageProviderSingleton.getInstance();
  return new Promise(function (resolve, reject) {
    storage.run(runTree, function () {
      return void Promise.resolve(fn()).then(resolve)["catch"](reject);
    });
  });
}
var ROOT = Symbol["for"]("langsmith:traceable:root");
function isTraceableFunction(x
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  return typeof x === "function" && "langsmith:traceable" in x;
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assertUuid: () => (/* binding */ assertUuid)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/validate.js");

function assertUuid(str, which) {
  if (!uuid__WEBPACK_IMPORTED_MODULE_0__["default"](str)) {
    var msg = which !== undefined ? "Invalid UUID for ".concat(which, ": ").concat(str) : "Invalid UUID: ".concat(str);
    throw new Error(msg);
  }
  return str;
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)
/* harmony export */ });
/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ "./node_modules/langsmith/node_modules/p-retry/index.js");
/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ "./node_modules/langsmith/node_modules/p-queue/dist/index.js");
/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ "./node_modules/langsmith/dist/singletons/fetch.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var STATUS_NO_RETRY = [400,
// Bad Request
401,
// Unauthorized
403,
// Forbidden
404,
// Not Found
405,
// Method Not Allowed
406,
// Not Acceptable
407,
// Proxy Authentication Required
408 // Request Timeout
];
var STATUS_IGNORE = [409 // Conflict
];
/**
 * A class that can be used to make async calls with concurrency and retry logic.
 *
 * This is useful for making calls to any kind of "expensive" external resource,
 * be it because it's rate-limited, subject to network issues, etc.
 *
 * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults
 * to `Infinity`. This means that by default, all calls will be made in parallel.
 *
 * Retries are limited by the `maxRetries` parameter, which defaults to 6. This
 * means that by default, each call will be retried up to 6 times, with an
 * exponential backoff between each attempt.
 */
var AsyncCaller = /*#__PURE__*/function () {
  function AsyncCaller(params) {
    var _params$maxConcurrenc, _params$maxRetries;
    _classCallCheck(this, AsyncCaller);
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = (_params$maxConcurrenc = params.maxConcurrency) !== null && _params$maxConcurrenc !== void 0 ? _params$maxConcurrenc : Infinity;
    this.maxRetries = (_params$maxRetries = params.maxRetries) !== null && _params$maxRetries !== void 0 ? _params$maxRetries : 6;
    if ( true) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__["default"]({
        concurrency: this.maxConcurrency
      });
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({
        concurrency: this.maxConcurrency
      });
    }
    this.onFailedResponseHook = params === null || params === void 0 ? void 0 : params.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return _createClass(AsyncCaller, [{
    key: "call",
    value: function call(callable) {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var onFailedResponseHook = this.onFailedResponseHook;
      return this.queue.add(function () {
        return p_retry__WEBPACK_IMPORTED_MODULE_0__(function () {
          return callable.apply(void 0, args)["catch"](function (error) {
            // eslint-disable-next-line no-instanceof/no-instanceof
            if (error instanceof Error) {
              throw error;
            } else {
              throw new Error(error);
            }
          });
        }, {
          onFailedAttempt: function onFailedAttempt(error) {
            return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              var response, status;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!(error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError"))) {
                      _context.next = 2;
                      break;
                    }
                    throw error;
                  case 2:
                    if (!((error === null || error === void 0 ? void 0 : error.code) === "ECONNABORTED")) {
                      _context.next = 4;
                      break;
                    }
                    throw error;
                  case 4:
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    response = error === null || error === void 0 ? void 0 : error.response;
                    status = response === null || response === void 0 ? void 0 : response.status;
                    if (!status) {
                      _context.next = 16;
                      break;
                    }
                    if (!STATUS_NO_RETRY.includes(+status)) {
                      _context.next = 11;
                      break;
                    }
                    throw error;
                  case 11:
                    if (!STATUS_IGNORE.includes(+status)) {
                      _context.next = 13;
                      break;
                    }
                    return _context.abrupt("return");
                  case 13:
                    if (!onFailedResponseHook) {
                      _context.next = 16;
                      break;
                    }
                    _context.next = 16;
                    return onFailedResponseHook(response);
                  case 16:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }))();
          },
          // If needed we can change some of the defaults here,
          // but they're quite sensible.
          retries: _this.maxRetries,
          randomize: true
        });
      }, {
        throwOnTimeout: true
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "callWithOptions",
    value: function callWithOptions(options, callable) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      // Note this doesn't cancel the underlying request,
      // when available prefer to use the signal option of the underlying call
      if (options.signal) {
        return Promise.race([this.call.apply(this, [callable].concat(args)), new Promise(function (_, reject) {
          var _options$signal;
          (_options$signal = options.signal) === null || _options$signal === void 0 || _options$signal.addEventListener("abort", function () {
            reject(new Error("AbortError"));
          });
        })]);
      }
      return this.call.apply(this, [callable].concat(args));
    }
  }, {
    key: "fetch",
    value: function fetch() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.call(function () {
        return (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)().apply(void 0, args).then(function (res) {
          return res.ok ? res : Promise.reject(res);
        });
      });
    }
  }]);
}();

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEnv: () => (/* binding */ getEnv),
/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),
/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),
/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),
/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),
/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),
/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),
/* harmony export */   getShas: () => (/* binding */ getShas),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isDeno: () => (/* binding */ isDeno),
/* harmony export */   isJsDom: () => (/* binding */ isJsDom),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),
/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/langsmith/dist/index.js");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Inlined from https://github.com/flexdinesh/browser-or-node

var globalEnv;
var isBrowser = function isBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
};
var isWebWorker = function isWebWorker() {
  return (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
};
var isJsDom = function isJsDom() {
  return typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
};
// Supabase Edge Function provides a `Deno` global object
// without `version` property
var isDeno = function isDeno() {
  return typeof Deno !== "undefined";
};
// Mark not-as-node if in Supabase Edge Function
var isNode = function isNode() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
};
var getEnv = function getEnv() {
  if (globalEnv) {
    return globalEnv;
  }
  if (isBrowser()) {
    globalEnv = "browser";
  } else if (isNode()) {
    globalEnv = "node";
  } else if (isWebWorker()) {
    globalEnv = "webworker";
  } else if (isJsDom()) {
    globalEnv = "jsdom";
  } else if (isDeno()) {
    globalEnv = "deno";
  } else {
    globalEnv = "other";
  }
  return globalEnv;
};
var runtimeEnvironment;
function getRuntimeEnvironment() {
  if (runtimeEnvironment === undefined) {
    var env = getEnv();
    var releaseEnv = getShas();
    runtimeEnvironment = _objectSpread({
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__
    }, releaseEnv);
  }
  return runtimeEnvironment;
}
/**
 * Retrieves the LangChain-specific environment variables from the current runtime environment.
 * Sensitive keys (containing the word "key", "token", or "secret") have their values redacted for security.
 *
 * @returns {Record<string, string>}
 *  - A record of LangChain-specific environment variables.
 */
function getLangChainEnvVars() {
  var allEnvVars = getEnvironmentVariables() || {};
  var envVars = {};
  for (var _i = 0, _Object$entries = Object.entries(allEnvVars); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      key = _Object$entries$_i[0],
      value = _Object$entries$_i[1];
    if (key.startsWith("LANGCHAIN_") && typeof value === "string") {
      envVars[key] = value;
    }
  }
  for (var _key in envVars) {
    if ((_key.toLowerCase().includes("key") || _key.toLowerCase().includes("secret") || _key.toLowerCase().includes("token")) && typeof envVars[_key] === "string") {
      var _value = envVars[_key];
      envVars[_key] = _value.slice(0, 2) + "*".repeat(_value.length - 4) + _value.slice(-2);
    }
  }
  return envVars;
}
/**
 * Retrieves the LangChain-specific metadata from the current runtime environment.
 *
 * @returns {Record<string, string>}
 *  - A record of LangChain-specific metadata environment variables.
 */
function getLangChainEnvVarsMetadata() {
  var allEnvVars = getEnvironmentVariables() || {};
  var envVars = {};
  var excluded = ["LANGCHAIN_API_KEY", "LANGCHAIN_ENDPOINT", "LANGCHAIN_TRACING_V2", "LANGCHAIN_PROJECT", "LANGCHAIN_SESSION", "LANGSMITH_API_KEY", "LANGSMITH_ENDPOINT", "LANGSMITH_TRACING_V2", "LANGSMITH_PROJECT", "LANGSMITH_SESSION"];
  for (var _i2 = 0, _Object$entries2 = Object.entries(allEnvVars); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
      key = _Object$entries2$_i[0],
      value = _Object$entries2$_i[1];
    if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
/**
 * Retrieves the environment variables from the current runtime environment.
 *
 * This function is designed to operate in a variety of JS environments,
 * including Node.js, Deno, browsers, etc.
 *
 * @returns {Record<string, string> | undefined}
 *  - A record of environment variables if available.
 *  - `undefined` if the environment does not support or allows access to environment variables.
 */
function getEnvironmentVariables() {
  try {
    // Check for Node.js environment
    // eslint-disable-next-line no-process-env
    if (typeof process !== "undefined" && process.env) {
      // eslint-disable-next-line no-process-env
      return Object.entries(process.env).reduce(function (acc, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        acc[key] = String(value);
        return acc;
      }, {});
    }
    // For browsers and other environments, we may not have direct access to env variables
    // Return undefined or any other fallback as required.
    return undefined;
  } catch (e) {
    // Catch any errors that might occur while trying to access environment variables
    return undefined;
  }
}
function getEnvironmentVariable(name) {
  // Certain Deno setups will throw an error if you try to access environment variables
  // https://github.com/hwchase17/langchainjs/issues/1412
  try {
    var _process$env;
    return typeof process !== "undefined" ? // eslint-disable-next-line no-process-env
    (_process$env = process.env) === null || _process$env === void 0 ? void 0 : _process$env[name] : undefined;
  } catch (e) {
    return undefined;
  }
}
function getLangSmithEnvironmentVariable(name) {
  return getEnvironmentVariable("LANGSMITH_".concat(name)) || getEnvironmentVariable("LANGCHAIN_".concat(name));
}
function setEnvironmentVariable(name, value) {
  if (typeof process !== "undefined") {
    // eslint-disable-next-line no-process-env
    process.env[name] = value;
  }
}
var cachedCommitSHAs;
/**
 * Get the Git commit SHA from common environment variables
 * used by different CI/CD platforms.
 * @returns {string | undefined} The Git commit SHA or undefined if not found.
 */
function getShas() {
  if (cachedCommitSHAs !== undefined) {
    return cachedCommitSHAs;
  }
  var common_release_envs = ["VERCEL_GIT_COMMIT_SHA", "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA", "COMMIT_REF", "RENDER_GIT_COMMIT", "CI_COMMIT_SHA", "CIRCLE_SHA1", "CF_PAGES_COMMIT_SHA", "REACT_APP_GIT_SHA", "SOURCE_VERSION", "GITHUB_SHA", "TRAVIS_COMMIT", "GIT_COMMIT", "BUILD_VCS_NUMBER", "bamboo_planRepository_revision", "Build.SourceVersion", "BITBUCKET_COMMIT", "DRONE_COMMIT_SHA", "SEMAPHORE_GIT_SHA", "BUILDKITE_COMMIT"];
  var shas = {};
  for (var _i3 = 0, _common_release_envs = common_release_envs; _i3 < _common_release_envs.length; _i3++) {
    var env = _common_release_envs[_i3];
    var envVar = getEnvironmentVariable(env);
    if (envVar !== undefined) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),
/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),
/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)
/* harmony export */ });
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function getErrorStackTrace(e) {
  if (_typeof(e) !== "object" || e == null) return undefined;
  if (!("stack" in e) || typeof e.stack !== "string") return undefined;
  var stack = e.stack;
  var prevLine = "".concat(e);
  if (stack.startsWith(prevLine)) {
    stack = stack.slice(prevLine.length);
  }
  if (stack.startsWith("\n")) {
    stack = stack.slice(1);
  }
  return stack;
}
function printErrorStackTrace(e) {
  var stack = getErrorStackTrace(e);
  if (stack == null) return;
  console.error(stack);
}
/**
 * LangSmithConflictError
 *
 * Represents an error that occurs when there's a conflict during an operation,
 * typically corresponding to HTTP 409 status code responses.
 *
 * This error is thrown when an attempt to create or modify a resource conflicts
 * with the current state of the resource on the server. Common scenarios include:
 * - Attempting to create a resource that already exists
 * - Trying to update a resource that has been modified by another process
 * - Violating a uniqueness constraint in the data
 *
 * @extends Error
 *
 * @example
 * try {
 *   await createProject("existingProject");
 * } catch (error) {
 *   if (error instanceof ConflictError) {
 *     console.log("A conflict occurred:", error.message);
 *     // Handle the conflict, e.g., by suggesting a different project name
 *   } else {
 *     // Handle other types of errors
 *   }
 * }
 *
 * @property {string} name - Always set to 'ConflictError' for easy identification
 * @property {string} message - Detailed error message including server response
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409
 */
var LangSmithConflictError = /*#__PURE__*/function (_Error) {
  function LangSmithConflictError(message) {
    var _this;
    _classCallCheck(this, LangSmithConflictError);
    _this = _callSuper(this, LangSmithConflictError, [message]);
    _this.name = "LangSmithConflictError";
    return _this;
  }
  _inherits(LangSmithConflictError, _Error);
  return _createClass(LangSmithConflictError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Throws an appropriate error based on the response status and body.
 *
 * @param response - The fetch Response object
 * @param context - Additional context to include in the error message (e.g., operation being performed)
 * @throws {LangSmithConflictError} When the response status is 409
 * @throws {Error} For all other non-ok responses
 */
function raiseForStatus(_x, _x2, _x3) {
  return _raiseForStatus.apply(this, arguments);
}
function _raiseForStatus() {
  _raiseForStatus = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(response, context, consume) {
    var errorBody, fullMessage;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!response.ok) {
            _context.next = 6;
            break;
          }
          if (!consume) {
            _context.next = 5;
            break;
          }
          _context.next = 4;
          return response.text();
        case 4:
          errorBody = _context.sent;
        case 5:
          return _context.abrupt("return");
        case 6:
          _context.next = 8;
          return response.text();
        case 8:
          errorBody = _context.sent;
          fullMessage = "Failed to ".concat(context, ". Received status [").concat(response.status, "]: ").concat(response.statusText, ". Server response: ").concat(errorBody);
          if (!(response.status === 409)) {
            _context.next = 12;
            break;
          }
          throw new LangSmithConflictError(fullMessage);
        case 12:
          throw new Error(fullMessage);
        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _raiseForStatus.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/* eslint-disable */
// @ts-nocheck
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = {
  result: "[Circular]"
};
var arr = [];
var replacerStack = [];
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
// Regular stringify
function stringify(obj, replacer, spacer, options) {
  try {
    return JSON.stringify(obj, replacer, spacer);
  } catch (e) {
    var _e$message;
    // Fall back to more complex stringify if circular reference
    if (!((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.includes("Converting circular structure to JSON"))) {
      console.warn("[WARNING]: LangSmith received unserializable value.");
      return "[Unserializable]";
    }
    console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.");
    if (typeof options === "undefined") {
      options = defaultOptions();
    }
    decirc(obj, "", 0, [], undefined, 0, options);
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, {
        value: replace
      });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (_typeof(val) === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
// Stable-stringify
function compareFunction(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], undefined, 0, options) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (_typeof(val) === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_) {
      return;
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, i, stack, val, depth, options);
        tmp[key] = val[key];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function (k, v) {
    return v;
  };
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),
/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function isLangChainMessage(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
message) {
  return typeof (message === null || message === void 0 ? void 0 : message._getType) === "function";
}
function convertLangChainMessageToExample(message) {
  var converted = {
    type: message._getType(),
    data: {
      content: message.content
    }
  };
  // Check for presence of keys in additional_kwargs
  if (message !== null && message !== void 0 && message.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = _objectSpread({}, message.additional_kwargs);
  }
  return converted;
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),
/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }

function isVersionGreaterOrEqual(current_version, target_version) {
  var current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);
  var target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);
  if (!current || !target) {
    throw new Error("Invalid version format.");
  }
  return current.compare(target) >= 0;
}
function parsePromptIdentifier(identifier) {
  if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
    throw new Error("Invalid identifier format: ".concat(identifier));
  }
  var _identifier$split = identifier.split(":"),
    _identifier$split2 = _slicedToArray(_identifier$split, 2),
    ownerNamePart = _identifier$split2[0],
    commitPart = _identifier$split2[1];
  var commit = commitPart || "latest";
  if (ownerNamePart.includes("/")) {
    var _ownerNamePart$split = ownerNamePart.split("/", 2),
      _ownerNamePart$split2 = _slicedToArray(_ownerNamePart$split, 2),
      owner = _ownerNamePart$split2[0],
      name = _ownerNamePart$split2[1];
    if (!owner || !name) {
      throw new Error("Invalid identifier format: ".concat(identifier));
    }
    return [owner, name, commit];
  } else {
    if (!ownerNamePart) {
      throw new Error("Invalid identifier format: ".concat(identifier));
    }
    return ["-", ownerNamePart, commit];
  }
}

/***/ }),

/***/ "./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   warnOnce: () => (/* binding */ warnOnce)
/* harmony export */ });
var warnedMessages = {};
function warnOnce(message) {
  if (!warnedMessages[message]) {
    console.warn(message);
    warnedMessages[message] = true;
  }
}

/***/ }),

/***/ "./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "./node_modules/langsmith/dist/index.js");


/***/ }),

/***/ "./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),
/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),
/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)
/* harmony export */ });
/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ "./node_modules/langsmith/dist/run_trees.js");


/***/ }),

/***/ "./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),
/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),
/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),
/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),
/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)
/* harmony export */ });
/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ "./node_modules/langsmith/dist/singletons/traceable.js");


/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/Options.js":
/*!*************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/Options.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions),
/* harmony export */   getDefaultOptions: () => (/* binding */ getDefaultOptions),
/* harmony export */   ignoreOverride: () => (/* binding */ ignoreOverride)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: undefined,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = function getDefaultOptions(options) {
  return typeof options === "string" ? _objectSpread(_objectSpread({}, defaultOptions), {}, {
    name: options
  }) : _objectSpread(_objectSpread({}, defaultOptions), options);
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/Refs.js":
/*!**********************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/Refs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRefs: () => (/* binding */ getRefs)
/* harmony export */ });
/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Options.js */ "./node_modules/zod-to-json-schema/dist/esm/Options.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

var getRefs = function getRefs(options) {
  var _options = (0,_Options_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultOptions)(options);
  var currentPath = _options.name !== undefined ? [].concat(_toConsumableArray(_options.basePath), [_options.definitionPath, _options.name]) : _options.basePath;
  return _objectSpread(_objectSpread({}, _options), {}, {
    currentPath: currentPath,
    propertyPath: undefined,
    seen: new Map(Object.entries(_options.definitions).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        def = _ref2[1];
      return [def._def, {
        def: def._def,
        path: [].concat(_toConsumableArray(_options.basePath), [_options.definitionPath, name]),
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: undefined
      }];
    }))
  });
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js":
/*!*******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/errorMessages.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addErrorMessage: () => (/* binding */ addErrorMessage),
/* harmony export */   setResponseValueAndErrors: () => (/* binding */ setResponseValueAndErrors)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs !== null && refs !== void 0 && refs.errorMessages)) return;
  if (errorMessage) {
    res.errorMessage = _objectSpread(_objectSpread({}, res.errorMessage), {}, _defineProperty({}, key, errorMessage));
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addErrorMessage: () => (/* reexport safe */ _errorMessages_js__WEBPACK_IMPORTED_MODULE_2__.addErrorMessage),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultOptions: () => (/* reexport safe */ _Options_js__WEBPACK_IMPORTED_MODULE_0__.defaultOptions),
/* harmony export */   getDefaultOptions: () => (/* reexport safe */ _Options_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultOptions),
/* harmony export */   getRefs: () => (/* reexport safe */ _Refs_js__WEBPACK_IMPORTED_MODULE_1__.getRefs),
/* harmony export */   ignoreOverride: () => (/* reexport safe */ _Options_js__WEBPACK_IMPORTED_MODULE_0__.ignoreOverride),
/* harmony export */   parseAnyDef: () => (/* reexport safe */ _parsers_any_js__WEBPACK_IMPORTED_MODULE_4__.parseAnyDef),
/* harmony export */   parseArrayDef: () => (/* reexport safe */ _parsers_array_js__WEBPACK_IMPORTED_MODULE_5__.parseArrayDef),
/* harmony export */   parseBigintDef: () => (/* reexport safe */ _parsers_bigint_js__WEBPACK_IMPORTED_MODULE_6__.parseBigintDef),
/* harmony export */   parseBooleanDef: () => (/* reexport safe */ _parsers_boolean_js__WEBPACK_IMPORTED_MODULE_7__.parseBooleanDef),
/* harmony export */   parseBrandedDef: () => (/* reexport safe */ _parsers_branded_js__WEBPACK_IMPORTED_MODULE_8__.parseBrandedDef),
/* harmony export */   parseCatchDef: () => (/* reexport safe */ _parsers_catch_js__WEBPACK_IMPORTED_MODULE_9__.parseCatchDef),
/* harmony export */   parseDateDef: () => (/* reexport safe */ _parsers_date_js__WEBPACK_IMPORTED_MODULE_10__.parseDateDef),
/* harmony export */   parseDef: () => (/* reexport safe */ _parseDef_js__WEBPACK_IMPORTED_MODULE_3__.parseDef),
/* harmony export */   parseDefaultDef: () => (/* reexport safe */ _parsers_default_js__WEBPACK_IMPORTED_MODULE_11__.parseDefaultDef),
/* harmony export */   parseEffectsDef: () => (/* reexport safe */ _parsers_effects_js__WEBPACK_IMPORTED_MODULE_12__.parseEffectsDef),
/* harmony export */   parseEnumDef: () => (/* reexport safe */ _parsers_enum_js__WEBPACK_IMPORTED_MODULE_13__.parseEnumDef),
/* harmony export */   parseIntersectionDef: () => (/* reexport safe */ _parsers_intersection_js__WEBPACK_IMPORTED_MODULE_14__.parseIntersectionDef),
/* harmony export */   parseLiteralDef: () => (/* reexport safe */ _parsers_literal_js__WEBPACK_IMPORTED_MODULE_15__.parseLiteralDef),
/* harmony export */   parseMapDef: () => (/* reexport safe */ _parsers_map_js__WEBPACK_IMPORTED_MODULE_16__.parseMapDef),
/* harmony export */   parseNativeEnumDef: () => (/* reexport safe */ _parsers_nativeEnum_js__WEBPACK_IMPORTED_MODULE_17__.parseNativeEnumDef),
/* harmony export */   parseNeverDef: () => (/* reexport safe */ _parsers_never_js__WEBPACK_IMPORTED_MODULE_18__.parseNeverDef),
/* harmony export */   parseNullDef: () => (/* reexport safe */ _parsers_null_js__WEBPACK_IMPORTED_MODULE_19__.parseNullDef),
/* harmony export */   parseNullableDef: () => (/* reexport safe */ _parsers_nullable_js__WEBPACK_IMPORTED_MODULE_20__.parseNullableDef),
/* harmony export */   parseNumberDef: () => (/* reexport safe */ _parsers_number_js__WEBPACK_IMPORTED_MODULE_21__.parseNumberDef),
/* harmony export */   parseObjectDef: () => (/* reexport safe */ _parsers_object_js__WEBPACK_IMPORTED_MODULE_22__.parseObjectDef),
/* harmony export */   parseOptionalDef: () => (/* reexport safe */ _parsers_optional_js__WEBPACK_IMPORTED_MODULE_23__.parseOptionalDef),
/* harmony export */   parsePipelineDef: () => (/* reexport safe */ _parsers_pipeline_js__WEBPACK_IMPORTED_MODULE_24__.parsePipelineDef),
/* harmony export */   parsePromiseDef: () => (/* reexport safe */ _parsers_promise_js__WEBPACK_IMPORTED_MODULE_25__.parsePromiseDef),
/* harmony export */   parseReadonlyDef: () => (/* reexport safe */ _parsers_readonly_js__WEBPACK_IMPORTED_MODULE_26__.parseReadonlyDef),
/* harmony export */   parseRecordDef: () => (/* reexport safe */ _parsers_record_js__WEBPACK_IMPORTED_MODULE_27__.parseRecordDef),
/* harmony export */   parseSetDef: () => (/* reexport safe */ _parsers_set_js__WEBPACK_IMPORTED_MODULE_28__.parseSetDef),
/* harmony export */   parseStringDef: () => (/* reexport safe */ _parsers_string_js__WEBPACK_IMPORTED_MODULE_29__.parseStringDef),
/* harmony export */   parseTupleDef: () => (/* reexport safe */ _parsers_tuple_js__WEBPACK_IMPORTED_MODULE_30__.parseTupleDef),
/* harmony export */   parseUndefinedDef: () => (/* reexport safe */ _parsers_undefined_js__WEBPACK_IMPORTED_MODULE_31__.parseUndefinedDef),
/* harmony export */   parseUnionDef: () => (/* reexport safe */ _parsers_union_js__WEBPACK_IMPORTED_MODULE_32__.parseUnionDef),
/* harmony export */   parseUnknownDef: () => (/* reexport safe */ _parsers_unknown_js__WEBPACK_IMPORTED_MODULE_33__.parseUnknownDef),
/* harmony export */   primitiveMappings: () => (/* reexport safe */ _parsers_union_js__WEBPACK_IMPORTED_MODULE_32__.primitiveMappings),
/* harmony export */   setResponseValueAndErrors: () => (/* reexport safe */ _errorMessages_js__WEBPACK_IMPORTED_MODULE_2__.setResponseValueAndErrors),
/* harmony export */   zodPatterns: () => (/* reexport safe */ _parsers_string_js__WEBPACK_IMPORTED_MODULE_29__.zodPatterns),
/* harmony export */   zodToJsonSchema: () => (/* reexport safe */ _zodToJsonSchema_js__WEBPACK_IMPORTED_MODULE_34__.zodToJsonSchema)
/* harmony export */ });
/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Options.js */ "./node_modules/zod-to-json-schema/dist/esm/Options.js");
/* harmony import */ var _Refs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Refs.js */ "./node_modules/zod-to-json-schema/dist/esm/Refs.js");
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
/* harmony import */ var _parsers_any_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parsers/any.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/any.js");
/* harmony import */ var _parsers_array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parsers/array.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/array.js");
/* harmony import */ var _parsers_bigint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parsers/bigint.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js");
/* harmony import */ var _parsers_boolean_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parsers/boolean.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js");
/* harmony import */ var _parsers_branded_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parsers/branded.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/branded.js");
/* harmony import */ var _parsers_catch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parsers/catch.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/catch.js");
/* harmony import */ var _parsers_date_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parsers/date.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/date.js");
/* harmony import */ var _parsers_default_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parsers/default.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/default.js");
/* harmony import */ var _parsers_effects_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./parsers/effects.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/effects.js");
/* harmony import */ var _parsers_enum_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parsers/enum.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/enum.js");
/* harmony import */ var _parsers_intersection_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./parsers/intersection.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js");
/* harmony import */ var _parsers_literal_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./parsers/literal.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/literal.js");
/* harmony import */ var _parsers_map_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./parsers/map.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/map.js");
/* harmony import */ var _parsers_nativeEnum_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./parsers/nativeEnum.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js");
/* harmony import */ var _parsers_never_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./parsers/never.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/never.js");
/* harmony import */ var _parsers_null_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./parsers/null.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/null.js");
/* harmony import */ var _parsers_nullable_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./parsers/nullable.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js");
/* harmony import */ var _parsers_number_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./parsers/number.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/number.js");
/* harmony import */ var _parsers_object_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./parsers/object.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/object.js");
/* harmony import */ var _parsers_optional_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./parsers/optional.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/optional.js");
/* harmony import */ var _parsers_pipeline_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./parsers/pipeline.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js");
/* harmony import */ var _parsers_promise_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./parsers/promise.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/promise.js");
/* harmony import */ var _parsers_readonly_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./parsers/readonly.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js");
/* harmony import */ var _parsers_record_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./parsers/record.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/record.js");
/* harmony import */ var _parsers_set_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./parsers/set.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/set.js");
/* harmony import */ var _parsers_string_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./parsers/string.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/string.js");
/* harmony import */ var _parsers_tuple_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./parsers/tuple.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js");
/* harmony import */ var _parsers_undefined_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./parsers/undefined.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js");
/* harmony import */ var _parsers_union_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./parsers/union.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/union.js");
/* harmony import */ var _parsers_unknown_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./parsers/unknown.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js");
/* harmony import */ var _zodToJsonSchema_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./zodToJsonSchema.js */ "./node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js");




































/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_zodToJsonSchema_js__WEBPACK_IMPORTED_MODULE_34__.zodToJsonSchema);

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js":
/*!**************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parseDef.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDef: () => (/* binding */ parseDef)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var _parsers_any_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers/any.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/any.js");
/* harmony import */ var _parsers_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parsers/array.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/array.js");
/* harmony import */ var _parsers_bigint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parsers/bigint.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js");
/* harmony import */ var _parsers_boolean_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parsers/boolean.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js");
/* harmony import */ var _parsers_branded_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parsers/branded.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/branded.js");
/* harmony import */ var _parsers_catch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parsers/catch.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/catch.js");
/* harmony import */ var _parsers_date_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parsers/date.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/date.js");
/* harmony import */ var _parsers_default_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parsers/default.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/default.js");
/* harmony import */ var _parsers_effects_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parsers/effects.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/effects.js");
/* harmony import */ var _parsers_enum_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parsers/enum.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/enum.js");
/* harmony import */ var _parsers_intersection_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parsers/intersection.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js");
/* harmony import */ var _parsers_literal_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parsers/literal.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/literal.js");
/* harmony import */ var _parsers_map_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./parsers/map.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/map.js");
/* harmony import */ var _parsers_nativeEnum_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parsers/nativeEnum.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js");
/* harmony import */ var _parsers_never_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./parsers/never.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/never.js");
/* harmony import */ var _parsers_null_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./parsers/null.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/null.js");
/* harmony import */ var _parsers_nullable_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./parsers/nullable.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js");
/* harmony import */ var _parsers_number_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./parsers/number.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/number.js");
/* harmony import */ var _parsers_object_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./parsers/object.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/object.js");
/* harmony import */ var _parsers_optional_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./parsers/optional.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/optional.js");
/* harmony import */ var _parsers_pipeline_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./parsers/pipeline.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js");
/* harmony import */ var _parsers_promise_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./parsers/promise.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/promise.js");
/* harmony import */ var _parsers_record_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./parsers/record.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/record.js");
/* harmony import */ var _parsers_set_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./parsers/set.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/set.js");
/* harmony import */ var _parsers_string_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./parsers/string.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/string.js");
/* harmony import */ var _parsers_tuple_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./parsers/tuple.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js");
/* harmony import */ var _parsers_undefined_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./parsers/undefined.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js");
/* harmony import */ var _parsers_union_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./parsers/union.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/union.js");
/* harmony import */ var _parsers_unknown_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./parsers/unknown.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js");
/* harmony import */ var _parsers_readonly_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./parsers/readonly.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js");
/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./Options.js */ "./node_modules/zod-to-json-schema/dist/esm/Options.js");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
































function parseDef(def, refs) {
  var forceResolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var seenItem = refs.seen.get(def);
  if (refs.override) {
    var _refs$override;
    var overrideResult = (_refs$override = refs.override) === null || _refs$override === void 0 ? void 0 : _refs$override.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== _Options_js__WEBPACK_IMPORTED_MODULE_30__.ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    var seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== undefined) {
      return seenSchema;
    }
  }
  var newItem = {
    def: def,
    path: refs.currentPath,
    jsonSchema: undefined
  };
  refs.seen.set(def, newItem);
  var jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = function get$ref(item, refs) {
  switch (refs.$refStrategy) {
    case "root":
      return {
        $ref: item.path.join("/")
      };
    case "relative":
      return {
        $ref: getRelativePath(refs.currentPath, item.path)
      };
    case "none":
    case "seen":
      {
        if (item.path.length < refs.currentPath.length && item.path.every(function (value, index) {
          return refs.currentPath[index] === value;
        })) {
          console.warn("Recursive reference detected at ".concat(refs.currentPath.join("/"), "! Defaulting to any"));
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : undefined;
      }
  }
};
var getRelativePath = function getRelativePath(pathA, pathB) {
  var i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString()].concat(_toConsumableArray(pathB.slice(i))).join("/");
};
var selectParser = function selectParser(def, typeName, refs) {
  switch (typeName) {
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodString:
      return (0,_parsers_string_js__WEBPACK_IMPORTED_MODULE_24__.parseStringDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodNumber:
      return (0,_parsers_number_js__WEBPACK_IMPORTED_MODULE_17__.parseNumberDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodObject:
      return (0,_parsers_object_js__WEBPACK_IMPORTED_MODULE_18__.parseObjectDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodBigInt:
      return (0,_parsers_bigint_js__WEBPACK_IMPORTED_MODULE_2__.parseBigintDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodBoolean:
      return (0,_parsers_boolean_js__WEBPACK_IMPORTED_MODULE_3__.parseBooleanDef)();
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodDate:
      return (0,_parsers_date_js__WEBPACK_IMPORTED_MODULE_6__.parseDateDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodUndefined:
      return (0,_parsers_undefined_js__WEBPACK_IMPORTED_MODULE_26__.parseUndefinedDef)();
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodNull:
      return (0,_parsers_null_js__WEBPACK_IMPORTED_MODULE_15__.parseNullDef)(refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodArray:
      return (0,_parsers_array_js__WEBPACK_IMPORTED_MODULE_1__.parseArrayDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodUnion:
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return (0,_parsers_union_js__WEBPACK_IMPORTED_MODULE_27__.parseUnionDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodIntersection:
      return (0,_parsers_intersection_js__WEBPACK_IMPORTED_MODULE_10__.parseIntersectionDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodTuple:
      return (0,_parsers_tuple_js__WEBPACK_IMPORTED_MODULE_25__.parseTupleDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodRecord:
      return (0,_parsers_record_js__WEBPACK_IMPORTED_MODULE_22__.parseRecordDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodLiteral:
      return (0,_parsers_literal_js__WEBPACK_IMPORTED_MODULE_11__.parseLiteralDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodEnum:
      return (0,_parsers_enum_js__WEBPACK_IMPORTED_MODULE_9__.parseEnumDef)(def);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodNativeEnum:
      return (0,_parsers_nativeEnum_js__WEBPACK_IMPORTED_MODULE_13__.parseNativeEnumDef)(def);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodNullable:
      return (0,_parsers_nullable_js__WEBPACK_IMPORTED_MODULE_16__.parseNullableDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodOptional:
      return (0,_parsers_optional_js__WEBPACK_IMPORTED_MODULE_19__.parseOptionalDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodMap:
      return (0,_parsers_map_js__WEBPACK_IMPORTED_MODULE_12__.parseMapDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodSet:
      return (0,_parsers_set_js__WEBPACK_IMPORTED_MODULE_23__.parseSetDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodLazy:
      return parseDef(def.getter()._def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodPromise:
      return (0,_parsers_promise_js__WEBPACK_IMPORTED_MODULE_21__.parsePromiseDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodNaN:
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodNever:
      return (0,_parsers_never_js__WEBPACK_IMPORTED_MODULE_14__.parseNeverDef)();
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodEffects:
      return (0,_parsers_effects_js__WEBPACK_IMPORTED_MODULE_8__.parseEffectsDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodAny:
      return (0,_parsers_any_js__WEBPACK_IMPORTED_MODULE_0__.parseAnyDef)();
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodUnknown:
      return (0,_parsers_unknown_js__WEBPACK_IMPORTED_MODULE_28__.parseUnknownDef)();
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodDefault:
      return (0,_parsers_default_js__WEBPACK_IMPORTED_MODULE_7__.parseDefaultDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodBranded:
      return (0,_parsers_branded_js__WEBPACK_IMPORTED_MODULE_4__.parseBrandedDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodReadonly:
      return (0,_parsers_readonly_js__WEBPACK_IMPORTED_MODULE_29__.parseReadonlyDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodCatch:
      return (0,_parsers_catch_js__WEBPACK_IMPORTED_MODULE_5__.parseCatchDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodPipeline:
      return (0,_parsers_pipeline_js__WEBPACK_IMPORTED_MODULE_20__.parsePipelineDef)(def, refs);
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodFunction:
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodVoid:
    case zod__WEBPACK_IMPORTED_MODULE_31__.ZodFirstPartyTypeKind.ZodSymbol:
      return undefined;
    default:
      /* c8 ignore next */
      return function (_) {
        return undefined;
      }(typeName);
  }
};
var addMeta = function addMeta(def, refs, jsonSchema) {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/any.js":
/*!*****************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/any.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAnyDef: () => (/* binding */ parseAnyDef)
/* harmony export */ });
function parseAnyDef() {
  return {};
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/array.js":
/*!*******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/array.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseArrayDef: () => (/* binding */ parseArrayDef)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



function parseArrayDef(def, refs) {
  var _def$type, _def$type2;
  var res = {
    type: "array"
  };
  if ((_def$type = def.type) !== null && _def$type !== void 0 && _def$type._def && ((_def$type2 = def.type) === null || _def$type2 === void 0 || (_def$type2 = _def$type2._def) === null || _def$type2 === void 0 ? void 0 : _def$type2.typeName) !== zod__WEBPACK_IMPORTED_MODULE_2__.ZodFirstPartyTypeKind.ZodAny) {
    res.items = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_1__.parseDef)(def.type._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.currentPath), ["items"])
    }));
  }
  if (def.minLength) {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js":
/*!********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseBigintDef: () => (/* binding */ parseBigintDef)
/* harmony export */ });
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function parseBigintDef(def, refs) {
  var res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  var _iterator = _createForOfIteratorHelper(def.checks),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var check = _step.value;
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
            } else {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
            } else {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return res;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseBooleanDef: () => (/* binding */ parseBooleanDef)
/* harmony export */ });
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/branded.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/branded.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseBrandedDef: () => (/* binding */ parseBrandedDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");

function parseBrandedDef(_def, refs) {
  return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(_def.type._def, refs);
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/catch.js":
/*!*******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/catch.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCatchDef: () => (/* binding */ parseCatchDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");

var parseCatchDef = function parseCatchDef(def, refs) {
  return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.innerType._def, refs);
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/date.js":
/*!******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/date.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDateDef: () => (/* binding */ parseDateDef)
/* harmony export */ });
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function parseDateDef(def, refs, overrideDateStrategy) {
  var strategy = overrideDateStrategy !== null && overrideDateStrategy !== void 0 ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map(function (item, i) {
        return parseDateDef(def, refs, item);
      })
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = function integerDateParser(def, refs) {
  var res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  var _iterator = _createForOfIteratorHelper(def.checks),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var check = _step.value;
      switch (check.kind) {
        case "min":
          (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minimum", check.value,
          // This is in milliseconds
          check.message, refs);
          break;
        case "max":
          (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maximum", check.value,
          // This is in milliseconds
          check.message, refs);
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return res;
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/default.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/default.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDefaultDef: () => (/* binding */ parseDefaultDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

function parseDefaultDef(_def, refs) {
  return _objectSpread(_objectSpread({}, (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(_def.innerType._def, refs)), {}, {
    "default": _def.defaultValue()
  });
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/effects.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/effects.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseEffectsDef: () => (/* binding */ parseEffectsDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");

function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(_def.schema._def, refs) : {};
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/enum.js":
/*!******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/enum.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseEnumDef: () => (/* binding */ parseEnumDef)
/* harmony export */ });
function parseEnumDef(def) {
  return {
    type: "string",
    "enum": def.values
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseIntersectionDef: () => (/* binding */ parseIntersectionDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
var _excluded = ["additionalProperties"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var isJsonSchema7AllOfType = function isJsonSchema7AllOfType(type) {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  var allOf = [(0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.left._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["allOf", "0"])
  })), (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.right._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["allOf", "1"])
  }))].filter(function (x) {
    return !!x;
  });
  var unevaluatedProperties = refs.target === "jsonSchema2019-09" ? {
    unevaluatedProperties: false
  } : undefined;
  var mergedAllOf = [];
  // If either of the schemas is an allOf, merge them into a single allOf
  allOf.forEach(function (schema) {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push.apply(mergedAllOf, _toConsumableArray(schema.allOf));
      if (schema.unevaluatedProperties === undefined) {
        // If one of the schemas has no unevaluatedProperties set,
        // the merged schema should also have no unevaluatedProperties set
        unevaluatedProperties = undefined;
      }
    } else {
      var nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        var additionalProperties = schema.additionalProperties,
          rest = _objectWithoutProperties(schema, _excluded);
        nestedSchema = rest;
      } else {
        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties
        unevaluatedProperties = undefined;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? _objectSpread({
    allOf: mergedAllOf
  }, unevaluatedProperties) : undefined;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/literal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/literal.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseLiteralDef: () => (/* binding */ parseLiteralDef)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function parseLiteralDef(def, refs) {
  var parsedType = _typeof(def.value);
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      "enum": [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    "const": def.value
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/map.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseMapDef: () => (/* binding */ parseMapDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
/* harmony import */ var _record_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./record.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/record.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return (0,_record_js__WEBPACK_IMPORTED_MODULE_1__.parseRecordDef)(def, refs);
  }
  var keys = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.keyType._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["items", "items", "0"])
  })) || {};
  var values = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.valueType._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["items", "items", "1"])
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js":
/*!************************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseNativeEnumDef: () => (/* binding */ parseNativeEnumDef)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function parseNativeEnumDef(def) {
  var object = def.values;
  var actualKeys = Object.keys(def.values).filter(function (key) {
    return typeof object[object[key]] !== "number";
  });
  var actualValues = actualKeys.map(function (key) {
    return object[key];
  });
  var parsedTypes = Array.from(new Set(actualValues.map(function (values) {
    return _typeof(values);
  })));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    "enum": actualValues
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/never.js":
/*!*******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/never.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseNeverDef: () => (/* binding */ parseNeverDef)
/* harmony export */ });
function parseNeverDef() {
  return {
    not: {}
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/null.js":
/*!******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/null.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseNullDef: () => (/* binding */ parseNullDef)
/* harmony export */ });
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    "enum": ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseNullableDef: () => (/* binding */ parseNullableDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
/* harmony import */ var _union_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./union.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/union.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: _union_js__WEBPACK_IMPORTED_MODULE_1__.primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [_union_js__WEBPACK_IMPORTED_MODULE_1__.primitiveMappings[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    var _base = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.innerType._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: _toConsumableArray(refs.currentPath)
    }));
    if (_base && '$ref' in _base) return {
      allOf: [_base],
      nullable: true
    };
    return _base && _objectSpread(_objectSpread({}, _base), {}, {
      nullable: true
    });
  }
  var base = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.innerType._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["anyOf", "0"])
  }));
  return base && {
    anyOf: [base, {
      type: "null"
    }]
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/number.js":
/*!********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/number.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseNumberDef: () => (/* binding */ parseNumberDef)
/* harmony export */ });
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function parseNumberDef(def, refs) {
  var res = {
    type: "number"
  };
  if (!def.checks) return res;
  var _iterator = _createForOfIteratorHelper(def.checks),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var check = _step.value;
      switch (check.kind) {
        case "int":
          res.type = "integer";
          (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.addErrorMessage)(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
            } else {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
            } else {
              (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return res;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/object.js":
/*!********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/object.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseObjectDef: () => (/* binding */ parseObjectDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

function decideAdditionalProperties(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    var _parseDef;
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : (_parseDef = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.catchall._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.currentPath), ["additionalProperties"])
    }))) !== null && _parseDef !== void 0 ? _parseDef : true;
  } else {
    var _parseDef2;
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_parseDef2 = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.catchall._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.currentPath), ["additionalProperties"])
    }))) !== null && _parseDef2 !== void 0 ? _parseDef2 : true;
  }
}
function parseObjectDef(def, refs) {
  var result = _objectSpread(_objectSpread({
    type: "object"
  }, Object.entries(def.shape()).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      propName = _ref2[0],
      propDef = _ref2[1];
    if (propDef === undefined || propDef._def === undefined) return acc;
    var parsedDef = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(propDef._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.currentPath), ["properties", propName]),
      propertyPath: [].concat(_toConsumableArray(refs.currentPath), ["properties", propName])
    }));
    if (parsedDef === undefined) return acc;
    return {
      properties: _objectSpread(_objectSpread({}, acc.properties), {}, _defineProperty({}, propName, parsedDef)),
      required: propDef.isOptional() ? acc.required : [].concat(_toConsumableArray(acc.required), [propName])
    };
  }, {
    properties: {},
    required: []
  })), {}, {
    additionalProperties: decideAdditionalProperties(def, refs)
  });
  if (!result.required.length) delete result.required;
  return result;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/optional.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/optional.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseOptionalDef: () => (/* binding */ parseOptionalDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var parseOptionalDef = function parseOptionalDef(def, refs) {
  var _refs$propertyPath;
  if (refs.currentPath.toString() === ((_refs$propertyPath = refs.propertyPath) === null || _refs$propertyPath === void 0 ? void 0 : _refs$propertyPath.toString())) {
    return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.innerType._def, refs);
  }
  var innerSchema = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.innerType._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["anyOf", "1"])
  }));
  return innerSchema ? {
    anyOf: [{
      not: {}
    }, innerSchema]
  } : {};
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parsePipelineDef: () => (/* binding */ parsePipelineDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var parsePipelineDef = function parsePipelineDef(def, refs) {
  if (refs.pipeStrategy === "input") {
    return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def["in"]._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.out._def, refs);
  }
  var a = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def["in"]._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["allOf", "0"])
  }));
  var b = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.out._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["allOf", a ? "1" : "0"])
  }));
  return {
    allOf: [a, b].filter(function (x) {
      return x !== undefined;
    })
  };
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/promise.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/promise.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parsePromiseDef: () => (/* binding */ parsePromiseDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");

function parsePromiseDef(def, refs) {
  return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.type._def, refs);
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseReadonlyDef: () => (/* binding */ parseReadonlyDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");

var parseReadonlyDef = function parseReadonlyDef(def, refs) {
  return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.innerType._def, refs);
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/record.js":
/*!********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/record.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseRecordDef: () => (/* binding */ parseRecordDef)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/string.js");
/* harmony import */ var _branded_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./branded.js */ "./node_modules/zod-to-json-schema/dist/esm/parsers/branded.js");
var _excluded = ["type"],
  _excluded2 = ["type"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




function parseRecordDef(def, refs) {
  var _def$keyType, _parseDef2, _def$keyType2, _def$keyType$_def$che, _def$keyType3, _def$keyType4, _def$keyType$_def$typ;
  if (refs.target === "openApi3" && ((_def$keyType = def.keyType) === null || _def$keyType === void 0 ? void 0 : _def$keyType._def.typeName) === zod__WEBPACK_IMPORTED_MODULE_3__.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce(function (acc, key) {
        var _parseDef;
        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, (_parseDef = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.valueType._def, _objectSpread(_objectSpread({}, refs), {}, {
          currentPath: [].concat(_toConsumableArray(refs.currentPath), ["properties", key])
        }))) !== null && _parseDef !== void 0 ? _parseDef : {}));
      }, {}),
      additionalProperties: false
    };
  }
  var schema = {
    type: "object",
    additionalProperties: (_parseDef2 = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.valueType._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.currentPath), ["additionalProperties"])
    }))) !== null && _parseDef2 !== void 0 ? _parseDef2 : {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_def$keyType2 = def.keyType) === null || _def$keyType2 === void 0 ? void 0 : _def$keyType2._def.typeName) === zod__WEBPACK_IMPORTED_MODULE_3__.ZodFirstPartyTypeKind.ZodString && (_def$keyType$_def$che = def.keyType._def.checks) !== null && _def$keyType$_def$che !== void 0 && _def$keyType$_def$che.length) {
    var _parseStringDef = (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.parseStringDef)(def.keyType._def, refs),
      type = _parseStringDef.type,
      keyType = _objectWithoutProperties(_parseStringDef, _excluded);
    return _objectSpread(_objectSpread({}, schema), {}, {
      propertyNames: keyType
    });
  } else if (((_def$keyType3 = def.keyType) === null || _def$keyType3 === void 0 ? void 0 : _def$keyType3._def.typeName) === zod__WEBPACK_IMPORTED_MODULE_3__.ZodFirstPartyTypeKind.ZodEnum) {
    return _objectSpread(_objectSpread({}, schema), {}, {
      propertyNames: {
        "enum": def.keyType._def.values
      }
    });
  } else if (((_def$keyType4 = def.keyType) === null || _def$keyType4 === void 0 ? void 0 : _def$keyType4._def.typeName) === zod__WEBPACK_IMPORTED_MODULE_3__.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === zod__WEBPACK_IMPORTED_MODULE_3__.ZodFirstPartyTypeKind.ZodString && (_def$keyType$_def$typ = def.keyType._def.type._def.checks) !== null && _def$keyType$_def$typ !== void 0 && _def$keyType$_def$typ.length) {
    var _parseBrandedDef = (0,_branded_js__WEBPACK_IMPORTED_MODULE_2__.parseBrandedDef)(def.keyType._def, refs),
      _type = _parseBrandedDef.type,
      _keyType = _objectWithoutProperties(_parseBrandedDef, _excluded2);
    return _objectSpread(_objectSpread({}, schema), {}, {
      propertyNames: _keyType
    });
  }
  return schema;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/set.js":
/*!*****************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/set.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseSetDef: () => (/* binding */ parseSetDef)
/* harmony export */ });
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


function parseSetDef(def, refs) {
  var items = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_1__.parseDef)(def.valueType._def, _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.currentPath), ["items"])
  }));
  var schema = {
    type: "array",
    uniqueItems: true,
    items: items
  };
  if (def.minSize) {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/string.js":
/*!********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/string.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseStringDef: () => (/* binding */ parseStringDef),
/* harmony export */   zodPatterns: () => (/* binding */ zodPatterns)
/* harmony export */ });
/* harmony import */ var _errorMessages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errorMessages.js */ "./node_modules/zod-to-json-schema/dist/esm/errorMessages.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

var emojiRegex;
/**
 * Generated from the regular expressions found here as of 2024-05-22:
 * https://github.com/colinhacks/zod/blob/master/src/types.ts.
 *
 * Expressions with /i flag have been changed accordingly.
 */
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: function emoji() {
    if (emojiRegex === undefined) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function parseStringDef(def, refs) {
  var res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    var _iterator = _createForOfIteratorHelper(def.checks),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var check = _step.value;
        switch (check.kind) {
          case "min":
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern(res, zodPatterns.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern(res, zodPatterns.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern(res, zodPatterns.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern(res, RegExp("^".concat(processPattern(check.value))), check.message, refs);
            break;
          case "endsWith":
            addPattern(res, RegExp("".concat(processPattern(check.value), "$")), check.message, refs);
            break;
          case "datetime":
            addFormat(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat(res, "date", check.message, refs);
            break;
          case "time":
            addFormat(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat(res, "duration", check.message, refs);
            break;
          case "length":
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes":
            {
              addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
              break;
            }
          case "ip":
            {
              if (check.version !== "v6") {
                addFormat(res, "ipv4", check.message, refs);
              }
              if (check.version !== "v4") {
                addFormat(res, "ipv6", check.message, refs);
              }
              break;
            }
          case "emoji":
            addPattern(res, zodPatterns.emoji, check.message, refs);
            break;
          case "ulid":
            {
              addPattern(res, zodPatterns.ulid, check.message, refs);
              break;
            }
          case "base64":
            {
              switch (refs.base64Strategy) {
                case "format:binary":
                  {
                    addFormat(res, "binary", check.message, refs);
                    break;
                  }
                case "contentEncoding:base64":
                  {
                    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(res, "contentEncoding", "base64", check.message, refs);
                    break;
                  }
                case "pattern:zod":
                  {
                    addPattern(res, zodPatterns.base64, check.message, refs);
                    break;
                  }
              }
              break;
            }
          case "nanoid":
            {
              addPattern(res, zodPatterns.nanoid, check.message, refs);
            }
          case "toLowerCase":
          case "toUpperCase":
          case "trim":
            break;
          default:
            /* c8 ignore next */
            (function (_) {})(check);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return res;
}
var escapeNonAlphaNumeric = function escapeNonAlphaNumeric(value) {
  return Array.from(value).map(function (c) {
    return /[a-zA-Z0-9]/.test(c) ? c : "\\".concat(c);
  }).join("");
};
var addFormat = function addFormat(schema, value, message, refs) {
  var _schema$anyOf;
  if (schema.format || (_schema$anyOf = schema.anyOf) !== null && _schema$anyOf !== void 0 && _schema$anyOf.some(function (x) {
    return x.format;
  })) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push(_objectSpread({
        format: schema.format
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: {
          format: schema.errorMessage.format
        }
      }));
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push(_objectSpread({
      format: value
    }, message && refs.errorMessages && {
      errorMessage: {
        format: message
      }
    }));
  } else {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(schema, "format", value, message, refs);
  }
};
var addPattern = function addPattern(schema, regex, message, refs) {
  var _schema$allOf;
  if (schema.pattern || (_schema$allOf = schema.allOf) !== null && _schema$allOf !== void 0 && _schema$allOf.some(function (x) {
    return x.pattern;
  })) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push(_objectSpread({
        pattern: schema.pattern
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: {
          pattern: schema.errorMessage.pattern
        }
      }));
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push(_objectSpread({
      pattern: processRegExp(regex, refs)
    }, message && refs.errorMessages && {
      errorMessage: {
        pattern: message
      }
    }));
  } else {
    (0,_errorMessages_js__WEBPACK_IMPORTED_MODULE_0__.setResponseValueAndErrors)(schema, "pattern", processRegExp(regex, refs), message, refs);
  }
};
// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true
var processRegExp = function processRegExp(regexOrFunction, refs) {
  var regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
  if (!refs.applyRegexFlags || !regex.flags) return regex.source;
  // Currently handled flags
  var flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s") // `.` matches newlines
  };
  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!
  var source = flags.i ? regex.source.toLowerCase() : regex.source;
  var pattern = "";
  var isEscaped = false;
  var inCharGroup = false;
  var inCharRange = false;
  for (var i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          var _source;
          if (inCharRange) {
            pattern += source[i];
            pattern += "".concat(source[i - 2], "-").concat(source[i]).toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && (_source = source[i + 2]) !== null && _source !== void 0 && _source.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += "".concat(source[i]).concat(source[i].toUpperCase());
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += "[".concat(source[i]).concat(source[i].toUpperCase(), "]");
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += "(^|(?<=[\r\n]))";
        continue;
      } else if (source[i] === "$") {
        pattern += "($|(?=[\r\n]))";
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? "".concat(source[i], "\r\n") : "[".concat(source[i], "\r\n]");
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    var regexTest = new RegExp(pattern);
  } catch (_unused) {
    console.warn("Could not convert regex pattern at ".concat(refs.currentPath.join("/"), " to a flag-independent form! Falling back to the flag-ignorant source"));
    return regex.source;
  }
  return pattern;
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js":
/*!*******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseTupleDef: () => (/* binding */ parseTupleDef)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(function (x, i) {
        return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(x._def, _objectSpread(_objectSpread({}, refs), {}, {
          currentPath: [].concat(_toConsumableArray(refs.currentPath), ["items", "".concat(i)])
        }));
      }).reduce(function (acc, x) {
        return x === undefined ? acc : [].concat(_toConsumableArray(acc), [x]);
      }, []),
      additionalItems: (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(def.rest._def, _objectSpread(_objectSpread({}, refs), {}, {
        currentPath: [].concat(_toConsumableArray(refs.currentPath), ["additionalItems"])
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(function (x, i) {
        return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(x._def, _objectSpread(_objectSpread({}, refs), {}, {
          currentPath: [].concat(_toConsumableArray(refs.currentPath), ["items", "".concat(i)])
        }));
      }).reduce(function (acc, x) {
        return x === undefined ? acc : [].concat(_toConsumableArray(acc), [x]);
      }, [])
    };
  }
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js":
/*!***********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseUndefinedDef: () => (/* binding */ parseUndefinedDef)
/* harmony export */ });
function parseUndefinedDef() {
  return {
    not: {}
  };
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/union.js":
/*!*******************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/union.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseUnionDef: () => (/* binding */ parseUnionDef),
/* harmony export */   primitiveMappings: () => (/* binding */ primitiveMappings)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3") return asAnyOf(def, refs);
  var options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.
  if (options.every(function (x) {
    return x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length);
  })) {
    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}
    var types = options.reduce(function (types, x) {
      var type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43
      return type && !types.includes(type) ? [].concat(_toConsumableArray(types), [type]) : types;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every(function (x) {
    return x._def.typeName === "ZodLiteral" && !x.description;
  })) {
    // all options literals
    var _types = options.reduce(function (acc, x) {
      var type = _typeof(x._def.value);
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [].concat(_toConsumableArray(acc), [type]);
        case "bigint":
          return [].concat(_toConsumableArray(acc), ["integer"]);
        case "object":
          if (x._def.value === null) return [].concat(_toConsumableArray(acc), ["null"]);
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (_types.length === options.length) {
      // all the literals are primitive, as far as null can be considered primitive
      var uniqueTypes = _types.filter(function (x, i, a) {
        return a.indexOf(x) === i;
      });
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        "enum": options.reduce(function (acc, x) {
          return acc.includes(x._def.value) ? acc : [].concat(_toConsumableArray(acc), [x._def.value]);
        }, [])
      };
    }
  } else if (options.every(function (x) {
    return x._def.typeName === "ZodEnum";
  })) {
    return {
      type: "string",
      "enum": options.reduce(function (acc, x) {
        return [].concat(_toConsumableArray(acc), _toConsumableArray(x._def.values.filter(function (x) {
          return !acc.includes(x);
        })));
      }, [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = function asAnyOf(def, refs) {
  var anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(function (x, i) {
    return (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(x._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.currentPath), ["anyOf", "".concat(i)])
    }));
  }).filter(function (x) {
    return !!x && (!refs.strictUnions || _typeof(x) === "object" && Object.keys(x).length > 0);
  });
  return anyOf.length ? {
    anyOf: anyOf
  } : undefined;
};

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseUnknownDef: () => (/* binding */ parseUnknownDef)
/* harmony export */ });
function parseUnknownDef() {
  return {};
}

/***/ }),

/***/ "./node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   zodToJsonSchema: () => (/* binding */ zodToJsonSchema)
/* harmony export */ });
/* harmony import */ var _parseDef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseDef.js */ "./node_modules/zod-to-json-schema/dist/esm/parseDef.js");
/* harmony import */ var _Refs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Refs.js */ "./node_modules/zod-to-json-schema/dist/esm/Refs.js");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }


var zodToJsonSchema = function zodToJsonSchema(schema, options) {
  var _parseDef2;
  var refs = (0,_Refs_js__WEBPACK_IMPORTED_MODULE_1__.getRefs)(options);
  var definitions = _typeof(options) === "object" && options.definitions ? Object.entries(options.definitions).reduce(function (acc, _ref) {
    var _parseDef;
    var _ref2 = _slicedToArray(_ref, 2),
      name = _ref2[0],
      schema = _ref2[1];
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, name, (_parseDef = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(schema._def, _objectSpread(_objectSpread({}, refs), {}, {
      currentPath: [].concat(_toConsumableArray(refs.basePath), [refs.definitionPath, name])
    }), true)) !== null && _parseDef !== void 0 ? _parseDef : {}));
  }, {}) : undefined;
  var name = typeof options === "string" ? options : (options === null || options === void 0 ? void 0 : options.nameStrategy) === "title" ? undefined : options === null || options === void 0 ? void 0 : options.name;
  var main = (_parseDef2 = (0,_parseDef_js__WEBPACK_IMPORTED_MODULE_0__.parseDef)(schema._def, name === undefined ? refs : _objectSpread(_objectSpread({}, refs), {}, {
    currentPath: [].concat(_toConsumableArray(refs.basePath), [refs.definitionPath, name])
  }), false)) !== null && _parseDef2 !== void 0 ? _parseDef2 : {};
  var title = _typeof(options) === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
  if (title !== undefined) {
    main.title = title;
  }
  var combined = name === undefined ? definitions ? _objectSpread(_objectSpread({}, main), {}, _defineProperty({}, refs.definitionPath, definitions)) : main : _defineProperty({
    $ref: [].concat(_toConsumableArray(refs.$refStrategy === "relative" ? [] : refs.basePath), [refs.definitionPath, name]).join("/")
  }, refs.definitionPath, _objectSpread(_objectSpread({}, definitions), {}, _defineProperty({}, name, main)));
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
};


/***/ }),

/***/ "./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BRAND: () => (/* binding */ BRAND),
/* harmony export */   DIRTY: () => (/* binding */ DIRTY),
/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),
/* harmony export */   INVALID: () => (/* binding */ INVALID),
/* harmony export */   NEVER: () => (/* binding */ NEVER),
/* harmony export */   OK: () => (/* binding */ OK),
/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),
/* harmony export */   Schema: () => (/* binding */ ZodType),
/* harmony export */   ZodAny: () => (/* binding */ ZodAny),
/* harmony export */   ZodArray: () => (/* binding */ ZodArray),
/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),
/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),
/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),
/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),
/* harmony export */   ZodDate: () => (/* binding */ ZodDate),
/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),
/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),
/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),
/* harmony export */   ZodError: () => (/* binding */ ZodError),
/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),
/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),
/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),
/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),
/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),
/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),
/* harmony export */   ZodMap: () => (/* binding */ ZodMap),
/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),
/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),
/* harmony export */   ZodNever: () => (/* binding */ ZodNever),
/* harmony export */   ZodNull: () => (/* binding */ ZodNull),
/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),
/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),
/* harmony export */   ZodObject: () => (/* binding */ ZodObject),
/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),
/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),
/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),
/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),
/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),
/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),
/* harmony export */   ZodSchema: () => (/* binding */ ZodType),
/* harmony export */   ZodSet: () => (/* binding */ ZodSet),
/* harmony export */   ZodString: () => (/* binding */ ZodString),
/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),
/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),
/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),
/* harmony export */   ZodType: () => (/* binding */ ZodType),
/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),
/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),
/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),
/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),
/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),
/* harmony export */   any: () => (/* binding */ anyType),
/* harmony export */   array: () => (/* binding */ arrayType),
/* harmony export */   bigint: () => (/* binding */ bigIntType),
/* harmony export */   boolean: () => (/* binding */ booleanType),
/* harmony export */   coerce: () => (/* binding */ coerce),
/* harmony export */   custom: () => (/* binding */ custom),
/* harmony export */   date: () => (/* binding */ dateType),
/* harmony export */   datetimeRegex: () => (/* binding */ datetimeRegex),
/* harmony export */   "default": () => (/* binding */ z),
/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),
/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),
/* harmony export */   effect: () => (/* binding */ effectsType),
/* harmony export */   "enum": () => (/* binding */ enumType),
/* harmony export */   "function": () => (/* binding */ functionType),
/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),
/* harmony export */   getParsedType: () => (/* binding */ getParsedType),
/* harmony export */   "instanceof": () => (/* binding */ instanceOfType),
/* harmony export */   intersection: () => (/* binding */ intersectionType),
/* harmony export */   isAborted: () => (/* binding */ isAborted),
/* harmony export */   isAsync: () => (/* binding */ isAsync),
/* harmony export */   isDirty: () => (/* binding */ isDirty),
/* harmony export */   isValid: () => (/* binding */ isValid),
/* harmony export */   late: () => (/* binding */ late),
/* harmony export */   lazy: () => (/* binding */ lazyType),
/* harmony export */   literal: () => (/* binding */ literalType),
/* harmony export */   makeIssue: () => (/* binding */ makeIssue),
/* harmony export */   map: () => (/* binding */ mapType),
/* harmony export */   nan: () => (/* binding */ nanType),
/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),
/* harmony export */   never: () => (/* binding */ neverType),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   nullable: () => (/* binding */ nullableType),
/* harmony export */   number: () => (/* binding */ numberType),
/* harmony export */   object: () => (/* binding */ objectType),
/* harmony export */   objectUtil: () => (/* binding */ objectUtil),
/* harmony export */   oboolean: () => (/* binding */ oboolean),
/* harmony export */   onumber: () => (/* binding */ onumber),
/* harmony export */   optional: () => (/* binding */ optionalType),
/* harmony export */   ostring: () => (/* binding */ ostring),
/* harmony export */   pipeline: () => (/* binding */ pipelineType),
/* harmony export */   preprocess: () => (/* binding */ preprocessType),
/* harmony export */   promise: () => (/* binding */ promiseType),
/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),
/* harmony export */   record: () => (/* binding */ recordType),
/* harmony export */   set: () => (/* binding */ setType),
/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),
/* harmony export */   strictObject: () => (/* binding */ strictObjectType),
/* harmony export */   string: () => (/* binding */ stringType),
/* harmony export */   symbol: () => (/* binding */ symbolType),
/* harmony export */   transformer: () => (/* binding */ effectsType),
/* harmony export */   tuple: () => (/* binding */ tupleType),
/* harmony export */   undefined: () => (/* binding */ undefinedType),
/* harmony export */   union: () => (/* binding */ unionType),
/* harmony export */   unknown: () => (/* binding */ unknownType),
/* harmony export */   util: () => (/* binding */ util),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   z: () => (/* binding */ z)
/* harmony export */ });
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === errorMap ? undefined : errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result)
            ? result.then((data) => freeze(data))
            : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
function custom(check, params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return util; },
    get objectUtil () { return objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    datetimeRegex: datetimeRegex,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./scripts/browserAgent.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=browserAgent.bundle.js.map